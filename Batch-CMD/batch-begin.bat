@REM Файл сохранен в кодировке DOS-866. (╘рщы ёюїЁрэхэ т ъюфшЁютъх DOS-866).
@REM Коммандой REM задаётся комментарий до конца строки. Символ @ отключает показ этой строки в консоли при включенном режиме "echo on".

@echo off & REM Отключение режима показа исполняемых комманд в консоли. Оператор & соединяет в одной строке несколько комманд скрипта, которые по умолчанию принято писать в отдельных строках. При таком объеденинении комманды считаются одним блоком. Альтернативный синтаксис выделения блока - заключить комманды в круглые скобки.

goto :mimimi & REM Переход к именованой метке в коде (имя метки начинается с двоеточия)
    Тут произвольный текст. Т.е. в строках которые никогда не будут выполнены можно написать многострочный комментарий.
    Но удобнее этот приём использовать для отключения временно ненужных участков кода. Тогда для включения достаточно закомментировать строку начальную строку goto
    goto :eof & REM Переход в конец скрипта 
    REM Запуск внешнего скрипта
    call mimimi2.bat  & REM С ожиданием выполнения
    start mimimi2.bat & REM Асинхронно
    REM Текст внешнего скрипта можно внести в текущий скрипт после метки и вызывать такой строкой:
    exit &    REM Полное завершение работы интерпретатора комманд CMD.EXE
    exit /b & REM Завершение работы текущего скрипта с возвратом в точку, из которой скрипт был вызван.
:mimimi

REM Вывод текста в консоль
<Nul set /P $V=Hello world! & REM без переноса строки (Здесь хитрость! На экран выводится сообщение якобы предлагающее пользователю ввести данные, но командой <nul на вход подаётся пустой набор данных. В итоге сообщение остается на экране без переноса строки.)
echo Hello world!           & REM с переносом строки (команда echo выводит на экран размещенное после неё сообщение)

goto :contin

REM Перенаправление вывода 
echo Hello world! > tempfile.txt  & REM в файл с перезаписью файла
echo Hello world! >> tempfile.txt & REM в файл с дописью в конец файла
echo Hello world! > nul           & REM в пустой поток (если надо просто скрыть вывод с экрана консоли)


REM Паузы в работе программы
ping 127.0.0.1 -n 3 > nul    & REM Пауза выполнения на 3 секунды (Хитрость! Запуск утилиты пингования сервера три раза - она выполняется 1 секунду. )
pause                   & REM Пауза выполнения до нажатия любой клавиши   
set /P $V=Нажмите ENTER & REM Пауза выполнения до нажатия клавиши Enter (Скрипт фактически ожидает ввода текстовой строки чтобы сохранить её в переменную $V)

:contin

    REM **********************
    REM  РАБОТА С ПЕРЕМЕННЫМИ  
    REM **********************
   
REM Инициализация переменной
set VARSTR=Hello & REM Все переменные сохраняются как строки вместе с пробелами от знака "=" до переноса строки. 
set VARSTR=Hello2 & REM Проинициализированную переменную можно перезаписать новым значением
REM Максимальный размер переменной вместе с названием: 8192 байта. Максимальный общий размер всех переменных среды, включая имена переменных и знак равенства, составляет 65536 Кбайт.

if defined VARSTR echo Переменная существует & REM Проверка инициализирована ли переменная
set NUMB2 = %NUMB1% & REM Для подстановки значения переменной её нужно обрамлять с двух сторон символами % %
echo В переменной VARSTR хранится значение %VARSTR% & REM Вывод значения переменной на экран

REM Арифметические операции (работают только с целыми 32-битными числами со знаком)
set /a NUMB1 = (7 + 2 - 3) * 4 & REM Параметр /a указывает что строку нужно воспринимать как арифметическое выражение. Результат может быть только целым числом со знаком разрядностью 32 бита. Пробелы игнорируются поэтому их можно использовать для форматирования.
set /a NUMB1 = 4 + 2 , NUMB2 = 7 - 9 , NUMB3 = 5 * 8 & REM 
set /a NUMB1 = 9 / 5 & REM Результат равен 1, поскольку берётся только целая часть от деления, а остаток отбрасывается. В скриптах доступно только целочисленное деление.
set /a NUMB1 = 31 %% 8 & REM Остаток от деления.
REM 

REM Унарные арифметические операторы
set /a NUMB2 = !NUMB1 & REM Аналог логического "НЕ". Возвратит 1, если NUMB1 равен 0, и возвратит 1 в другом случае. 
set /a NUMB2 = -NUMB1 & REM Вычитание из 0. Т.е. смена знака.
set /a NUMB2 = ~NUMB1 & REM Побитовая инверсия - вычитание из -1. Т.е. смена знака и одновременный декремент. Полезна в связке с операцией смены знака
set /a NUMB2 = -~NUMB1 & REM Инкремент
set /a NUMB2 = ~-NUMB1 & REM Декремент

REM Комбинированные операторы
set /a NUMB1 += 9 & REM Увеличение значения на указанное число. Эквивалентно NUMB1 = %NUBM1% + 9. 
REM Аналогичным образом доступны операции -= *= /= %=


REM Битовые арифметические операции
set /a NUMB2 = NUMB1 ">>" 1 & REM Двоичный сдвиг вправо на указанное число битов (фактически деление на 2 в степени указанного числа). Оператор пишется в двойных кавычках. Для отрицательных чисел знак сохраняется в старших битах (число 11___110 = -2 сдвигается в число 11___111 = -1 и т.д.)  
set /a NUMB2 = NUMB1 "<<" 1 & REM Двоичный сдвиг влево (фактически умножение на 2 в степени указанного числа)
set /a NUMB2 = NUMB1 "&" NUMB2 & REM Побитовое И (AND). Используется для установки в нужные биты значения 0.
set /a NUMB2 = NUMB1 "|" NUMB2 & REM Побитовое ИЛИ (OR). Используется для установки в нужные биты значения 1. 
set /a NUMB2 = NUMB1 "^" NUMB2 & REM Побитовое исключающее ИЛИ (XOR). Используется для смены значений нужных битов на противоположные.

REM Операторы сравнения и логические операторы предусмотрены только в операторе условного выполнения команд IF
if Str1==Str1 set RESULT=yes           & REM Логический оператор равенства ==
if Str1 EQU Str1 set RESULT=equal      & REM Альтернативный вариант равенства EQU
if Str1 NEQ Str2 set RESULT=not equal  & REM Логический оператор неравенства NEQ
if 5 LSS 7 set RESULT=smaller          & REM Меньше LSS
if 5 LEQ 7 set RESULT=smaller or equal & REM Меньше или равно LEQ
if 9 GTR 7 set RESULT=bigger           & REM Больше - GTR
if 9 GEQ 7 set RESULT=bigger or equal  & REM Больше или равно - GEQ
if not Str1==Str2 set RESULT=yes       & REM Логический оператор отрицания NOT
REM Логических операторов И и ИЛИ (конъюнкции и дизъюнкции не предусмотрено). Их можно реализовать с помощью переходов по меткам или через введение дополнительных переменных.

REM Использование переменных
echo В переменной NUMB1 хранится значение %NUMB1% & REM Для подстановки значения переменной её нужно обрамлять c двух сторон символами % %
set /a NUMB1 = %NUMB1% + 5 & REM Для присвоения нового значения можно использовать эту же переменную, пока в ней хранится старое значение.
set /a NUMB2 = NUMB1 + 5 & REM При вычислении числовых значений переменные можно использовать без обрамляющих знаков %%. В обоих случаях строковое значение переменной будет преобразовываться в целое число.

REM Указание области видимости переменной
set V1=Глобальное значение
setlocal & REM Команды setlocal и endlocal задают область кода в которой все изменения переменных будут локальными для этой области
    set V1=Локальное значение
    echo Внутри локальной области V1 = %V1% & REM Тут получаем локальное значение
endlocal
echo Снаружи локальной области V1 = %V1% & REM Тут получаем глобальное значение

setlocal ENABLEDELAYEDEXPANSION & REM Для того чтобы иметь доступ к новым значениям переменных внутри программных блоков, нужно включить режим отложенной подстановки их значений. По умолчанию вместо имён переменных внутри блока (...) подставляются их значения, которые были до начала выполнения этого блока. Если же нужно получить новые значения, то при включенной отложенной подстановке нужно использовать обрамляющие символы !! вместо %%
( set V1=Новое значение
  set V2=%V1%
  set V3=!V1!
  echo Внутри блока у V2 значение !V2! & REM Тут получаем старое значение
  echo Внутри блока у V3 значение !V3! & REM Тут получаем новое значение
)
echo Снаружи блока у V3 значение %V3% & REM Снаружи блока наконец-то можно использовать обычные обрамляющие символы %%
endlocal

REM Подстановка содержимого переменной в код программы для выполнения
set PINGER1=ping 127.0.0.1 -n 1
%PINGER1% & REM Будет выполнена комманда, текст которой сохранен в переменной. Более сложные многострочные конструкции можно сохранить в файл и вызвать коммандой call

REM Ввод данных в переменные
Set /P VARSTR=Введите текст: & REM Запрос пользователю ввести строку текста. Введенная с клавиатуры строка записшется в переменную VARSTR

    REM ***************************************
    REM  РАБОТА С ПРОЦЕДУРАМИ (ПОДПРОГРАММАМИ)  
    REM ***************************************

    REM Процедура - блок программы, которому могут передаваться или не передаваться на вход аргументы, но который (в отличие от функции в классических   языках программирования) не возвращает значения, а просто совершает некие побочные действия (ввод/вывод, изменение значений глобальных переменных и т.д.).

REM Если процедура объявляется в начале или середине скрипта, то чтобы она не выполнилась сама по себе перед ней ставится переход на метку после объявления процедуры. Если она объявлена в конце скрипта, то перед её объявлением можно просто завершить работу скрипта командами exit или goto :eof
goto :contin2 
    REM Имя процедуры задётся обычной меткой. 
    :proc1 
        echo Выполняется процедура proc1 & REM Здесь тело процедуры (в данном случае - вывод демонстрационного сообщения)
    exit /b & REM Эта команда завершает выполнение процедуры и делает возврат исполнения в точку, из которой процедура была вызвана.

    :proc2 
        REM Значения аргументов, переданных в процедуру, можно подставлять в команды используя специальные переменные %1 %2 %3 и т.д.
        set ARGDEMO=Первый аргумент равен %1, второй аргумент равен %2, а третий - %3.
    exit /b
:contin2

    REM ********************
REM Вызов процедуры без аргументов (аналогичен простому вызову другого скрипта)
call :proc1
REM Передача аргументов в процедуру (или другой скрипт). Это текстовые строки, разделенные пробелами. Если нужно в самом аргументе использовать пробелы, то текст строки нужно заключить в двойные кавычки:
call :proc2 октябрь 2018 "Тестовая строка"
echo %ARGDEMO%& REM Особенность: Переменные, присвоенные внутри процедуры (внешнего скрипта) не являются локальными и доступны после её выполнения. А значит могут быть потеряны значения, которые в них были до вызова процедуры.


    REM ********************
    REM  РАБОТА С ФУНКЦИЯМИ   
    REM ********************

    REM Функция - это блок программы, который прнимает на вход аргументы и возвращает некое значение (или значения). В BAT-скриптах функции не предусмотрены. Но всё-таки  (помимо изменения глобальных переменных) значения можно "возвращать" либо печатью текста в стандартное устройство вывода, либо через передачу 32-битного числового значения ошибки. В первом случае требуется запуск функции из внешнего файла. Для удобства несколько функций объединены в одном внешнем скрипте batch-begin-lib.bat

set STRING1=test & REM Демонстрационная переменная, которая будет подаваться на вход функции
REM Для сохранения возвращенного функцией значения в новую переменную нужно воспользоваться конструкцией для обработки результатов работы команд. В качестве команды используется имя внешнего скрипта и аргументы запуска (имя функции и передаваемая строка), заключенные в одинарные кавычки:
for /f "delims=" %%A in ('batch-begin-lib.bat func1 %STRING1%') do set STRING2=%%A& REM Функция принимает на вход STRING1 и возвращает STRING2
echo Функция возвращает %STRING2%

REM Более короткий вариант возврата значения - через указание в вызове функции имени переменой для сохранения. Это также удобно тем, что функцию можно не выносить в отдельный скрипт:
call batch-begin-lib.bat func1 %STRING1% STRING3 > nul
echo Альтернативный возврат значения: %STRING3%


goto :contin3 
    REM Функция возведения в квадрат возвращает число через код ошибки (указываемый в команде exit)
    :sqr [число которое нужно возвести в квадрат]
        REM Для наглядности полезно после имени метки в квадратных скобках указать, что должно быть передано в аргументах
        setlocal
        set /a RESULT=%1*%1
    endlocal & exit /b %RESULT% & REM Запись в одну строку позволяет подставить локальное значение переменной RESULT. В следующей строке после endlocal будет уже возвращаться глобальное значение.
:contin3

echo RESULT = %RESULT% & REM Функция не перезаписала переменную, что очень хорошо в плане чистоты функции (отсутствии побочных эффектов)
call :sqr 7 & REM ВЫзов функции
echo Результат работы функции SQR = %ERRORLEVEL% & REM 32-битное целое число с результатом функции сохранено в системной переменной ERRORLEVEL

    REM ******************************************
    REM  ОРГАНИЗАЦИЯ ВЕТВЛЕНИЙ В ЛОГИКЕ ПРОГРАММЫ  
    REM ******************************************

REM Условие с одной ветвью
if Str1==Str1 set RESULT=yes
REM Запись в несколько строк
if Str1==Str1 ( 
  set RESULT=yes
)

REM Условие с двумя ветвями
if Str1==Str1 set RESULT=yes else RESULT=no
REM Запись в несколько строк
if Str1==Str1 ( 
  set RESULT=yes
) else (
  set RESULT=no
)

REM Организация рекурсии используя ветвление по условиям:
goto :contin4
    REM Функция вычисления факториала
    :factorial
        setlocal
        if not %1 GEQ 0 exit /b 0 & REM Проверяем чтобы на входе было положительное число, если нет то подаём на выход 0
        if %1==0 exit /b 1
        if %1==1 exit /b 1
        set /A PREVNUMB=%1-1 
        call :factorial %PREVNUMB% 
        set /A RESULT = %1 * %ERRORLEVEL%
    endlocal & exit /b %RESULT%
:contin4
call :factorial 10 & REM Вызываем функцию вычисления факториала
echo Factorial 10 = %ERRORLEVEL%

REM Организация рекурсии со вспомогательной функцией для хранения промежуточного значения:
goto :contin5 
    REM Функция проверки числа на простоту. 1 == true, 0 == false, -1 == error
    :prime
        if %1 LEQ 0 exit /b -1
        if %1 GTR 0 call :prime_ %1 2 
    exit /b %ERRORLEVEL%

    REM Вспомогательная функция для хранения и использования промежуточного значения (до какого числа произведена проверка)
    :prime_
    setlocal ENABLEDELAYEDEXPANSION & set /a DOUBLE = %2 * %2
        if %1 LEQ 0 exit /b -1
        if %DOUBLE% GTR %1 ( set RESULT=1 
            ) else ( set /a MOD = %1 %% %2 
            if !MOD! EQU 0 ( set RESULT = 0
                ) else ( set /a NEXT = %2 + 1
                call :prime_ %1 !NEXT! ))
    endlocal & exit /b %RESULT%
:contin5
setlocal ENABLEDELAYEDEXPANSION & echo Простые числа:
for /L %%I in (0,1,100) do ( call :prime %%I
    if !ERRORLEVEL!==1 <Nul set /P $V=%%I )  
endlocal & echo.


    REM *******
    REM  ЦИКЛЫ  
    REM *******

echo Элементарный цикл - вывод чисел от 30 до 40 (с шагом 2): 
for /L %%I in (30,2,40) do echo %%I
echo Цикл, внутри которого меняются переменные (вычисление факториала):
setlocal ENABLEDELAYEDEXPANSION
set FACTORIAL=1
for /L %%I in (2,1,10) do ( 
    set /a FACTORIAL = !FACTORIAL! * %%I
)
echo Факториал 10! = %FACTORIAL%
endlocal

REM Вложенный цикл
echo Отображаем таблицу сложения:
setlocal ENABLEDELAYEDEXPANSION
for /L %%I in (1,1,5) do ( 
    for /L %%J in (1,1,5) do (   
        set /A SUMM = %%I + %%J
        <Nul set /P $V=!SUMM! 
    ) 
    echo.
) 
endlocal
 
REM Другие виды циклов реализуются через оператор goto либо рекурсию

pause
exit