{ Этот файл является модулем к демонстрационной программе Pascal_Begin.
  Модуль содержит демонстрационные подпрограммы (процедуры и функции).
  Вынос подпрограмм в отдельный модуль обычно делается для удобства структуризации и повторного
  использования кода. В нашем случае важную роль сыграло то, что язык Pascal требует описывать
  все подпрограммы до начала тела программы, а это бы нарушило последовательнось изложения учебного
  материала. Ведь в подпрограммах активно применяются циклы, работа с переменными и прочие приёмы
  программирования, основы которых в программе Pascal_Begin раскрываются позже, в теле программы. }

unit Pascal_Begin_Functions; { Модуль начинается с ключевого слова unit, за которым следует
        имя модуля. Имя модуля должно совпадать с именем PAS файла, в котором хранится модуль.
        В главном программном файле модуль подключается в разделе Uses путём указания его имени. }

{$mode ObjFPC}{$H+}{$J-} { Модули компилируются отдельно, поэтому следует указывать нужные
                     директивы компилятора, даже если они указаны в основном программном файле }
{$codepage UTF8}


interface { В разделе interface объявляются публичные переменные и публичные подпрограммы модуля,
            т.е. такие которые будут доступны в основной программе. }
  uses SysUtils;  // Подключение других модулей делается в начале раздела interface

  var unitstr1: string = 'Глобальное значение';

  procedure proc1; // Декларация простейшей процедуры
  procedure proc2;
  procedure proc3;
  procedure proc4(width,height:integer;flag:boolean);
  procedure double(var number:integer);
  function func1:string; // Декларация простейшей функции, возвращающей значение указанного типа
  function summ_sqr(a,b:integer):integer; // Ф-я суммирования квадратов двух чисел

implementation { В разделе implementation описываются тела подпрограмм.
                Объявленные здесь переменные и подпрограммы, не упомянутые в разделе interface,
                являются приватными, т.е. недоступными в основной программе }

  procedure proc1; // Объявление простейшей процедуры
  begin // Тело процедуры
    writeln('Работает процедура proc1 из модуля Pascal_Begin_Functions');
  end;

  // Область видимости переменных
  procedure proc2;
  var s1, s2, unitstr1: string; // Объявление переменных внутри подпрограммы
  begin
    unitstr1 := 'Локальное значение';
    { При совпадении имён локальной и глобальной переменной в теле подпрограммы  используется
      локальная переменная. Доступ к локальным переменным подпрограммы возможен только внутри
      тела подпрограммы. }
    writeln('Значение локальной переменной unitstr1: ', unitstr1);
    // Доступ к одноимённой глобальной переменной - через добавление имени модуля или программы:
    writeln('Значение глобальной переменной unitstr1: ', Pascal_Begin_Functions.unitstr1);
    // Глобальную переменную можно менять:
    Pascal_Begin_Functions.unitstr1 := 'Новое глобальное значение';
    writeln('Новое значение глобальной переменной unitstr1: ', Pascal_Begin_Functions.unitstr1);
  end;

  // Поведение статических переменных, объявленных в подпрограмме
  procedure proc3;
  var s1:string;
  const {$J+} s2:string ='Начальное значение'; {$J-} { Эта инициализация сработает только на этапе
      компиляции и при последующих вызовах процедуры значение не перезапишется }
  begin
    s1 := 'Начальное значение'; // При каждом вызове функции переменная получает это значение
    s1 += ' + дополнение'; // Это присвоение бесполезно, т.к. нигде не сохранится
    s2 += ' + дополнение'; // Новое значение s2 будет доступно при следующем вызове процедуры
  end;

  // Использование именованных аргументов при вызове подпрограммы:
  procedure proc4(width,height:integer;flag:boolean); // Аргументы перечисляются с указанием типов
  begin // При вызове подпрограммы тип передаваемых значений должен соответсвовать типу аргумента
    // Имена аргументов становятся локальными переменным внутри подпрограммы
    writeln('Ширина: ',width,'. Высота: ',height);
    width *= 2; // Аргумент, став локальной переменной, может принимать новые значения
    writeln('Ширина: ',width,'. Высота: ',height);
  end;

  // Передача в качестве аргумента не значения, а ссылки на значение переменной:
  procedure double(var number:integer); // Ключевое слово var перед именем аргумента определяет,
  begin                                 // что аргумент является ссылкой на переданное значение
    number *= 2; // Изменяется глобальное значение переменной, переданной в качестве аргумента
  end;

  // Объявление функции, возвращающей значение указанного типа:
  function func1:string;
  begin // Тело функции
    // Возвращаемое значение присваивается имени функции:
    func1 := 'Результат работы функции func1 из модуля Pascal_Begin_Functions';
    { Также для возврата значения можно вместо имени функции использовать индентификатор result,
      который доступен при включенной директиве компилятора {$modeswitch result+} }
    result := 'Другой результат работы функции func1 из модуля Pascal_Begin_Functions';
    write(' (внимание!) '); { Этот оператор выполнится, поскольку присвоение
            значения в имя функции или в result не останавливает работу функции.
            В режиме {$mode objFPC} можно избежать такого поведения, используя инструкцию exit }
    exit('Финальный результат работы функции func1 из модуля Pascal_Begin_Functions');
    write('Пока!'); // Этот оператор не будет выполнен, поскольку exit завершил работу функции
  end;

  function summ_sqr(a,b:integer):integer;
  begin
    result := a*a + b*b;
  end;



initialization { Код в разделе initialization будет выполнен при подключении модуля. }
  writeln('Начинает работать модуль Pascal_Begin_Function...');

finalization { Код в разделе finalization будет выполнен при окончании работы программы. }
  writeln('Модуль Pascal_Begin_Function совершает финальные действия...');

end. // Модуль заканчивается ключевым словом end. (с точкой в конце)

