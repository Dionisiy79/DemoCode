{ Этот файл является модулем к демонстрационной программе Pascal_Begin.
  Модуль содержит демонстрационные подпрограммы (процедуры и функции).
  Вынос подпрограмм в отдельный модуль обычно делается для удобства структуризации и повторного
  использования кода. В нашем случае важную роль сыграло то, что язык Pascal требует описывать
  все подпрограммы до начала тела программы, а это бы нарушило последовательнось изложения учебного
  материала. Ведь в подпрограммах активно применяются циклы, работа с переменными и прочие приёмы
  программирования, основы которых в программе Pascal_Begin раскрываются позже, в теле программы. }

unit Pascal_Begin_Functions; { Модуль начинается с ключевого слова unit, за которым следует
        имя модуля. Имя модуля должно совпадать с именем PAS файла, в котором хранится модуль.
        В главном программном файле модуль подключается в разделе Uses путём указания его имени. }

{$mode ObjFPC}{$H+}{$J-} { Модули компилируются отдельно, поэтому следует указывать нужные
                     директивы компилятора, даже если они указаны в основном программном файле }
{$codepage UTF8}

//Эта директива разрешает использование особого типа переменных - ссылок на вложенные процедуры:
{$modeswitch nestedprocvars}

interface { В разделе interface объявляются публичные переменные и публичные подпрограммы модуля,
            т.е. такие которые будут доступны в основной программе. }
  uses SysUtils;  // Подключение других модулей делается в начале раздела interface

  var unitstr1: string = 'Глобальное значение';

  procedure proc1; // Декларация простейшей процедуры
  procedure proc2;
  procedure proc3;
  procedure proc4(width,height:integer;flag:boolean);
  procedure proc4b(width:integer; height:integer=100);
  procedure proc5(a: array of byte);
  procedure proc5b(a: array of const);
  procedure double(var number:integer; out prev_value:integer);
  procedure proc6(var a:integer; const b:integer; constref c:integer);
  procedure proc7(var a);
  procedure double2(var number:integer); inline; // Декларация встариваемой процедуры
  function func1:string; // Декларация простейшей функции, возвращающей значение указанного типа
  function summ_sqr(a,b:integer):integer; // Ф-я суммирования квадратов двух чисел

  type FuncType1 = function (a,b:integer):integer; { Объявление процедурного типа, описывающего
                             функцию принимающую два числа integer, и возвращающую число integer }
  var func_pointer1: FuncType1; //Переменная, которая может хранить ссылку на функции типа FuncType1
      procPointer1: procedure; // Можно объявить процедурную переменную напрямую, без создания типа
      procPointer2: procedure is nested;  // Ссылка на вложенную процедуру - отдельный тип

  function ApplyFunc1(f:FuncType1; a,b,c:integer):integer; // Функция высшего порядка
  function sum(a,b:integer):integer; // Функция суммирования двух чисел
  procedure localProc1;

implementation { В разделе implementation описываются тела подпрограмм.
                Объявленные здесь переменные и подпрограммы, не упомянутые в разделе interface,
                являются приватными, т.е. недоступными в основной программе }

  procedure proc1; // Объявление простейшей подпрограммы
  begin // Тело подпрограммы
    writeln('Работает процедура proc1 из модуля Pascal_Begin_Functions');
  end;

  // Область видимости переменных
  procedure proc2;
  var s1, s2, unitstr1: string; // Объявление переменных внутри подпрограммы
  begin
    unitstr1 := 'Локальное значение';
    { При совпадении имён локальной и глобальной переменной в теле подпрограммы  используется
      локальная переменная. Доступ к локальным переменным подпрограммы возможен только внутри
      тела подпрограммы. }
    writeln('Значение локальной переменной unitstr1: ', unitstr1);
    // Доступ к одноимённой глобальной переменной - через добавление имени модуля или программы:
    writeln('Значение глобальной переменной unitstr1: ', Pascal_Begin_Functions.unitstr1);
    // Глобальную переменную можно менять:
    Pascal_Begin_Functions.unitstr1 := 'Новое глобальное значение';
    writeln('Новое значение глобальной переменной unitstr1: ', Pascal_Begin_Functions.unitstr1);
  end;

  // Поведение статических переменных, объявленных в подпрограмме
  procedure proc3;
  var s1:string;
  const {$J+} s2:string ='Начальное значение'; {$J-} { Эта инициализация сработает только на этапе
      компиляции и при последующих вызовах процедуры значение не перезапишется }
  begin
    s1 := 'Начальное значение'; // При каждом вызове функции переменная получает это значение
    s1 += ' + дополнение'; // Это присвоение бесполезно, т.к. нигде не сохранится
    s2 += ' + дополнение'; // Новое значение s2 будет доступно при следующем вызове процедуры
  end;

  // Использование именованных аргументов при вызове подпрограммы:
  procedure proc4(width,height:integer;flag:boolean); // Аргументы перечисляются с указанием типов
  begin // При вызове подпрограммы тип передаваемых значений должен соответсвовать типу аргумента
    // Имена аргументов становятся локальными переменным внутри подпрограммы
    writeln('Ширина: ',width,'. Высота: ',height);
    width *= 2; // Аргумент, став локальной переменной, может принимать новые значения
    writeln('Ширина: ',width,'. Высота: ',height);
  end;

  // Необязательные именованные аргументы:
  procedure proc4b(width:integer; height:integer=100); // Можно задать значения по умолчанию
  begin // Если у последних аргументов указаны значения по умолчанию, то их
    writeln('Ширина: ',width,'. Высота: ',height); // не обязательно указывать при вызове процедуры
  end;

  // Неименованные аргументы можно передавать с помощью "открытого" массива (т.е. неопред. длины)
  procedure proc5(a: array of byte);
  var i:integer;
  begin
    for i:=0 to high(a) do writeln('Аргумент №', i,' = ', a[i]);
  end;

  // Через специальный массив констант можно передать разнотипные неименованные аргументы
  // Каждый элемента такого массива имеет тип TVarRec - запись с вариантами
  procedure proc5b(a: array of const);
  var i:integer;
  begin
    write('Получены аргументы: ');
    for i:=0 to high(a) do
      case a[i].VType of  // Доступ к аргументам, как к вариантам записи
        vtInteger    : write(           a[i].VInteger         ,', ');
        vtBoolean    : write(           a[i].VBoolean         ,', ');
        vtchar       : write(           a[i].VChar            ,', ');
        vtextended   : write(           a[i].VExtended^       ,', ');
        vtString     : write(           a[i].VString^         ,', ');
        vtPointer    : write(   Longint(a[i].VPointer)        ,', ');
        vtPChar      : write(           a[i].VPChar           ,', ');
        vtObject     : write(           a[i].VObject.Classname,', ');
        vtClass      : write(           a[i].VClass.Classname ,', ');
        vtAnsiString : write(AnsiString(a[i].VAnsiString)     ,', ');
      else write ('(Аргумент неизвестного типа) : ',a[i].vtype);
      end; writeln;
  end;

  // Передача в качестве аргумента не значения, а ссылки на значение переменной:
  { Ключевое слово var означает, что аргумент является ссылкой на переданное значение:
    Ключевое слово out - аналог var с той лишь разницей, что переменную планируется использовать
    только для записи, но не для чтения. Это позволяет передавать в подпрограмму
    непроинициализированные переменные без появления предупреждений компилятора.
    При этом если переменная ссылается на структуру со счётчиком ссылок (например строку), то
    этот счётчик уменьшается на единицу - т.е. считается что переменная больше не ссылается
    на эти данные и если не записать в неё новую информацию, то она может ссылаться на мусорные
    данные либо быть равной nil.}
  procedure double( var number:integer; out prev_value:integer);
  begin
    prev_value := number;
    number *= 2; // Изменяется глобальное значение переменной, переданной в качестве аргумента
  end;

  // Защита от изменения аргументов, переданных по ссылке:
  procedure proc6(var a:integer;   // Простая передача переменной по ссылке, её можно менять.
                  const b:integer; { Гибридный способ - малые по объёму переменные перeдаются
                                   по значению, а большие по ссылке. При этом их нельзя изменять. }
                  constref c:integer); { Передача и малых и больших переменных по ссылке
                                         без возможности их изменения. }
  begin
    a *= 2; // Первый аргумент никак не защищён и может свободно изменяться.
  end;      // Остальные - доступны только для чтения.

  // Нетипизированные аргументы можно предать по ссылке:
  procedure proc7(var a); // Аргумент является ссылкой на ячейку памяти неопределённого типа
  begin  // Для доступа к значению в ячейке памяти нужно использовать ручное приведение типа:
    writeln('Получен символ ',char(a));  // Приведение к типу Char
    writeln('Получено число ', byte(a)); // Приведение к числу
  end;

  procedure double2(var number:integer);
    inline; { Ключевое слово inline после имени подпрограммы указывает, что тело подпрограммы
              должно подставляться непосредственно в код во всех местах использования подпрограммы
              (вместо вызова подпрограммы с созданием соответсвующего окружения) }
    begin number *= 2;end;

  procedure proc8a; forward; { Ключевое слово forward после имени подпрограммы объявляет,
                               что описание самой подпрограммы будет размещено ниже. }
  procedure proc8b;
    begin proc8a; end; // Вызов ранее неописанной процедуры благодаря forward-объявлению
  procedure proc8a;    // Обещанное описание forward-процедуры
    begin writeln('Выполняется процедура, объявленная через forward'); end;

  // Объявление функции, возвращающей значение указанного типа:
  function func1:string;
  begin // Тело функции
    // Возвращаемое значение присваивается имени функции:
    func1 := 'Результат работы функции func1 из модуля Pascal_Begin_Functions';
    { Также для возврата значения можно вместо имени функции использовать индентификатор result,
      который доступен при включенной директиве компилятора {$modeswitch result+} }
    result := 'Другой результат работы функции func1 из модуля Pascal_Begin_Functions';
    write(' (внимание!) '); { Этот оператор выполнится, поскольку присвоение
            значения в имя функции или в result не останавливает работу функции.
            В режиме {$mode objFPC} можно избежать такого поведения, используя инструкцию exit }
    exit('Финальный результат работы функции func1 из модуля Pascal_Begin_Functions');
    write('Пока!'); // Этот оператор не будет выполнен, поскольку exit завершил работу функции
  end;

  function summ_sqr(a,b:integer):integer;
  begin
    result := a*a + b*b;
  end;

  function sum(a,b:integer):integer; // Функция суммирования двух чисел
  begin
    result := a+b;
  end;

  // Функция высшего порядка - принимает на вход другую функцию, соответствующую типу FuncType1
  function ApplyFunc1(f:FuncType1; a,b,c:integer):integer;
  var x:integer;
  begin // В этом примере к аргументам a,b,c попарно применяется функция f
    x      := f(a,b);
    result := f(x,c);
  end;

  procedure localProc1;
    procedure localProc2; // Можно создавать вложенные подпрограммы неограниченного уровня
    begin
      writeln('Работает вложенная функция localFunc2');
    end;
  begin
    localProc2(); // Вложенная подпрограмма видна только внутри подпрограммы более высокого уровня
    procPointer2 := @localProc2; // Но можно передать её адрес в глобальную процедурную переменную
  end;

initialization { Код в разделе initialization будет выполнен при подключении модуля. }
  writeln('Начинает работать модуль Pascal_Begin_Function...');

finalization { Код в разделе finalization будет выполнен при окончании работы программы. }
  writeln('Модуль Pascal_Begin_Function совершает финальные действия...');

end. // Модуль заканчивается ключевым словом end. (с точкой в конце)

