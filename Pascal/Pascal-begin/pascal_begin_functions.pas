{ Этот файл является модулем к демонстрационной программе Pascal_Begin.
  Модуль содержит демонстрационные подпрограммы (процедуры и функции).
  Вынос подпрограмм в отдельный модуль обычно делается для удобства структуризации и повторного
  использования кода. В нашем случае важную роль сыграло то, что язык Pascal требует описывать
  все подпрограммы до начала тела программы, а это бы нарушило последовательнось изложения учебного
  материала. Ведь в подпрограммах активно применяются циклы, работа с переменными и прочие приёмы
  программирования, основы которых в программе Pascal_Begin раскрываются позже, в теле программы. }

unit Pascal_Begin_Functions; { Модуль начинается с ключевого слова unit, за которым следует
        имя модуля. Имя модуля должно совпадать с именем PAS файла, в котором хранится модуль.
        В главном программном файле модуль подключается в разделе Uses путём указания его имени. }

{$mode ObjFPC}{$H+}{$J-} { Модули компилируются отдельно, поэтому следует указывать нужные
                     директивы компилятора, даже если они указаны в основном программном файле }
{$codepage UTF8}


interface { В разделе interface объявляются публичные переменные и публичные подпрограммы модуля,
            т.е. такие которые будут доступны в основной программе. }
  uses SysUtils;  // Подключение других модулей делается в начале раздела interface

  var unitstr1: string = 'Глобальное значение';

  procedure proc1; // Декларация простейшей процедуры
  procedure proc2;
  procedure proc3;
  procedure proc4(width,height:integer;flag:boolean);
  procedure proc5(width:integer; height:integer=100);
  procedure double(var number:integer);
  procedure proc6(var a:integer; const b:integer; constref c:integer);
  procedure proc7(var a);
  procedure double2(var number:integer); inline; // Декларация встариваемой процедуры
  function func1:string; // Декларация простейшей функции, возвращающей значение указанного типа
  function summ_sqr(a,b:integer):integer; // Ф-я суммирования квадратов двух чисел

implementation { В разделе implementation описываются тела подпрограмм.
                Объявленные здесь переменные и подпрограммы, не упомянутые в разделе interface,
                являются приватными, т.е. недоступными в основной программе }

  procedure proc1; // Объявление простейшей подпрограммы
  begin // Тело подпрограммы
    writeln('Работает процедура proc1 из модуля Pascal_Begin_Functions');
  end;

  // Область видимости переменных
  procedure proc2;
  var s1, s2, unitstr1: string; // Объявление переменных внутри подпрограммы
  begin
    unitstr1 := 'Локальное значение';
    { При совпадении имён локальной и глобальной переменной в теле подпрограммы  используется
      локальная переменная. Доступ к локальным переменным подпрограммы возможен только внутри
      тела подпрограммы. }
    writeln('Значение локальной переменной unitstr1: ', unitstr1);
    // Доступ к одноимённой глобальной переменной - через добавление имени модуля или программы:
    writeln('Значение глобальной переменной unitstr1: ', Pascal_Begin_Functions.unitstr1);
    // Глобальную переменную можно менять:
    Pascal_Begin_Functions.unitstr1 := 'Новое глобальное значение';
    writeln('Новое значение глобальной переменной unitstr1: ', Pascal_Begin_Functions.unitstr1);
  end;

  // Поведение статических переменных, объявленных в подпрограмме
  procedure proc3;
  var s1:string;
  const {$J+} s2:string ='Начальное значение'; {$J-} { Эта инициализация сработает только на этапе
      компиляции и при последующих вызовах процедуры значение не перезапишется }
  begin
    s1 := 'Начальное значение'; // При каждом вызове функции переменная получает это значение
    s1 += ' + дополнение'; // Это присвоение бесполезно, т.к. нигде не сохранится
    s2 += ' + дополнение'; // Новое значение s2 будет доступно при следующем вызове процедуры
  end;

  // Использование именованных аргументов при вызове подпрограммы:
  procedure proc4(width,height:integer;flag:boolean); // Аргументы перечисляются с указанием типов
  begin // При вызове подпрограммы тип передаваемых значений должен соответсвовать типу аргумента
    // Имена аргументов становятся локальными переменным внутри подпрограммы
    writeln('Ширина: ',width,'. Высота: ',height);
    width *= 2; // Аргумент, став локальной переменной, может принимать новые значения
    writeln('Ширина: ',width,'. Высота: ',height);
  end;

  // Необязательные именованные аргументы:
  procedure proc5(width:integer; height:integer=100); // Можно задать значения по умолчанию
  begin // Если у последних аргументов указаны значения по умолчанию, то их не обязательно указывать
    writeln('Ширина: ',width,'. Высота: ',height); // при вызове процедуры
  end;

  // Передача в качестве аргумента не значения, а ссылки на значение переменной:
  procedure double(var number:integer); // Ключевое слово var перед именем аргумента определяет,
  begin                                 // что аргумент является ссылкой на переданное значение
    number *= 2; // Изменяется глобальное значение переменной, переданной в качестве аргумента
  end;

  // Защита от изменения аргументов, переданных по ссылке:
  procedure proc6(var a:integer;   // Простая передача переменной по ссылке, её можно менять.
                  const b:integer; { Гибридный способ - малые по объёму переменные перeдаются
                                   по значению, а большие по ссылке. При этом их нельзя изменять. }
                  constref c:integer); { Передача и малых и больших переменных по ссылке
                                         без возможности их изменения. }
  begin
    a *= 2; // Первый аргумент никак не защищён и может свободно изменяться.
  end;      // Остальные - доступны только для чтения.

  // Нетипизированные аргументы можно предать по ссылке:
  procedure proc7(var a); // Аргумент является ссылкой на ячейку памяти неопределённого типа
  begin  // Для доступа к значению в ячейке памяти нужно использовать ручное приведение типа:
    writeln('Получен символ ',char(a));  // Приведение к типу Char
    writeln('Получено число ', byte(a)); // Приведениее к числу
  end;

  procedure double2(var number:integer);
  inline; { Ключевое слово inline перед телом подпрограммы указывает, что тело подпрограммы
            должно подставляться непосредственно в код во всех местах вызова подпрограммы
            (вместо вызова подпрограммы с созданием соответсвующего окружения) }
  begin
    number *= 2;
  end;

  // Объявление функции, возвращающей значение указанного типа:
  function func1:string;
  begin // Тело функции
    // Возвращаемое значение присваивается имени функции:
    func1 := 'Результат работы функции func1 из модуля Pascal_Begin_Functions';
    { Также для возврата значения можно вместо имени функции использовать индентификатор result,
      который доступен при включенной директиве компилятора {$modeswitch result+} }
    result := 'Другой результат работы функции func1 из модуля Pascal_Begin_Functions';
    write(' (внимание!) '); { Этот оператор выполнится, поскольку присвоение
            значения в имя функции или в result не останавливает работу функции.
            В режиме {$mode objFPC} можно избежать такого поведения, используя инструкцию exit }
    exit('Финальный результат работы функции func1 из модуля Pascal_Begin_Functions');
    write('Пока!'); // Этот оператор не будет выполнен, поскольку exit завершил работу функции
  end;

  function summ_sqr(a,b:integer):integer;
  begin
    result := a*a + b*b;
  end;



initialization { Код в разделе initialization будет выполнен при подключении модуля. }
  writeln('Начинает работать модуль Pascal_Begin_Function...');

finalization { Код в разделе finalization будет выполнен при окончании работы программы. }
  writeln('Модуль Pascal_Begin_Function совершает финальные действия...');

end. // Модуль заканчивается ключевым словом end. (с точкой в конце)

