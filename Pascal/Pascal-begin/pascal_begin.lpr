{ В этом файле расположен код программы демонстрирующей синтаксис языка программирования Free Pascal
  при использовании в среде разработки Lazarus IDE. }

// Однострочный комментарий до конца строки задается двумя косыми чертами в начале комментария
{ Многострочный комментарий - обрамляется
  фигурными скобками. }

{ Наиболее важные специальные директивы компилятора, располагаются в начале файла: }

  {$mode objfpc} // Эта директива включает режим совместимости с Object Pascal
  {$H+} // Синоним {$LongStrings ON}. В этом режиме тип string - строка неограниченной длины
        // в текущей кодировке компилятора
  {$J-} // Выключает возможность изменения типизированных констант
  {$PointerMath-} // Выключает возможность арифметических операций с указателями

{ Директивы условной компиляции - позволяют компилировать код избирательно: }

  {$define Sym1} { Объявление символа, который можно использовать в условной компиляции
    Символы unix, windows, Win32, Win64 автоматически объявляются компилятором в соответсвующих ОС }
  {$define debug} { Например можно задать символ debug и использовать его для включения
                    каких-то отладочных фрагментов своего кода (логирование, уведомления и т.п.) }
  {$undef debug} // Отмена объявления ранее объявленного символа

  // Использование символов и опций для условной компиляции:
  {$ifdef Sym1} // Проверка условия, объявлен ли указанный символ
    // Здесь помещается код, компилирующийся при объявленном символе Sym1 ...
    {$note Hello! Symbol is defined!}  // Генерация сообщения при компиляции
  {$else} // Здесь код, компилирующийся при необъявленном символе. Проверка else не обязательна.
    {$error В вашей системе код нельзя скомпилировать!} // Остановка компиляции с генерацией ошибки.
  {$endif}

  {$ifndef Sym1} { Этот код компилируется, если символ НЕ объявлен} {$endif}
  {$ifopt H+} {Этот код компилируется, если указанная опция включена} {$endif}

  { Для вывода UTF-строк в консоль есть два подхода:
    1. С помощью директивы {$codepage UTF8} Явно указать, что исходный код в кодировке UTF8.
       При этом все строки будут автоматически конвертироваться в кодировку UCS2 (внутреннюю
       кодировку FPC). А для вывода в консоль понадобится подключение модуля LazUTF - он
       автоматически преобразовывает выводимые в консоль строки в текущую кодировку консоли.
       При этом ограничивается возможность работать с UTF8-литералами, а также отображать
       символы не входящие в текущую кодовую страницу консоли.
    2. Смена системной кодировки windows на UTF-8 и изменение шрифта консоли на UTF-совместимый. }

  // Закомментируйте следующую строку для работы программы без режима {$codepage UTF8}
       {$define UTF8mode} { Создаём этот символ, как тумблер использования режима {$codepage UTF8} }

       {$ifdef UTF8mode}
         {$codepage UTF8}  { Эта директива требует от компилятора преобразовать все используемые
                             в программе строковые константы из кодировки UTF8 в UCS2}
       {$endif}

program Pascal_Begin; // Главный программный файл начинается ключевым словом PROGRAM
uses         // В разделе uses перечисляются имена подключаемых внешних модулей.
  SysUtils,  // Стандартный модуль sysutils содержит много популярных функций.
  {$ifdef UTF8mode}
    LazUTF8, { Стандартный модуль для корректной работы терминала с кодировкой UTF8
               Если этот модуль автоматически не подключается, то нужно в IDE зайти в меню:
               Проект -> Инспектор проекта -> Правый клик по Требуемые пакеты -> Добавить ->
               ищем в имя пакета LazUtils -> OK }
    {$ifdef unix}    cwstring,  {$endif} // Модуль для корректной работы модуля LazUTF8 в Linux
  {$else}
    {$ifdef windows}
       SetWinConsoleFont, // Самописный модуль автоматической смены шрифта в консоли на UTF8-шрифт
    {$endif}
  {$endif}

  {$ifdef windows} windows, {$endif} // Модуль со специфичными функциями Windows
  Math,                              // Модуль с математическими функциями и константами
  pascal_begin_functions;            // Модуль с демонстрационными процедурами и функциями

{ РАБОТА С ПЕРЕМЕННЫМИ }
// Объявление имён и типов переменных.
  { Имя переменной должно начинаться с латинской буквы или символа подчеркивания,
    может также содержать цифры. Длина имени от 1 до 127 символов.
    Написание не чувствительно к регистру.
  }
const { Объявление имён неизменяемых переменных (констант). Производится до начала
        раздела операторов указанием значения через знак равенства. Константе автоматически
        присваивается "минимальный" тип данных, достаточный для её представления.}

    NUMB_PI_ = 3.14; // Для удобства имена констант пишут заглавными буквами, но можно и строчными
    NUMB_3_2 = 3 - sqrt(2); { Константа времени компиляции - значение выражения будет
       вычислено компилятором и подставлено в код программы во всех местах использования константы }
    INTNUMB:Integer = 456; // Типизированная константа. Тип таких констант задаётся через двоеточие.
    {$J+}
    REALNUMB:Double = 789; { При включенной директиве $J+ объявленная типизированная константа,
        становится статической переменной (т.е. её можно менять по ходу программы) }
    {$J-}
    ConstStr1 = 'Привет'; // При {$codepage UTF8} строковый литерал 'Привет' конвертируется в UTF-16
    ConstStr2: AnsiString = 'Строка'; { Для типизированной строковой константы кодировка будет
      соответсвовать указанному типу. Т.е. в данном случае вместо кодировки UTF-16 получаем UTF-8 }


var // Объявление имён изменяемых переменных. Производится до начала раздела операторов.

  { СТАНДАРТНЫЕ ПРОСТЫЕ ТИПЫ ДАННЫХ }

    // Целые числа
    numb_1b : Shortint; // 1 байт  (        -128 .. 127        )
    numb_2b : Smallint; // 2 байта (      -32768 .. 32767      ) синоним Integer в режиме TP и FPC
    numb_4b : Longint;  // 4 байта ( -2147483648 .. 2147483647 ) синоним Integer в режиме ObjFPC
    numb_8b : Int64;    // 8 байт  ( -9223372036854775808 .. 9223372036854775807 )
    numb_1b_natural : Byte;   // 1 байт без знака  ( 0 .. 255   )
    numb_2b_natural : Word;   // 2 байта без знака ( 0 .. 65535 )
    numb_4b_natural : DWord;  // 4 байта без знака ( 0 .. 4294967295 ) синоним Cardinal и LongWord
    numb_8b_natural : QWord;  // 8 байт без знака  ( 0 .. 18446744073709551615 )

    // Числа для описания размеров структур данных в памяти компьютера.
    // Занимают 2, 4 или 8 байт для 16, 32 и 64-битных программ соответсвенно:
    structSize1 : SizeInt;   // Целое со знаком
    structSize2 : SizeUInt;  // Целое без знака

    i, j, n :integer; // Объявление нескольких переменных (имена пишутся через запятую).
    factorial1 : integer = 1; // Указание значения, которым переменная будет проинициализирована

    // Вещественные числа с плавающей точкой
    rnumb_4b : Single;    // 4 байта ( 2,9*10^-39   .. 1,7*10^38   )
    rnumb_6b : Real;      // 6 байт  ( 1,5*10^-45   .. 3,4*10^38   )
    rnumb_8b : Double;    // 8 байт  ( 5,0*10^-324  .. 1,7*10^308  )
    rnumb_10b : Extended; // от 4, 8 или 10 байт ( 3,4*10^-4932 .. 1,1*10^4932 )
    real1 : ValReal;      // Самый большой вещественный тип из вышеперечисленных;
    float1 : float;       // Синоним Extended в модуле Math
    // Вещественные числа с фиксированной точкой
    rnumb_8bf : Currency; // 8 байт ( -922337203685477.5808 .. 922337203685477.5807 ) -

    // Логические типы
    bool1, bool2 : Boolean; // Занимает 1 байт. Принимает значения true или false
    bool_1b: ByteBool;  // Натуральное число 1 байт. 0 = false
    bool_2b: WordBool;  // Натуральное число 2 байта.
    bool_6b: QWordBool; // Натуральное число 6 байт.

    // Символьные типы
    letter1 : char;  // 1 байт. Содержит символ в кодировке ASCII.
    wideletter1 : widechar;  // 2 байта. Unicode-символ в кодировке UTF-16.

    v1 : Variant;   // Вариативная переменная может принимать значения любого значимого типа.

  { СТАНДАРТНЫЕ СОСТАВНЫЕ ТИПЫ ДАННЫХ }

  { СТРОКИ }
    ansistr1 : ansistring;   { Строка-ANSI в текущей однобайтной системной кодировке. Безразмерная -
          завершается нулём. Переменная является указателем на область памяти, где хранится текст.
          Может хранить строки в кодировке UTF8. Почти все строки содержат внутри себя счётчик
          ссылок на себя. Если он равен 0, то строка уничтожается, освобождая память. }
    str1,str2 : string; // Строка ansistring при опции компилятора {H+}. Иначе - shortstring.
    utf8str1: UTF8String;   // Строка ansistring с явно заданной кодировкой UTF-8
    unistr1: UnicodeString; // Эквивалент AnsiString, но в двухбайтной кодировке UTF-16
    widestr1 : WideString;  // Эквивалент UnicodeString, но без встроенного счётчика ссылок
    rawstr1, rawstr2: RawByteString; { Строка без указания кодировки. Операции с такими строками
                         происходят без автоматического преобразования из одной кодировки в другую }

    // Строковые типы старого стандарта. При {$codepage utf8} они некорректно работают с литералами.
    shortstr1 : shortstring; // Строка длиной 255 символов
    shortstr2 : string[10];  // Строка shortstring длиной 10 байт
    PCharstr1 : PChar; { Указатель на символ char, как на первый символ строки, оканчивающейся
                         нулевым байтом #0  (cтандарт языка C) }

  { ФАЙЛОВЫЕ ТИПЫ }
    textfile1: text;        // Текстовый файл
    binfile1: file of char; // Бинарный файл.
    typfile1: file of real; // Типизированный файл, состоящий из компонент указанного типа.

  { СТАТИЧЕСКИЕ МАССИВЫ }
    // Статический индексированный массив в FPC - это набор однотипных элементов с доступом
    // по перечислимому индексу (числа, буквы и пр.) с фиксированным количеством элементов.

    arr1 : array [1..100] of integer; // Массив целых чисел, пронумерованных от 1 до 100
    arr2 : array ['a'..'z'] of byte; // В качестве индекса может выступать любой перечислимый тип
    arr255 : array [char] of byte; // В качестве диаппазона можно указать весь тип целиком
    SecretCodes1 : array[1..3] of byte = (17,52,84); // Можно указать значения элементов массива

    Flags1 : array [1..8] of boolean; // Такой массив занимает 8 байт памяти
    // Применение ключевого слова bitpacked уплотняет элементы побитно:
    Flags1bitpacked : bitpacked array [1..8] of boolean; // Теперь массив занимает 1 байт памяти

    // Элементами массива могут быть массивы - в этом случае получаем двухмерный массив:
    tableSum1 : array [0..2] of array [0..2] of byte;
    tableSum2 : array [0..2,0..2] of byte; // Более краткая запись
    arr3d : array [1941..1945,1..12,1..31] of integer; { Трёхмерный массив - для
      хранения значений в ячейках с индексами указывающими на год, месяц, число.}
    holo3d : array [0..9,0..9,0..9,0..9] of byte; // 4-мерный массив

  { ЗАПИСИ }
    // Запись - набор фиксированной длины из разнотипных элементов
    rec1 : record    // После ключевого слова record перечисляются переменные - т.н. поля записи:
      i : integer;   // Порядок указания полей не важен - доступ к ним будет по имени поля
      b1,b2 : boolean;
    end; // Конец перечисления полей записи

    { По умолчанию при выделении памяти для переменных в целях увеличения быстродействия может
      производиться выравнивание, из-за которого даже для однобайтных типов может быть выделено
      от 2 до 16 байт памяти. Ключевое слово packed даёт указание уплотнить данные так, чтобы
      в памяти не было пробелов из неиспользуемых байт }
    rec1packed : packed record
      i: integer; b1,b2: boolean; // Для переменных b1 и b2 выделено по 1 байту, а не по 2 или 16
    end; // Такая запись в итоге займёт 6 байт вместо 8 или 16

    { Ключевое слово bitpacked даёт указание уплотнить в памяти данные так, чтобы минимизировать
      число неиспользуемых бит. При этом скорость работы может значительно снижаться. }
    rec1bitpacked : bitpacked record
      i: integer; b1,b2: boolean; // b1 и b2 размещаются в одном байте, занимая 1-й и 2-й биты
    end; // Такая запись займёт 5 байт

    { Можно задавать вариантные поля. Для этого внутри записи указывается оператор выбора по образцу
      CASE, после которого указывается декларативный селектор - в нём при желании можно хранить
      информацию о том, какой вариант полей стоит использовать. Но о сохранении и последующей
      проверке этой информации должен заботиться сам программист - компилятор никак не препятствует
      записи или чтению информации из "неправильного" поля. }
    passport1 : record  // Запись, хранящая информацию о паспорте (имя, фамилию, серию и номер)
      name, surname: string[20]; // 2 поля с именем и фамилией - инвариантны
      case country_code:byte of  // В поле-селекторе типа byte хранится условный код страны
        // Варианты хранения полей в одной и той же области памяти:
        0..1: (series_number: Qword); // Для стран 0 и 1 - хранится только одно большое число
        2..255: (series: string[4]; number: Dword); // Для остальных стран - хранится строка и число
    end;

    { По причине декларативности селектора стандарт Паскаля позволяет вообще его имя опустить и тем
      самым не расходовать лишние байты внутри записи. Это оправдано в случае, если в логике
      программы информация о используемом варианте полей известна из какого-то другого источника: }
      passport_numb1 : record
         case byte of  // Безымянный селектор
           1: (series_number: Qword);
           2: (series: string[4]; number: Dword);
       end;

    { Включение режима {$modeswitch AdvancedRecords} позволяет использовать т.н. расширенные записи,
      позволяющие хранить не только поля, но и константы, типы, и даже процедуры с функциями.
      Но это не особо актуально, полскольку такой функционал удобнее реализовывать объектами. }

  { МНОЖЕСТВА (НАБОРЫ) }
    { Множество в FPC - набор из однотипных элементов-констант любого перечислимого типа, являющимся
      базовым для множества и удволетворяющим двум существенным ограничениям:
      1. Число элементов в базовом типе должно быть не более 256.
      2. Порядковые номера его элементов не должны превышать 255. Так например перечисление 80..300
      не может быть базовым типом для множества, т.к. элемент 300 имеет порядковый номер 300.
      Такие ограничения объясняется тем, что для переменных, хранящих множества, в памяти компьютера
      выделяется не более 32 байт (т.е. 256 бит: каждый пустой бит означает отстутвие в множестве
      соответсвующего по номеру элемента, а равный единице - что есть) }

      digits_set1 : set of 0..9; // Множество, предназначенное для цифр (базовый тип - byte)
      digits_char_set1 : set of '0'..'9'; // Предназначенное для символов цифр (базовый тип - char)
      char_set1, char_set2 : set of char; // Можно задать весь базовый тип целиком
      level_set1 : set of (lowlevel, middlelevel, highlevel); // Можно задать своё перечисление

  { УКАЗАТЕЛИ }

    // Указатель на переменную соответсвующего объявляется оператором ^ после имени переменной
    int_pointer1: ^integer; // Переменная int_pointer1 может хранить ссылку на integer-переменную
    pointer1 : pointer; // Безтиповый указатель - может ссылаться на переменную любого типа.

    // Для многих скалярных (простых) типов существуют соответсвующие типизированные указатели:
    int_pointer2    : PInteger;  // Синоним ^Integer

    { Также "из коробки" доступны типизированные указатели для таких скалярных типов:
        PShortint    PByte     PSingle      PCurrency    PBoolean      PString        PUnicodeString
        PSmallint    PWord     PDouble      PChar        PByteBool     PAnsiString    PRawByteString
        PLongint     PDWord    PExtended    PWideChar    PWordBool     PUTF8String    PShortString
        PInt64       PQWord    PFloat       PVariant     PQWordBool    PWideString
      При этом списке нет PReal и PValReal.
    }

    // Можно создавать ссылки на ссылку, как указатель на уже существующий ссылочный тип:
    int_doublepointer1    : ^PInteger;
    { Для некоторых типов уже есть такие встроенные типизированные указатели на указатели:
          PPLongint     PPByte     PPDouble      PPChar       PPWideChar
    }

    { Абсолютная адресация переменных }
    // Можно создать типизированную переменную, размещающуюся в памяти по одному и тому же адресу
    // с другой переменной. Но тут нужна осторожность, т.к. снижается понятность и надёжность кода:
    letter1code : byte absolute letter1; // Число letter1code совпадает по адресу с буквой letter1
    { При желании можно вообще указать точный адрес в памяти компьютера кодом absolute $123000;
      но практического смысла в этом нет, т.к. неизвестно что будет по этому адресу ещё храниться.
      Исторически такой приём использовался для прямого доступа к видеопамяти в режиме DOS.}

  { ДИНАМИЧЕСКИЕ МАССИВЫ }
    // Динамический индексированный массив в FPC - это набор однотипных элементов с доступом по
    // неотрицательному целочисленному индексу с неизвестным при компиляции количеством элементов.
  AChar1, AChar2 : array of char;  // Переменная является указателем на динамический массив символов
  ACharMulti : array of array of byte; // Двухмерный массив чисел

type // Раздел объявления пользовательских типов данных

  { ПОЛЬЗОВАТЕЛЬСКИЕ ПЕРЕЧИСЛИМЫЕ ТИПЫ }
     // Для стандратных перечислимых типов (ordinal types, множество значений которых упорядоченно),
     //  можно вводить новые т.н. ограниченные типы (как подмножества-диаппазоны):
  IntPercent = 0..100;             // Пользовательский тип для целочисленных процентов
  IntTemperature = -273..1000000;  // Целочисленная температура
  Alphabet = 'a'..'z';             // Диаппазон символов
  {$R+} { Эта директива компилятора включает контроль за тем, чтобы при записи в переменную
          значение не выходило за указанный допустимый диаппазон значений для типа этой переменной}
  {$R-}

  // Можно создавать новые перечислимые типы как упорядоченные наборы констант, указанные в скобках:
  WeekDays = (Mon, Tue, Wen, Thu, Fri, Sat, Sun); // Новый тип из обозначений дней недели
  WorkDays = Mon..Fri; // Ограниченный тип на основе предыдущего (рабочие дни)
  { По умолчанию в перечислимом типе константам соответсвуют значения 0,1,2,3 и т.д.
    Но можно задавать и произвольную нумерацию. При этом если номер не задан, то он вычисляется
    автоматически как "предыдущий номер + 1" }
  MemorySizes = (smallmem=32, normalmem=64, bigmem=128); // У константы smallmem значение 32
  // Аналогично можно создавать безымянные типы
  var weekday1: Sat..Sun;               // Ограниченный безымянный тип
      SignalLight:(Red, Yellow, Green); // Новый перечислимый безымянный тип

  label mimimi;  // Объявление метки с именем mimimi (для безусловного перехода)

  { Объявления процедур и функций размещается до начала раздела операторов.
    Командами begin и end обозначается начало и конец составного оператора.
    Если такой составной оператор указан сразу после объявления имени процедуры или функции,
    то он является телом этой процедуры/функции.
    Внутри составного оператора можно помещать другие составные и прочие операторы.}
  procedure proc1; // Объявление простейшей процедуры
    begin // Тело процедуры
      writeln('Выполняется процедура proc1');
    end;

  function func1:string; // Объявление простейшей функции, возвращающей значение указанного типа
    begin // Тело функции
      func1 := 'Результат работы функции'; // Возвращаемое значение присваивается имени функции.
    end;

BEGIN // Раздел операторов - составной оператор begin..end, не являющийся телом процедуры/функции

begin { ОБЩИЕ СИНТАКСИЧЕСКИЕ ПРАВИЛА }
  { Операторы разделяются символом точки с запятой ";"
    Блок операторов помещается между ключевыми словами begin и end;
    Отключить выполнение кода можно:
      1. Используя директивы условной компиляции $ifdef или $ifndef}
         {$ifdef debug} write('Этот код будет выполнен только при отладке.'); {$endif}  {
      2. Перед кодом поставить переход к метке, размещённой после этого кода
      3. Поместив код внутрь блока if(FALSE): }
         if(FALSE) then
           begin
             write('Этот код не будет выполнен.');
           end;
end;

begin { ПРОСТЕЙШИЕ СРЕДСТВА ВЗАИМОДЕЙСТВИЯ С ПОЛЬЗОВАТЕЛЕМ }

  // Настройка windows-консоли для отображения UTF8-строк
  {$ifndef UTF8mode}
    {$ifdef windows} // Исходные параметры кодировок:
      writeln('Console output code page: ', GetConsoleOutputCP());           // 866
      writeln('Console output stream code page: ', GetTextCodePage(Output)); // 866
      writeln('System code page: ', DefaultSystemCodePage);                  // 1251
      writeln('ANSI codepage: ', GetACP());                                  // 1251
      writeln('Console input code page: ', GetConsoleCP());                  // 866
      writeln('Console input stream code page: ', GetTextCodePage(Input));   // 866

      SetConsoleOutputCP(CP_UTF8); // Смена кодировки отображения консоли
      writeln('Console output code page: ', GetConsoleOutputCP());  // Стало 65001 вместо 866
      SetTextCodePage(Output,CP_UTF8); // Смена кодировки потока вывода в консоль
      writeln('Console output stream code page: ',GetTextCodePage(Output)); //Стало 65001 вместо 866
      SetMultiByteConversionCodePage(CP_UTF8); // Смена системной кодировки
      writeln('System codepage: ', DefaultSystemCodePage);  // Стало 65001 вместо 1251

      writeln('ANSI codepage: ', GetACP());                 // 1251 - не поменялось
    {$endif}
  {$endif} { После этих трёх изменений UTF8-строки со всеми UTF8-символами будут нормально
             отображаться и вводиться, но для этого в системах Windows понадобится изменить шрифт
             консоли на содержащий UTF8-символы. Данная программа меняет этот шрифт атоматически
             путём запуска кода в модуле SetWinConsoleFont.pas}

  // Вывод текстовых строк
  write('Hello world!');       // Вывод строки в консоль без перевода строки
  writeln('Привет мир!');      // и с переводом строки
  writeln('Буква Пси: Ψ, ψ');  // Вывод UTF8-символов только при отключенном режиме {$codepage UTF8}
  // Вывод чисел с выравниванием по правому краю:
  writeln(123:6);    // (целое число : кол-во знаков)
  writeln(2.5:10:2); // (вещественное число : общее кол-во знаков : кол-во знаков после запятой)

  {$ifdef debug}
    // Пауза работы
    sleep(3000); // Пауза на 3000 мс. Требует uses windows
    // Ожидание нажатия любой клавиши. Требует устаревший модуль - uses Crt, не совместимый с Linux:
    // writeln('Нажмите любую клавишу:'); readkey;
    // Ожидание нажатия клавиши ENTER (ввода строки)
    write('Нажмите ENTER:'); readln;
  {$endif}

end;

begin { РАБОТА С ПЕРЕМЕННЫМИ }
  { Непроинициализированные переменные обычно хранят значение по умолчанию, но стандартами это не
    гарантируется - т.е. в таких переменных может сожержаться и мусор, оставшийся от других данных.
    Поэтому хорошая практика - обязательно инициализировать переменную.
    Инициализация переменных производится оператором присвоения := (двоеточие и знак равенства) }
  numb_4b := 1234567890;     // Непроинициализированная переменная обычно хранит значение 0
  numb_1b := 12345;          // Число больше допустимого 127, поэтому сохранится
                             // неправильное значение (обрезанное до 8 бит)
  rnumb_4b := 12345.456789;  // В качестве разделителя используется точка
  rnumb_4b := 456.789;       // Проинициализированную переменную можно перезаписать новым значением

  numb_2b := $F57;           // Шестнадцатеричное число начинается с символа $
  numb_2b := &4651;          // Восьмеричное число начинается с символа &
  numb_2b := %10011110;      // Двоичное число начинается с символа %
  // В модуле Math Доступны вещественные константы  Infinity и NaN:
  real1 :=  infinity;  // const Infinity = 1.0/0.0 (бесконечность)
  float1 := NaN;       // const NaN = 0.0/0.0  (Not a Number или "не число", "не вычислимое")

  bool1:=true; bool2:=false; // Непроинициализированная переменная обычно хранит значение FALSE
  letter1 := 'W';            // Непроинициализированная переменная обычно хранит латинскую букву 'a'
    writeln(letter1);
  letter1 := #75;            // Символ с ASCII-кодом 75
    writeln(letter1);
  wideletter1:=#$03A8;       // Символ Ψ в кодировке UTF-16
    writeln(wideletter1);

  str1 := 'Тестовая строка';  // Непроинициализированная переменная хранит пустую сроку
  writeln(str1);
  str1 := 'граф д''Артаньян'; // Одинарную кавычку можно сохранить в строке, написав её дважды
  writeln(str1);
  str1 := 'граф д' + #39 + 'Артаньян';  // либо указав ASCII-код 39
  writeln(str1);
  str1 := 'Первая строка' + LineEnding  + 'Вторая строка'; // Перенос строки в стандарте текущей ОС
  writeln(str1);
  str1 := #13#10;  // Символы Carriage Return (возврат каретки) и Line feed (перенос строки)
  str1 := #9#8#12; // Символы  Tab | Backspace | Form feed (новая страница)
  writeln(ConstStr1);
  writeln(ConstStr2);

  // Корректность работы разных типов строк со строковыми литералами  зависит от режима компиляции:
  // https://wiki.freepascal.org/Unicode_Support_in_Lazarus/ru

  // AnsiString и RawByteString работают корректно в любом режиме
  ansistr1 := 'Строка ANSI'; writeln(ansistr1);
  rawstr1 := 'Строка без указания кодировки'; writeln(rawstr1);
  {$ifdef UTF8mode} // Строки в UTF-кодировках воспринимают литералы в режиме {$codepage UTF8}
    utf8str1 := 'Строка UTF8string'; writeln(utf8str1);
    unistr1 := 'Строка Unicodestring'; writeln(unistr1);
    widestr1 := 'Строка Widestring'; writeln(widestr1);
  {$else} // Строки shortstring и PChar не воспринимают литералы в режиме {$codepage UTF8}
    shortstr1 := 'Строка длиной 256 байт.'; writeln(shortstr1);
    shortstr2 := 'Строка длиной 10 байт'; writeln(shortstr2); // Строка обрежется до 10 байт
    PCharstr1 := 'Строка - массив символов Char с нулевым байтом в конце.'; writeln(PCharstr1);
  {$endif}

  // Вариативная переменная может принимать значения любого значимого типа:
  v1 := 78; v1 := 'строка'; v1 := TRUE; // При подключении модуля uses variants можно узнать текущий
                                        // тип вариативной переменной с пом.функции VarType(v1)

  // Использование констант и переменных в операторах:
  numb_2b := numb_1b;
  writeln(numb_2b);
  writeln(' ', letter1, str1, bool2); // В функции вывода можно перечислять аргументы через запятую.
  rnumb_4b := rnumb_4b / numb_4b;  { В выражениях для присвоения нового значения можно использовать
                                     эту же переменную, пока в ней хранится старое значение. }
end;

begin { ОПЕРАЦИИ }
  numb_1b := 5; // Оператор присваивания

  { Арифметические операторы }
    numb_1b := ( 7 + 2 - 3 ) * 4; // Сложение, вычитание и умножение для любых типов чисел.
    numb_1b_natural := 1 - numb_1b; { Результирующее значение не проверяется на предмет
                                попадания в допустимый диапазон: }
    writeln('В переменной типа BYTE отрицательное значение ', 1 - numb_1b,
                                         ' сохранилось как ', numb_1b_natural);
    numb_4b := 2147483647;
    numb_4b := numb_4b  + 2; // Пример арифметического переполнения
    writeln('В переменной типа Longint 33-битное значение ', 2147483647 + 2,
                                        ' сохранилось как ', numb_4b);

    {$Q+} // Эта директива компилятора включает режим проверки арифметического переполнения
    {$Q-} // Выключение режима проверки переполнения (значение по умолчанию)

    numb_4b := 2147483647;
    numb_4b := numb_4b  + 2;  // На этой строке при директиве {$Q+} программа остановится с ошибкой

    numb_2b := 31 div 8; // Целочисленное деление
    numb_2b := 31 mod 8; // Остаток от деления
    rnumb_6b := 31 / 8;  // Вещественное деление

    numb_4b := sqr(3); { Квадрат числа. Для целых чисел результат функции SQR
                         можно сохранить в т.ч. в целочисленную переменную.}
    numb_4b := 3**5; { Возведение в произвольную степень. Если операнды целочисленные,
                       то результат можно сохранить в целочисленную переменную.}
    rnumb_8b := power(2,3);   { Аналогичная функция POWER даже для целых
                                чисел возвращает вещественный результат.}
    rnumb_8b := 2**3.5;       // Возведение в дробную степень через оператор **
    rnumb_8b := power(2,3.5); // Возведение в дробную степень через функцию power()

    rnumb_10b := sqrt(9); // Корень квадратный из числа
    // Для вычисления корня можно использовать возведение в дробную степень:
    rnumb_8b := power(9, 1/2); // = 3

  { Унарные операторы }
    i := - numb_4b; // Унарный оператор смены знака.
    i := not i; { Побитовая инверсия - вычитание из -1. Т.е. смена знака
             и одновременный декремент. Полезна в связке с операцией смены знака.}
    i := -not i; // Инкремент. Унарный аналог i+1
    i := not- i; // Декремент. Унарный аналог i-1
    i := -not 2 * 6; { Результат равен 18, а не 13, поскольку у унарных операций
                       приоритет выше чем у операций умножения и деления.}

  { Комбинированные операторы }
    numb_4b += 5; numb_4b -= 5;  // Увеличить или уменьшить переменную на указанное число.
    numb_4b *= 3; rnumb_8b /= 3; // Умножить или поделить переменную на указанное число.

  { Битовые операции}
    inc(i); dec(i); // Процедуры увеличения и уменьшения значения переменной на 1 бит
    inc(i,5); dec(i,5); // Процедуры увеличения и уменьшения значения на указанное число бит
    i := i and 5; { Побитовое И (AND).  Используется для установки в нужные биты значения 0 }
    i := i or 5;  { Побитовое ИЛИ (OR). Используется для установки в нужные биты значения 1 }
    i := i xor 5; { Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR).
                    Используется для смены значений нужных битов на противоположные}
    i := i << 3; i := i shl 2; { Побитовый сдвиг влево на указанное число бит
                               с сохранением знака (умножение на степень двойки )}
    i := i >> 2; i := i shr 3; { Побитовый сдвиг вправо на указанное число бит
                               с сохранением знака (деление на степень двойки)}

    // Для отрицательных значений сдвиг вправо работает не как деление на 2:
    numb_1b :=-3;
    numb_1b:=numb_1b shr 1;
    writeln('Результат битового сдвига shr: ', numb_1b); // = 126 а не (-3 div 2 = -1)
    numb_1b :=-3;
    // Поэтому для работы с отрицательными значениями целочисленных типов есть "правильные"
    // аналогичные функции SarShortint, SarSmallint, SarLongint, Sarint64.
    // Эти функции работают как div, но для отрицательных нечётных чисел дают результат меньший на 1
    numb_1b := SarShortint(numb_1b, 1);
    writeln('Результат битового сдвига SarShortint: ', numb_1b); // = -2

    // Функции RolByte, RolWord, RolDWord, RolQWord, RorByte, RorWord, RorDword, RorQword
    // делают ротационный сдвиг, когда вытесняемые биты переносятся в освобождающиеся биты.

    { Конкатенация строк }
    str1 := 'строка1' + 'строка2';
    str1 += 'строка3'; // Комбинированный оператор идентичен str1 := str1 + 'строка3';

  { Операторы сравнения и логические операторы }
    // Во всех нижепреведенных сравнениях результат равен TRUE:
    bool1 := (2 = 2)               and  // Равенство
             (2 <> 3)              and  // Неравенство
             (bool1 <> not bool1)  and  // Отрицание
             (1 >= 1) and (2 > 1)  and  // Логическое "И" (конъюнкция)
             (1 <= 1) or (2 < 1)   and  // Логическое "ИЛИ" (дизъюнкция)
            ((1 <= 1) xor (2 < 1)) and  // Логическое "ЛИБО" (исключение)
             (Mon < Tue)           and  // Можно сравнивать величины перечислимого типа
             ('Строка 2' > 'Строка 1'); // Строки сравниваются побуквенно
    writeln('Результат всех сравнений и логических операций: ',bool1);  // TRUE

  { Операции с особыми вещественными числами Infinity и NaN }
    // Во всех нижепреведенных сравнениях результат равен TRUE:
    bool1 := (1 + Infinity = Infinity)  and
             (1 - Infinity = -Infinity) and
             (1 / Infinity = 0)   and // Деление на бесконечность равно нулю
            (-1 / Infinity = -0)  and // минус ноль (бесконечно малое отрицательное число)
            (-0 = 0)              and
             (1 / 0 = Infinity)   and // Деление на 0 даёт бесконечность, а не ошибку
             isNaN(NaN)           and // Функция isNaN(x) возвращает true если её аргумент NaN
             isInfinite(Infinity) and // isInfinite(x) возращает true если её аргумент бесконечность
             (NaN <> NaN)         and // NaN не равен ничему - даже самому себе
         not (NaN = NaN)          and
             isNaN(0 / 0)         and // Не вычислимо: деление 0 на 0,
             isNaN(0 * Infinity)  and // умножение нуля на бесконечность,
             isNaN(5 + NaN)       and // арифметические операции с NaN,
             isNaN(Infinity / Infinity) and // деление двух бесконечностей,
             isNaN(Infinity - Infinity);    // вычитание двух бесконечностей }
    writeln('Результат всех операций с Infinity и NaN: ', bool1);  // TRUE
end;

begin { ПРИВЕДЕНИЕ ПРОСТЫХ ТИПОВ ПРИ ОПЕРАЦИЯХ }
  { Автоматическое строковое преобразование }
    str1 := 'Строка1' + letter1 + WideLetter1; // Символьные типы автоматически приводятся к строке
    writeln(str1);

  { Явное строковое преобразование }
    // Эти функции требуют uses sysutils:
    str1 := intToStr(17);    // Преобразование целого числа в строку
    str1 := floatToStr(2.5); // Преобразование вещественного числа в строку

    WriteStr(str1,'2+2 = ', 2+2, true); // Аналог функции write - сохраняет результат в строку str1
    writeln(str1);
    str(3.456789,str1); // Функция конвертирования чисел в строку
    writeln(str1);

    PCharstr1 := PChar(rawstr1); // Явное приведение строки к строке другого типа

    // Преобразование в строку с форматированием:
    ThousandSeparator := ' '; // Устаревшие способы изменить разделитель тысячных частей числа
    DecimalSeparator := ',';  // и дробной части числа
    str1 := FloatToStrF(12345.5, ffNumber, 0, 2);
    writeln('Отформатированное число с разделителями тысяч: ',str1);
    str(3.456789:7:2, str1);
    writeln('Отформатированное число с фиксированными пробелами перед ним: ',str1,' руб.');

    // Приведение числа к строке в разных системах счисления (второй параметр - число знаков):
    HexStr(175,10); // Шестнадцатеричное представление
    BinStr(175,10); // Двоичное представление
    OctStr(175,10); // Восьмиричное представление

  { Автоматическое численное преобразование }
    rnumb_4b := numb_1b; // Целые числа автоматически приводятся к вещественным
    numb_1b := numb_4b;  // При сохранении в тип меньшей разрядности биты обрезаются
                         // При директиве {$Q+} это не считается переполнением и ошибки не выдаётся
    writeln('Число ',numb_4b,' хранилось в 4-х байтах. При сохранении в 1 байт стало = ',numb_1b);

  { Явное численное преобразование }
    // Приведение вещественных чисел к целому:
    numb_2b := trunc(2.7);  // Отсечение дробной части числа.  = 2
    numb_2b := round(2.7);  // Округление до ближайшего целого числа.  = 3
    // Если ближайших целых чисел два, то FPC округляет до ближайшего чётного:
    numb_2b := round(1.5); // = 2
    numb_2b := round(2.5); // = 2

    // Приведение строки к числу. В случае ошибки приведения генерируется исключение
    numb_2b := StrToInt('123'); // Приведение строки к целому числу:
    rnumb_4b := StrToFloat('2,7'); { Приведение строки к вещественному числу.
                                     Разделитель по умолчанию - "," (запятая) }
    DecimalSeparator:='.'; // Можно изменить разделитель дробной части например на точку
    rnumb_4b := StrToFloat('2.7'); // Строка с разделителем '.' теперь не выдаёт исключение

    // Получение символа по коду
    writeln('Коду 73 соответсвует ANSI-символ ', chr(73));
    writeln('Коду 936 соответсвует UTF16-символ ', WideChar(936));

    // Получение кода символа (как значения перечислимого типа)
    writeln('Код символа ', letter1,    ' : ', ord(letter1));
    writeln('Код символа ', wideletter1,' : ', ord(wideletter1));
    // Альтернатива - использовать числовую переменную с абсолютной адресацией по тому же адресу:
    writeln('По адресу символа ', letter1, ' хранится число: ', letter1code);

    // Получение порядкового номера величины перечислимого типа:
    writeln('У дня недели ', Tue, ' порядковый № ', ord(Tue)); // = 1

    // Получение величины перечислимого типа по порядковому номеру.
    // Для этого используется функция, одноимённая названию перечислимого типа:
    writeln('Порядковому номеру ', 4, ' соответствует день недели ', WeekDays(4)); // = Fri

    // Другие функции для работы с перечислимыми типами:
    writeln('После ', Sat, ' будет ', succ(Sat)); // = Sun
    writeln('Перед ', Wen, ' будет ', pred(Wen)); // = Tue
    // По имени типа или одной из его констант можно узнать минимальное и максимальное значения:
    writeln('Миним. и максим. значения для типа WeekDays: ', low(Sat),' и ', high(Weekdays));
    writeln('Максимальное число integer для текущей ОС: ', high(integer));

  { Логическое преобразование }
    bool1 := odd(7); // Функция odd() возвращает TRUE если число нечётное
    if bool1 then writeln('Число нечётное!');
end;

begin { МАТЕМАТИЧЕСКИЕ КОНСТАНТЫ И ФУНКЦИИ }

  rnumb_4b := PI; // Функция PI не имеет аргументов и возвращает число Пи

  randomize; // Запуск генератора псевдослучайных чисел
  numb_2b := random(1000); // Псевдослучайное целое число от 0 до 1000

  rnumb_4b := abs(-3.14);  // = 3.14  Абсолютное значение числа (модуль числа)
  rnumb_4b := int(PI);     // Целая часть числа. Результат - вещественное число.
  rnumb_4b := frac(PI);    // Дробная часть числа.

  rnumb_4b := exp(1);    // Натуральная экспонента числа (e в степени x).
    writeln('Число e = ', rnumb_4b);
  rnumb_4b := ln(5);     // Натуральный логарифм числа
  rnumb_4b := lnXP1(5);  // Натуральный логарифм числа x+1, т.е. в данном случае = ln(6)
  rnumb_4b := log10(5);  // Десятичный логарифм числа
  rnumb_4b := log2(5);   // Двоичный логарифм числа
  rnumb_4b := logN(3,5); // Логарифм по произвольному основанию N. В данном случае N = 3

  // Эти функции перегружены - могут возвращать числа любого типа:
  rnumb_4b := max(2,7); // Максимальное из двух чисел.
  rnumb_4b := min(2,7); // Минимальное из двух чисел.

  {Тригонометрические функции}
  rnumb_4b := sin(PI/2); // Синус числа   (= 1)
  rnumb_4b := cos(PI); // Косинус числа  (= -1)
  rnumb_4b := tan(PI/4); // Тангенс числа (= 1)
  rnumb_4b := cotan(PI/4); // Котангенс числа (= 1)
  rnumb_4b := arcsin(1); // Арксинус числа (= PI/2)
  rnumb_4b := arccos(-1); // Арккосинус числа (= PI)
  rnumb_4b := arctan(1); // Арктангенс числа (= PI/4)

end;

begin { ФУНКЦИИ РАБОТЫ СО СТРОКАМИ }
  str1 := 'Строка1'; // Строка UTF8 с многобайтными символами (кириллица)
  str2 := 'String1'; // Строка UTF8 с однобайтными символами (латинница и цифры)

  // Получение и установка длины строки:
  numb_2b := length(str1); // Длина строки в байтах
    writeln('Длина строки в байтах: ', numb_2b);
  SetLength(str1, 12); // Установить новую длину строки в байтах
    writeln(str1);

  // Для преобразования в произвольную кодировку следует поместить строку в RawByteString
  rawstr1 := 'Строка будет в кодировке 1251';
  SetCodePage(rawstr1, 1251, TRUE); // Изменение кодировки RawByteString с конвертацией (флаг TRUE)
      writeln('Преобразованная строка: ', rawstr1);
  { Чтобы предотвратить автоматическое преобразование в другие кодировки при работе со строкой
     можно сбросить информацию о кодировке: }
  SetCodePage(rawstr1, CP_NONE, FALSE); // Флаг FALSE указывает не конвертировать саму строку
      writeln('Строка без информации о кодировке: ', rawstr1);

  { Доступ к строке как к массиву символов. Работает только:
      - для ansi-строк без многобайтных символов
      - с unicodestring в режиме {$codepage UTF8}
      - строк PChar }
    str1 := 'Test string';
    letter1 := str1[7]; // Доступ к 7-му элементу строки (нумерация элементов с 1)
        writeln('7-й символ строки ',str1,' : ',letter1);
    str2[7]:='S'; // Замена 7-го символа в строке на другой.

    // У строк PChar (в стандарте C) нумерация элементов - с нуля
      PCharstr1 := 'Test string';
      writeln('7-й символ строки ',PCharstr1,' : ',PCharstr1[6]);  // У 7-го символа - индекс 6

  // Получение подстроки из строки
      str2 := copy(str1, 6, 4); // Скопировать с 6-й позиции 4 символа.
      str2 := copy(str1, 6);    // Скопировать с 6-й позиции до конца строки.

  // Вставка строки в указанную позицию другой строки
      insert('other ', str1, 6); // Вставить текст 'other ' в строку str1 перед 6-м символом

  // Удаление из строки нескольких символов, начиная с указанной позиции
      delete(str1, 6, 2); // Удалить начиная с 6-й позиции 2 символа

  // Копирование строки в новую строку
      { Для всех строк кроме PChar в FPC действует механизм "копирование при записи", что означает
       что при дублировании строки в новую переменную копирование данных будет происходить только
       после того, как в одну из этих двух переменных будет произведена запись: }

      str2 := str1; { Сейчас обе переменные указывают на одну и ту же строку в памяти компьютера.
        Счётчик ссылок самой строки увеличивается на единицу (на строку появилась ещё одна ссылка) }
      str2[2]:='o'; { Одна из строк изменена - запускается процесс создания в памяти компьютера
        дубликата строки со счётчиком равным 1, а счётчик ссылок у оригинала уменьшается на 1 }

      { Если по каким-то причинам такое копирование нужно произвести заранее, до изменения
        содержимого строк, то сделать это можно с помощью процедуры UniqueString: }
      UniqueString(str1); // При счётчике ссылок у str1 больше 1 запустится процесс копирования.
      // Либо можно использовать функцию copy:
      str2 := copy(str1,1);
      // Также функция copy - единственный вариант получить отдельный дубликат строки PChar

  { Изменение регистра символов }
      // Только латинских символов
        str2 := LowerCase(str2); // Перевод в нижний регистр
        str2 := UpperCase(str2); // Перевод в верхний регистр
      // Всех символов для ansi-строк
        str2 := AnsiLowerCase(str1);
        str2 := AnsiUpperCase(str1);
      // Всех символов для unicode-строк
        unistr1 := 'Строка';
        str2 := UnicodeLowerCase(unistr1);
        str2 := UnicodeUpperCase(unistr1);
      // Всех символов для widestring-строк
        widestr1 := 'Строка';
        str2 := WideLowerCase(widestr1);
        str2 := WideUpperCase(widestr1);

  { Поиск позиции подстроки в строке.
      Для многобайтных кодировок работает в режиме {$codepage UTF8} }
    str1 := 'Test String';
    i := Pos('ring', str1); // = 8   Поиск чувствителен к регистру.
    i := Pos('t', str1,5);  // = 7   Вторым аргументом можно указать позицию начала поиска
    i := Pos('tost', str1); // = 0   Если ничего не найдено функция возвращает значение 0

    // Поиск всех вхождений подстроки в строку
      i:=0; write('Подстрока найдена в позициях: ');
      repeat
        i := Pos('t', str1, i+1);
        if (i>0) then write(i, ' ') else writeln;
      until (i=0);

  { Сравнение строк по кодам символов }
    // Для кодировки UTF-8 cправедливы следующие равенства:
    if (('еж' = 'еж')    and  // Строки равны, если все их символы совпадают
        ('ежик' > 'еж' ) and  // При совпадении символов более длинная строка - больше
        ('ежик' < 'лис') and  // Если код 1-го неравного символа больше, то вся строка больше
        ('ежик' > 'Лис') and  // Коды строчных букв больше прописных
        ('ёжик' > 'лис') and  // Буква ё идёт после основного алфавита
        ('Ёжик' < 'Лис')      // Буква Ё идёт перед основным алфавитом
    ) then writeln('Все выражения сравнения строк истинны.');

  { Сравнение строк по алфавиту }
    i := AnsiCompareStr('лис', 'лис');   // = 0  для равных строк
    i := AnsiCompareStr('ежик', 'лис');  // = -1 если первая строка меньше
    i := AnsiCompareStr('ежик', 'аист'); // = 1 если первая строка больше
    if (AnsiCompareStr('ежик','Ежик') = -1) and // Строчная буква меньше такой же прописной
       (AnsiCompareStr('Ежик','лис')  = -1) and // Алфавит идёт в порядке аАбБвВгГ и т.д.
       (AnsiCompareStr('ёжик','лис')  = -1)     // Буквы ёЁ обрабатываются корректно
    then writeln('Все выражения сравнения строк истинны.');
    // Аналогичная функция AnsiCompareText игнорирует регистр символов:
      i := AnsiCompareText('ежик','Ежик');  // = 0
      { Для латинницы и строк других типов есть аналогичные функции
        CompareStr,  UnicodeCompareStr,  WideCompareStr
        CompareText, UnicodeCompareText, WideCompareText }

  { Функции режима {$codepage UTF8} для работы с многобайтными кодировками }
  {$ifdef UTF8mode}
    unistr1 := 'Строка2';
    numb_2b := UTF8length(str1); // Длина строки в символах
       writeln('Длина строки в символах: ', numb_2b);

    // в режиме {$codepage UTF8} ф-я length возращает длину unicodestring в символах, а не байтах:
    numb_2b := length(unistr1);
      writeln('Длина unicodestring в символах: ', numb_2b);
    SetLength(unistr1,6); // Также корректно работает установка новой длины unicodestring в символах
      writeln('Обрезанная строка: ', unistr1);

    // Изменение кодировки ansi-строки для windows-систем:
    {$ifdef windows}
      str2 := UTF8ToWinCP(str1); // Преобразование из UTF8 в кодировку консоли Windows
      str1 := WinCPToUTF8(str2); // Преобразование из кодировки консоли Windows в UTF8
    {$endif}

    // Аналоги функций copy, insert, delete:
    str1:='Тестовая строка';
    str2 := UTF8Copy(str1, 6, 4); // Скопировать с 6-й позиции 4 символа.
    UTF8insert('ещё', str1, 6);   // Вставить текст 'ещё' в строку str1 перед 6-м символом
    UTF8delete(str1, 6, 2);       // Удалить начиная с 6-й позиции 2 символа
  {$endif}
end;

begin { РАБОТА С ФАЙЛАМИ }

  begin {ЗАПИСЬ И ЧТЕНИЕ ДАННЫХ ИЗ ФАЙЛА }
    // Запись в тектосвый файл, представляющий собой последовательность строк:
      AssignFile(textfile1, 'тест.txt');       // Связать переменную с именем файла
      ReWrite(textfile1);                      // Открыть файл для записи, затерев всё содержимое
      WriteLn(textfile1, 'Строка1', 3.14:8:2); // Записать в файл строку и число
      Write(textfile1, 'Строка2');             // Записать строку без перевода каретки
      // Данные в файл записываются не сразу, а сначала помещаются во внутренний буфер
      Flush(textfile1); // Принудительно записать содержимое буфера в файл
      Close(textfile1); // Закрыть файл, сохранив из буфера все изменения

    // Запись в бинарный файл, представляющий собой последовательность типа char
      AssignFile(binfile1, 'тест2Ψ.txt'); ReWrite(binfile1);
      Write(binfile1, 'a', 'b', 'c', chr(89));   // Запись нескольких разных символов
     for i:=1 to 255 do Write(binfile1, chr(i)); // Запись всего набора ANSI-символов
     Close(binfile1);

   // Запись в типизированный файл
     AssignFile(typfile1, 'тест3.txt'); ReWrite(typfile1);
     for i:=1 to 100 do Write(typfile1, i/3);  // Запись сотни чисел типа real
     Close(typfile1);

   // Чтение строк из текстового файла в строковую переменную
     reset(textfile1);    // Открыть файл для чтения
     readln(textfile1, str1); // Считать строку из текущей позиции и перейти к следующей строке
     read(textfile1, str1);   // Считать строку до конца, не переходя к следующей
     writeln('Считана строка: ', str1);
     if EOF(textfile1) then writeln('Достигнут конец файла '); // // Проверка достижения конца файла
     close(textfile1);

   // Чтение строк из бинарного файла в переменную типа char
     reset(binfile1);
     read(binfile1, letter1); // Считать символ из текущей позиции и сдвинуть указатель на единицу
     writeln('Считан символ: ', letter1);
     i := FilePos(binfile1);  // = 1  Текущая позиция указателя в файле (отсчёт с нуля)
     seek(binfile1, 75);      // Переместить указатель чтения файла в позицию 75
     read(binfile1, letter1);
     writeln('Считан 76-й символ файла: ', letter1);
     writeln('Текущая позиция в файле: ', FilePos(binfile1));
     close(binfile1);

   // Чтение типизированного файла в переменную совпадающего типа
     reset(typfile1);
     read(typfile1, rnumb_6b); // Считать данные в переменную и сдвинуть указатель на единицу
     writeln('Считано число: ', rnumb_6b:6:2);
     seek(typfile1, 75);      // Переместить указатель чтения файла в позицию 75
     // Физически при этом указатель находится на байте с номером 75*N, где N - размер типа в байтах
     read(typfile1, rnumb_6b);
     writeln('Считано 76-е число в файле: ', rnumb_6b:6:2);
     close(typfile1);

   // Допись в файл
     append(textfile1);    // Открыть файл для дописи в конец
     write(textfile1, 'Строка3');
     close(textfile1);

   // Чтение всего файла в строковую переменую
     reset(textfile1);
     readln(textfile1, str1);
     while not EOF(textfile1) do
       begin
         readln(textfile1, str2);
         str1 := str1 + LineEnding + str2 ;
       end;
     writeln('Содержимое всего файла: ', str1);
     close(textfile1);

   // Создание файла из строковой переменной
     rewrite(textfile1);
     write(textfile1, str1);
     close(textfile1);
  end;

  begin { МАНИПУЛЯЦИИ С ЦЕЛЫМИ ФАЙЛАМИ И КАТАЛОГАМИ }
    // Проверка существования файла
      if FileExists('тест.txt') then writeln('Файл найден!');

    // Создание файла
      i:=FileCreate('тест4Ψ.txt'); // Создать и открыть пустой файл.
      writeln('Создан файл с дескриптором ', i);
      FileClose(i); // Закрыть файл с указанным дескриптором

     // Переименование файла
       RenameFile('тест5Ψ.txt', 'оригинал.txt'); // Преименовать файл с именем тест5Ψ.txt
       // Функция Rename() выдаёт ошибку, если новое имя файла уже занято, поэтому нужна проверка:
       if not FileExists('тест5Ψ.txt') then
          Rename(binfile1,'тест5Ψ.txt'); // Переименовать файл в переменной binfile1

     // Удаление файлов по имени в любой кодировке работает только через файловую переменную:
       Erase(typfile1); // Удалить файл в переменной typfile1

     // Функция Erase() выдаёт ошибку, если файла не существует, поэтому лучше делать проверку:
       if FileExists('тест4Ψ.txt') then
         begin
           AssignFile(binfile1, 'тест4Ψ.txt');
           Erase(binfile1);
         end;

     // Копирование файла
     {$ifdef windows}
     { В системе Windows функции CopyFile() и DeleteFile() не поддерживают кодировку UTF8,
       кирилические имена ей должны быть переданы в системной кодировке, чаще всего CP-1251.
       Поэтому можно применять два обходных способа использования этой функции: }

       // Способ 1. Копирование с предварительным и последующим переименованием:
         str1:='оригинал.txt'; // Исходный файл
         RenameFile(str1, 'temp1.txt'); // Переименовываем исходный файл в имя на латиннице
         // Копирование (третий аргумент TRUE - указание скопировать также и дату создания файла):
         CopyFile('temp1.txt', 'temp2.txt', TRUE); // Создан файл temp2.txt как копия temp1.txt
         RenameFile('temp1.txt', str1); // Возвращено обратно имя исходного файла
         // Переименовываем новый файл в нужное имя в кодировке UTF8
         RenameFile('temp2.txt', 'копия Ψ.txt');

       // Способ 2. Изменение кодировки имени файла на системную кодировку windows:
         rawstr1:='оригинал.txt'; // Имя файла, который будет копироваться
         rawstr2:='копия.txt';    // Имя файла-копии
         SetCodePage(rawstr1, GetACP(), TRUE); // Меняем кодировку имён файлов на системную
         SetCodePage(rawstr2, GetACP(), TRUE);
         // Функция CopyFile() принимает на вход строки типа PChar. Поэтому нужно приведение типа:
         CopyFile(PChar(rawstr1), PChar(rawstr2), true);

     // Удаление файла с указанным именем
         DeleteFile(PChar(rawstr1));
         DeleteFile(PChar(rawstr2));
   {$endif}

   // Удаление демонстрационных файлов
     if FileExists('тест5Ψ.txt') then begin AssignFile(binfile1, 'тест5Ψ.txt'); Erase(binfile1); end;
     if FileExists('копия Ψ.txt') then begin AssignFile(binfile1, 'копия Ψ.txt'); Erase(binfile1); end;
     if FileExists('тест.txt') then begin AssignFile(binfile1, 'тест.txt'); Erase(binfile1); end;

  { МАНИПУЛЯЦИИ С КАТАЛОГАМИ И ДИСКАМИ }
    MkDir('Каталог 1'); // Создание каталога
    if DirectoryExists('Каталог 1') then writeln('Каталог найден!'); // Проверка существования
    str1 := GetCurrentDir(); // Полный путь к текущему каталогу
       writeln('Текущий каталог: ', str1);
    ChDir('Каталог 1'); // Смена каталога
    ChDir('..');        // Возврат на уровень выше
    RenameFile('Каталог 1', 'Каталог 2'); // Переименование каталога
    RmDir('Каталог 2'); // Удаление каталога
    numb_8b:=DiskSize(0); writeln('Всего на текущем диске: ', numb_8b, ' байт');
    numb_8b:=DiskFree(0); writeln('Свободно на текущем диске: ', numb_8b, ' байт');

  end;
end;

begin { ПРОЦЕДУРНОЕ ПРОГРАММИРОВАНИЕ }
  { Процедура - блок программы, которому могут передаваться или не передаваться на вход аргументы,
    но который (в отличие от функции в классических языках программирования) не возвращает значения,
    а просто совершает побочные действия (ввод/вывод, изменение значений внешних переменных и т.д.)}
  proc1; // Вызов процедуры
  { Если в программе и подключенных модулях есть процедуры с одинаковыми именами, то запустится та,
    что была подключена или объявлена последней. Можно принудительно указать, из какого модуля
    следует запустить процедуру, указав через имя модуля и процедуры: }
  Pascal_Begin_Functions.proc1; // Вызов процедуры proc1 из модуля Pascal_Begin_Functions

    { С целью последовательного изложения материала все нижеследующие процедуры и функции объявлены
      в модуле Pascal_Begin_Functions. Если Вы уже освоили работу с простыми типами данных, то
      можете приступить к изучению указанного модуля для освоения работы с подпрограммами.}

  proc1; // Простейшая процедура
  proc2; // Демонстрация области видимости переменных
  proc3; // Поведение статических переменных, оюъявленных в подпрограмме
  proc4(640,480,true); // Передача аргументов в подпрограмму
  proc4b(640,480); // Передача необязательного (второго) аргумента в подпрограмму
  proc4b(640);     // Вызов подпрограммы без второго, необязательного аргумента
  proc5([5,9,2]);  // Вызов подпрограммы с произвольным количеством однотипных аргументов
  proc5b([7,true,str1,3+2]);  // Произвольное количество разнотипных аргументов

  letter1:='W';
  proc7(letter1);

  i:=5;
  double(i,j);
  writeln('Удвоенное значение: ',i);
  double2(i); // Вместо этой строки компилятор подставит код i*=2;

end;

begin { ФУНКЦИОНАЛЬНОЕ ПРОГРАММИРОВАНИЕ }
  { Функция - это блок программы, который принимает на вход аргументы и возвращает некое значение
    определённого типа. ФП предполагает использование функций без взаимодействия с внешними
    переменными и без произведения побочных действий. Все нужные данные передаются в функцию в виде
    аргументов и функция взаимодействует с внешним миром только путем возврата значений. }
  str1 := func1(); // Вызов функции
  writeln('Функция func1 вернула значение: ', str1);
  str1 := Pascal_Begin_Functions.func1(); // Вызов функции из указанного модуля
  writeln('Функция func1 вернула значение: ', str1);
  writeln('Cумма квадратов 2 и 3 равна: ', summ_sqr(2,3)); // Вызов функции с аргументами

  // Функция высшего порядка может использовать другую функцию через процедурную переменную:
  func_pointer1 := addr(sum); // Процедурная переменная func_pointer1 содержит адрес функции sum()
  func_pointer1 := @sum; // Более короткая запись - используется оператор взятия адреса: @
  i := ApplyFunc1(func_pointer1, 2, 3, 4); // Применение функции func_pointer1 к числам 2,3,4
  writeln('Cумма чисел 2,3 и 4 равна: ', i);
  i := ApplyFunc1(@sum,2,3,4); // Можно обойтись и без переменной - передать сразу адрес функции

  writeln('Результаты созданных функций: ');
  func_pointer1 := ReturnFunc1(8);
  writeln(func_pointer1(3,4),' и ');
  func_pointer1 := ReturnFunc1(9);
  writeln(func_pointer1(3,4));

  localProc1;   // При вызове localProc1 ссылка на вложенную подпрограмму сохраняется в переменную
  procPointer2; // Вызов вложенной подпрограммы через процедурную переменную с типом nested

  lexEnvTest; // Вложенная функция при обращении к переменной ищет её сначала в функции уровнем выше

  str1 := decoString('декорируемая строка');
  writeln('Результат работы вложенных функций:', str1);

  str1 := sum('Строка1','Строка2');
  writeln('Результат полиморфной  фуннкции:', str1);

end;

{ ОРГАНИЗАЦИЯ ЛОГИКИ ПРОГРАММЫ }

begin { ВЕТВЛЕНИЯ В ЛОГИКЕ ПРОГРАММЫ }

  { Условие с одной ветвью }
    if bool1 then str1:='Yes';
    // Запись в несколько строк:
    if not bool1 then
      begin
        str1:='No';
      end;

  { Условие с двумя ветвями }
    if bool1 then str1:='Yes'
      // Перед ключевым словом ELSE точка с запятой не ставится:
      else str1:='No';
      // Запись в несколько строк:
    if bool1 then
      begin
        str1:='Yes';
      end
    else
      begin
        str1:='No';
      end;

  { Множественный выбор между несколькими условиями }
    if        numb_2b = 0   then j:=0
      else if numb_2b < 10  then j:=2
      else if numb_2b < 100 then j:=5
      else                       j:=10;

  { Сравнение по образцу }
    case numb_4b of    // Значение переменной далее сравнивается с образцами:
      0        : j:=0; { Можно указать конкретное значение при совпадении
                         с которым выполняются операции после двоеточия. }
      1..100   : j:=2; // Можно указать диаппазон значений.
      647, 729 : j:=3; // Можно указать несколько значений через запятую.
      else j:=-1;      { Значение по умолчанию, если совпадений не найдено.
                         Эта строка не обязательна.}
    end;

  { Тернарная условная операция }
    { В FPC нет тернарных условных операций. Вместо них в модуле Math существует функция ifThen,
      которая работает только с числами. При этом вычисляются все аргументы для передачи
      их значений в функцию (а не только подпадающие под условие), что влечёт лишние вычисления }
    j := ifThen(i>10, i, i*2);

    // Цепочка тернарных операторов делается через вложение функции ifThen
    j := ifThen(i=0,   0,
         ifThen(i<10,  2,
         ifThen(i<100, 5,
                      10)));

  { БЕЗУСЛОВНЫЕ УПРАВЛЯЮЩИЕ КОМАНДЫ }
    goto mimimi; // Переход к метке с именем mimimi
    writeln('Этот оператор будет пропущен');
    { Процедуры завершения работы программы }
      Exit;     // Закончить работу программы или текущей подпрограммы в штатном режиме
      Halt(17); // Закончить работу программы в штатном режиме, вернув код возврата (errorlevel) 17
      RunError; // Аварийно завершить работу программы с нулевым кодом возврата
      RunError(23); // Аварийное завершение с кодом возврата 23
  mimimi:  // Имя метки. После неё ставится знак двоеточия

end;

begin { ЦИКЛЫ }

  // Цикл со счётчиком (параметром)
  for i:=1 to 9 do write(i); // На каждой итерации счётчик увеличивается на 1.
  // Если счётчик должен уменьшаться, то вместо to используется downto:
  for i:=9 downto 1 do write(i);
  // В качестве параметра можно использовать любой дискретный (порядковый) тип
  for letter1:='a' to 'z' do write(letter1);
  writeln;

  factorial1 := 1;
  for i:=2 to 5 do // Если в теле цикла несколько операторов,
    begin          // то они заключаются в логический блок BEGIN-END
      factorial1 := factorial1 * i;
      writeln (i,'! = ',factorial1,'; ');
    end;

  // Вложенный цикл со счётчиком
  writeln('Таблица сложения:');
  for i:=1 to 5 do
    begin
      for j:=1 to 5 do
        write(i+j,' ');
      writeln;
    end;
  writeln('После выполнения циклов значения счётчиков сохраняются: i = ',i,
                                                               ' и j = ',j);
    // Цикл с предусловием
  i:=12;
  while i<90 do
    begin // Удваиваем число если оно меньше 90
      i:=i*2;
      write(i,' ');
    end;  writeln(' Цикл с предусловием окончен.');

  // Цикл с постусловием
  repeat
    i := i div 3; // Можно использовать несколько операторов без заключения
    write(i,' '); // их в блок begin-end
  until i<10; // Уменьшаем число в 3 раза пока не преодолеем порог меньше 10
  writeln(' Цикл с постусловием окончен.');

  // Перерывание работы цикла
  repeat
    inc(i);
    if i mod 2 = 0 then continue; // Переход на следующую итерацию
    if i>30 then break; // Выход из цикла
    write(i,' ');
  until false; { При таком условии цикл будет повторяться вечно,
                 если его не прервать }
  writeln(' Вечный цикл окончен.');

  // Прерывание работы вложенных циклов
  writeln('Нечетные строки треугольной таблицы сложения:');
  for i:=1 to 5 do
  begin
    if i mod 2 = 0 then continue; // Переход на следующую итерацию основного цикла
    for j:=1 to 5 do
    begin
        if j>i then break;          // Выход из текущего вложенного цикла с возвратом в основной
        write(i+j,' ');
        continue; // Во вложенном цикле переходит на следующию итерацию этого вложенного цикла
    end;
    writeln();
  end;

  {$ifdef debug}
  write('Введите строку текста:');
  readln(str1); { Процедура READLN считывает введённый текст в переменную.
    Для надёжности лучше использовать переменную строкового типа,
    потому как если в численную переменную пользователь по невнимательности
    введёт буквы, то программа зависнет. }
  writeln(str1);
  {$endif}

end;

begin { РЕКУРСИЯ }
  // Рекурсия с ветвлением по условию:
  writeln('10! = ', factorial(10)); // = 3628800.  Вычисление факториала через обычную рекурсию
  writeln('1 + .. + 10 = ', summNatural(10)); //  == 55
  writeln('60! = ', factorial2(60)); // = 3628800.  Факториал через рекурсию с множественным выбором

  str1:='';
  for i:=2 to 128 do   // Формируем список простых чисел
    if (prime(i)) then str1 += ' ' + intToStr(i) + ' ';
  writeln('Простые числа: ', str1);

  writeln('Суммы округлённых квадратных корней чисел - ');
  writeln('от 1 до 1000: ', sumSqrt(1000));
  // Псевдорекурсия не переполняет стек при больших значениях:
  writeln('от 1 до 1000000: ', trampoline(@sumSqrtTail, 1000000));

end;

{ СОСТАВНЫЕ СТРУКТУРЫ ДАННЫХ }

begin { СТАТИЧЕСКИЕ МАССИВЫ }
  // Доступ к элементам массива осуществляется через селектор - индекс в квадратных скобках:
  arr1[5] := 73;             // Запись в массив значения - в ячейку с индексом 5.
  arr1[6] := arr1[5] + 2;    // Элемент массива можно использовать как обычную переменную.
  arr3d[1943,7,23] := 398;   // Запись значения в многомерный массив.
  arr3d[1943][7][23] := 398; // То же самое в чуть более длинном формате.

  // Контроль допустимости диаппазона
  {$R-} arr1[105]:= 5; // В режиме {$R-} поверка на корректность индекса не проводится:
     writeln('Удалось записать значение в элемент вне диаппазона. Он стал равен ', arr1[105]);
   // В режиме {$R+} попытка обращения к элементу с некорректным индексом выдаст ошибку
    {$ifdef debug}
      {$R+} j := arr1[105]; {$R-}  // Range check error!
    {$endif}

  // Перебор элементов массива
  for i:=1 to length(arr1) do arr1[i]:=i; // Функция length(X) возвращает длину массива X
  // Если индексы не числовые или же начинаются не с 1, то нужно использовать функции LOW и HIHG,
  // возвращающие для массивов начальный и конечный индексы:
  for i:=low(arr1) to high(arr1) do arr1[i]:=i;

  for i:=0 to 2 do
    for j:=0 to 2 do
      tablesum1[i,j]:=i+j; // Заполнение таблицы сложения

  // Цикл считывания всех без исключения элементов массива
  n:=0;
  for i in tablesum1 do
    n += i;
  writeln('Сумма всех чисел в таблице: ', n);

  // Копирование одного массива в другой возможно, если совпадают их длины и тип.
  tablesum2 := tablesum1;
end;

begin { ЗАПИСИ }
  // Доступ к полям записи осуществляется через селектор - точку, после которой идёт имя поля:
  rec1.i := 15;     // В поле i записи rec1 записано новое значение 15
  j := rec1.i + 2;  // Используем поле, как обычную переменную

  { Несмотря на то, что имя поля i совпадает с глобальной переменной i, конфликта не возникает,
    т.к. запись имеет своё собственное пространство имён: имена глобальных переменных не видны
    внутри записи, а имена полей записи не видны извне. При этом в отличие от подпрограмм
    инкапсуляция происходит без сокрытия - поля доступны на чтение и запись либо через селектор,
    либо через оператор присоединения with. Этот оператор даёт указание считать переменные внутри
    своего тела полями указанной после слова with записи, и только если у записи таких полей нет -
    обращаться в к соответствующей глобальной переменной: }
  with rec1 do begin // Имена i, b1, b2 принадлежат пространству имён rec1, а имя j - нет. Поэтому:
    i:=0; b1:=false; b2:=false; // тут изменятся поля записи,
    j:=0;                       // а тут изменится глобальная переменная.
  end;

  { В операторе with можно указать несколько имён записей - столкнувшись внутри оператора с именем
    переменной компилятор ищет её как поле одной из перечисленных записей, начиная обход с конца: }
  with rec1, rec1packed do i:=5; // Изменено поле только последней записи, а не всех записей.
  writeln('rec1packed.i = ', rec1packed.i); // 5
  writeln('А вот в записи rec1 поле i осталось неизменным - оно равно ', rec1.i); // 0

  // Оптимизация потребления памяти - результат применения ключевых слов packed и bitpacked:
  writeln('Размер записи rec1 : ',          sizeof(rec1));           // 8 байт
  writeln('Размер записи rec1packed : ',    sizeof(rec1packed));     // 6 байт
  writeln('Размер записи rec1bitpacked : ', sizeof(rec1bitpacked));  // 5 байт

  { Использование вариантных полей записи }
  passport1.series_number:=1234567890; // Запись числа в поле первого варианта
  // Независимо от значения селектора в эту же область памяти можно записать другой вариант полей:
  passport1.series:='ABCD';  passport1.number:=123456;
  { Считать информацию тоже можно обоими вариантами. Поэтому правильный результат считывания будет
    у того варианта, который использовался при записи последним. Так, например, сейчас в этой
    области памяти хранится строка и число - поэтому чтение этих данных как числа приведёт к выводу
    на экран мусорной информации: }
  writeln('Серия и номер паспорта в виде числа: ', passport1.series_number); // Некорректный вывод
  // А вот этот вывод будет правильным:
  writeln('Серия и номер паспорта в виде строки и числа: ', passport1.series, passport1.number);
end;

begin { МНОЖЕСТВА (НАБОРЫ) }

  { Инициализация и использование множеств }
    char_set1 := []; // Инициализация множества, как пустого. Не инициализированные множества
                     // в ряде случаев могут содержать мусорные данные
    char_set2 := char_set1; // При совпадении типов можно сделать копию другого множества.
    // Либо задать перечисление:
    char_set1 := ['a'..'z']; // Теперь множество содержит только малые латинские буквы
    digits_char_set1 := ['0'..'3','5']; // В этом множестве - несколько символов цифр
    // Заполнить множество всеми допустимыми значениями можно с помощью функций LOW и HIGH:
    digits_char_set1 := [low(digits_char_set1)..high(digits_char_set1)]; // = ['0'..'9']

  { Операции над множествами }
    // Операция принадлежности IN проверяет, есть ли в множестве элемент с указанным значением:
    if letter1 in char_set1 then
        writeln(letter1,' является малой латинской буквой.');
    if not (letter1 in digits_char_set1) then
        writeln(letter1,' не является цифрой.');

    char_set2 := ['a'..'z'] + ['A'..'Z'] + digits_char_set1; // Объединение множеств
    char_set1 := char_set2 - digits_char_set1;  // Разность множеств
    char_set2 := char_set1 * digits_char_set1;  // Пересечение множеств
    // Симметричная разность - элементы входящие только в одно из множеств
    // (т.е. результат объединения, из которого вычтен результат перечесения) :
    char_set2 := char_set1 >< digits_char_set1;

  { Изменение множества }
    char_set1 += ['#','!'];  // Добавление в множество другого множества
    include(char_set1, '$'); // Добавление только одного элемента через стандартную процедуру FPC
    // Cтоит заметить, что если в множество добавляется элемент, который уже там есть, то множество
    // никак не изменяется (ведь в множестве никак не может быть двух одинаковых элементов).

    char_set1 -= ['$'];      // Удаление из множества другого множества
    exclude(char_set1, '!'); // Удаление только одного элемента через стандартную процедуру FPC
    char_set2 := [low(char_set2)..high(char_set2)] - char_set2;  // Инвертирование множества

  { Сравнение множеств }
    // Справедливы следующие равенства:
    if (([1..9] = [1..9]) and // Множества равны, если имеют одинаковые наборы элементов
       ([1..9] <> [1..8]) and // Множества не равны, если их наборы элементов не одинаковы
       ([1..9] >= [2..5]) and // Множество X больше или равно Y, если вcе элементы Y входят в X
       ([5..7] <= [1..9])     // Множество X меньше или равно Y, если вcе элементы X входят в Y
    ) then writeln('Все выражения сравнения множеств истинны.');

  { Перебор всех элементов множества}
    str1:='';
    for letter1 in char_set1 do
      str1 += letter1;
    writeln('Множество char_set1 содержит символы: ', str1);

  { Контроль элементов на вхождение в допустимый диаппазонов значений }
    // Если базовый тип множества является пользовательским перечислением, то в множество возможно
    // поместить только константы из этого перечисления:
    level_set1 := [lowlevel, highlevel];

    { В режиме {$R-} в множества с базовым типом byte можно пытаться добавлять любые числа - ошибки
      при этом возникать не будет (максимум - предупреждение компилятора при добавлении числовой
      константы вне диаппазона). Но при этом в множестве сохранятся только те элементы, которые
      попадают в объявленное подмножество значений: }
    {$R-} digits_set1 := [7, 12, 300]; // Результат - [7], т.к. только 7  - в диаппазоне 0..9

    // Включение режима {$R+} будет выдавать исключения при попытке записать вне диаппазона 0..255
      {$R+}
             {$ifdef debug}
              digits_set1 := [300]; // Этот код выдаст ошибку времени выполнения
             {$endif}
      // Однако запись вне диаппазона подмножества, но в рамках базового типа, ошибку не выдаёт:
      digits_set1 := [12]; // Число 12 вне диаппазона 0..9 проигнорировано, его нет в множестве:
      i := 12;
      if not (i in digits_set1) then
          writeln('Число 12 не попало в множество, предназначенное для цифр.');

    // Более странное поведение у множеств с базовым типом char. Запись в множество символов вне
    // диаппазона '0'..'9' точно так же, как и с числами, происходит без появления исключения:
      digits_char_set1 := ['Z'];
      letter1 := 'Z'; // Теперь, если поместить этот символ в переменную и сделать операндом,
        // то в режиме {$R+} оператор IN выдаст исключение, а в режиме {$R-} покажет что символ Z
        // неожиданно присутсвует в множестве (хотя в отладчике множество отображается пустым):
      {$R-} if letter1 in digits_char_set1 then
         writeln('Буква Z ошибочно видна в множестве, предназначенном для символов цифр.');
      // Итог: контроль для чисел происходит при записи, а для символов - при чтении в режиме {$R+}
end;

begin { УКАЗАТЕЛИ }

  { Непроинициализированый указатель обычно хранит константу nil (т.е. никуда не ссылается),
    но полагаться на это не стоит, т.к. в ряде случаев он может содержать случайные данные.
    Поэтому в целях безопасности если в нём нет конкретного значения или он больше не нужен, то
    его лучше обнулить: }
  int_pointer1 := nil; // Обнуление указателя.

  { В Free Pascal ссылочные переменные могут ссылаться на именованные переменные. Для этого
    используется оператор взятия ссылки @ на область памяти, в которой хранится переменная:}
  int_pointer1 := @i; // Теперь в указателе int_pointer1 хранится адрес переменной i
  int_pointer1 := addr(i); // Получить ссылку на переменную X можно также функцией addr(X)

    // Теперь к одной и той же области памяти можно обратиться либо через именованную переменную i:
    i := 5;
    // либо использовать указатель вместе с оператором разыменования ^ (стрелка вверх),
    // который будучи помещённым после имени указателя означает "переход по ссылке": }

    int_pointer1^ := 7;  writeln('i = ',i); // Значение i поменялось на 7

  { Важно отметить, что в общем стандарте Pascal операция взятия ссылки запрещена, поскольку это
    несёт угрозы ошибок. Например, если в указатель поместить адрес локальной переменной какой-то
    функции, то после завершения работы функции переменная исчезнет, а указатель останется с прежним
    неактуальным адресом - а значит любые дальнейшие чтение или запись информации по этому адресу
    будут приводить к трудно отслеживаемым ошибкам. Поэтому применения такой техники следует
    либо вообще избегать, либо производить с особой осторожностью.

    Другой опасный источник ошибок - это стандартная возможность записи в указатель целого числа,
    операции прибавления к указателю целых чисел и прочие арифметические операции. Ведь можно
    элементарно забыть поставить оператор разыменования и в результате этого записать число не в
    переменную по ссылке, а в сам указатель. Хоть арифметические манипуляции с адресами в указателях
    в отдельных случаях и могут быть полезными, но в целях повышения надёжности программы их лучше
    вообще запретить следующей директивой компилятора: }
    {$PointerMath-} // Эту директиву нужно поместить в начале кода, до ключего слова PROGRAM.

  { Использование указателей второго порядка }
    int_doublepointer1 := @int_pointer1; // Указатель на указатель
    int_doublepointer1^^ := 9; // Для доступа к переменной по ссылке второго порядка нужно две ^^
    writeln('i = ',i);         // Значение i поменялось на 9

  { Использование нетипизированных указателей }
  pointer1 := int_pointer1; { Нетипизированный указатель может присваивать значения типизированных.
           При этом для доступа к переменной через нетипизированный указатель недостаточно оператора
           разыменования, т.к. компилятору непонятно, какой тип данных находится по ссылке.
           Понадобится либо скопировать значение в типизированный указатель: }
  int_pointer2 := pointer1;
  int_pointer2^ := 3; writeln('i = ',i);
  // либо сделать ручное приведение типа:
  PInteger(pointer1)^ := 6; writeln('i = ',i);
end;

begin  { БЕЗЫМЯННЫЕ ДИНАМИЧЕСКИЕ ПЕРЕМЕННЫЕ }
     { Динамические переменные создаются в динамической области памяти, называемой "куча".
       Узнать какой размер памяти на данный момент выделен для нашей пограммы можно через
       элемент глобальной переменной-записи getHeapStatus.TotalAllocated }
  writeln('Использовано памяти: ', getHeapStatus.TotalAllocated); // Размер выделенной памяти

  new(int_pointer1); { Стандартная процедура new(X) создаёт новую безымянную переменную того же
    типа, что и типизированный указатель X, выделяет для неё память (участками кратными 16 байт)
    и сохраняет адрес этой области памяти в саму переменную X.
    Теперь с этой динамической переменной можно работать, используя оператор разыменования: }
  int_pointer1^ := 4; writeln('int_pointer1^ = ', int_pointer1^); // = 4
  writeln('Использовано памяти: ', getHeapStatus.TotalAllocated); // Стало больше на 16 байт
  dispose(int_pointer1); { Функция dispose уничтожает динамическую переменную, на которую указывает
    указатель, и освобождает выделенную для неё память. Если переменную не уничтожить и при этом
    снова вызвать процедуру new для этой же ссылки, то доступ к безымянной переменной будет
    безвозвратно потерян - а значит она продолжит занимать выделенную под неё память до самого конца
    выполнения программы. Такие ставшие недоступными переменные называются "переменными-сиротами",
    а сама ситуация называется "утечкой памяти". Её требуется тщательно избегать (в т.ч. через
    скурпулёзный контроль размера выделенной памяти. }
  writeln('Использовано памяти: ', getHeapStatus.TotalAllocated); // Уменьшилось на 16 байт

  // Вместо процедуры New можно использовать процедуру GetMem:
  GetMem(int_pointer1, 4); { Выделить 4 байта памяти для новой переменной integer и адрес сохранить
                             в указатель int_pointer1. Реально при этом будет выделено 16 байт. }
  dispose(int_pointer1);   // Память освобождена
  { Хорошая практика - использовать функцию SizeOf(X), возвращающую количество байт, требуемых
    для хранения переменной X. Это позволяет точно задавать требуемый размер памяти даже
    для сложных динамических структур данных: }
  GetMem(int_pointer1, SizeOf(int_pointer1^));  // Память 16 байт выделена
  dispose(int_pointer1);   // Память освобождена

  { Важно отметить, что после уничтожения динамической переменной указатель продолжает хранить
    старый адрес этой переменной. Такая ссылка, указывающая на освобождённый участок памяти
    называется "висячей ссылкой". Дальнейшие чтение или запись информации по этой ссылке могут
    привести к тяжёлым ошибкам: при чтении могут прочитаться посторонние или мусорные данные, а при
    записи -  запортиться информация в другой, новой переменной, которая по несчастью разместилась
    в освобождённом участке памяти. Поэтому важно все висячие ссылки сразу обнулять.}
  int_pointer1 := nil; // Обнуление висячей ссылки

  // При удалении даже одной динамической переменной висячих ссылок может оказаться несколько:
  new(int_pointer1);
  int_pointer2 := int_pointer1; // Оба ссылки указывают на одну область памяти.
  dispose(int_pointer1);        // Переменная удалена и образовалось две висячих ссылки
  int_pointer1 := nil; int_pointer2 := nil; // Важно обнулить их все!

  { При создании большого числа динамических переменных возможен риск нехватки свободной памяти.
    В этом случае потребуется либо обработка соответсвующего исключения, либо включение режима
    присваивания указателю значения nil в случаях, когда память не удалось выделить. Сделать это
    можно путём изменения значения глобальной переменной ReturnNilIfGrowHeapFails на true: }

    ReturnNilIfGrowHeapFails := true; // Теперь при нехватке памяти во время создания новой
                                      // динамической переменной в указатель запишется nil
end;

begin { ДИНАМИЧЕСКИЕ МАССИВЫ }

  { Создание динамических массивов }
    // Память для динамического массива выделяется не в ручную, а в полуавтоматическом режиме.
    // Изначально переменная-указатель содержит nil, длина массива равна 0
    write('Длина несозданного массива: ',length(AChar1));        // 0
    if (AChar1 = nil) then writeln(', а указатель равен nil');  // true

    { Функцией setLength() можно задать новую длину массива. В этом случае выделяется
      соответсвующая новой длине область памяти, содержимое массива копируется в эту новую область,
      счётчик ссылок увеличивается на 1 для этой новой области, и уменьшается на 1 для старой }
    setLength(AChar1,10); // Создан массив из 10 элементов с индексами в диаппазоне 0..9
    setLength(AChar1,20); // Содержимое скопировано в новую 20-байтную область, а у старой
                          // счётчик ссылок уменьшился на 1.
    setLength(AChar1,6);  // В новую 6-байтную область скопировано только первые 6 элементов
    setLength(AChar1,0);  // Длина обнулена, новая область не выделена, у старой счётчик ссылок
                          // уменьшился на 1, а указатель стал равен nil
    if (AChar1 = nil) then writeln('Указатель обнулённого массива равен nil'); // trye
    // Если счётчик ссылок для области памяти уменьшился до нуля, то эта память освобожается.

  { Использование массивов }
    { Синтаксически работать с элементами динамического массива можно аналогично статическому.
      Но поскольку переменная динамического массива является указателем, то на самом деле привычное
      обращение к элементу массива компилятор обрабатывает как операцию разыменовывания указателя: }
    setLength(AChar1,10);
    AChar1[5] := 'F'; // Запись в массив значения - в ячейку с индексом 5. Или точнее - переход
                      // по ссылке на адрес, где хранится элемент массива с индексом 5
    letter1 := AChar1[5]; // Аналогичным образом осуществляется чтение элемента

  { Контроль допустимости диаппазона }
    {$R-} AChar1[15]:= 'G'; // В режиме {$R-} поверка на корректность индекса не проводится:
       writeln('Удалось записать значение в элемент вне диаппазона. Он стал равен ', AChar1[15]);
    // В режиме {$R+} попытка обращения к элементу с некорректным индексом выдаст ошибку
    {$ifdef debug}
        {$R+} letter1 := AChar1[15]; {$R-}  // Range check error!
    {$endif}

  { Копирование массивов }
    // В отличие от статических массивов для динамических недостаточно сделать операцию присвоения:
    AChar2 := AChar1; // Скопирован только указатель. Обе переменные указывают на один адрес памяти,
                      // а счётчик ссылок на эту область памяти увеличился на единицу.
    AChar1[0] := 'A';
    AChar2[0] := 'B'; // Это присвоение изменило и массив AChar1
    writeln('Значение AChar1[0] "испортилось". Стало равным ', AChar1[0]);  // 'B'

    // Поэтому нужно применять либо функцию setLength, либо функцию copy:
    setLength(AChar1,10);           // Вызов setLength() создало отдельный массив
    AChar1[0]:='A'; AChar2[0]:='B'; // Теперь указатели не равны, массивы независимы друг от друга:
    writeln('Значение AChar1[0] осталось неповреждённым: ', AChar1[0]);  // 'A'

    { Используемая для строк функция copy() применима и к динамическим массивам. При копировании
      она создаёт отдельный массив с длиной, равной количеству копируемых элементов: }
    AChar2 := copy(AChar1, 3, 4); // Скопировать 4 элемента, начиная с элемента с индексом 3
    AChar2 := copy(AChar1, 3);    // Скопировать от элемента с индексом 3 до конца массива
    AChar2 := copy(AChar1, 0);    // Скопировать массив целиком

  { Перебор элементов массива }
    str1:='';
    for i:=0 to high(AChar1) do     // high(AChar1) = length(AChar1) -1
      str1 += AChar1[i];
    writeln('Содержимое массива AChar1: ', str1);
end;

  writeln('На этом всё. Жмите ENTER для выхода.');
  readln;

END. { После последнего end раздела операторов ставится точка, а не точка с запятой. }

