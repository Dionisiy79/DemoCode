// Однострочный комментарий до конца строки задается двумя косыми чертами в начале комментария
{ Многострочный комментарий - обрамляется
  фигурными скобками. }

{ Наиболее важные специальные директивы компилятора }

  {$mode objfpc} // Эта директива - включает режим совместимости с Object Pascal
  {$H+} // Строкой по умолчанию является строка неограниченной длины в текущей кодировке компилятора
  {$J-} // Выключает возможность изменения типизированных констант

{ Директивы условной компиляции - позволяют компилировать код избирательно }

  {$define Sym1} { Объявление символа, который можно использовать в условной компиляции
    Символы unix, windows, Win32, Win64 автоматически объявляются компилятором в соответсвующих ОС }
  {$define debug}

  // Использование символов и опций для условной компиляции:
  {$ifdef Sym1} // Проверка условия, объявлен ли указанный символ
    // Код, выполняющийся при объявленном символе Sym1
    {$note Hello! Symbol is defined!}  // Генерация сообщения при компиляции
  {$else} // Код, выполняющийся в противоположном случае. Проверку else можно не использовать.
    {$error В вашей системе код нельзя скомпилировать!} // Остановка компиляции с генерацией ошибки
  {$endif}

  {$ifndef Sym1} { Этот код компилируется, если символ НЕ объявлен} {$endif}
  {$ifopt H+} {Этот код компилируется, если указанная опция включена} {$endif}
  {$undef Sym1} // Отмена объявления ранее объявленного символа

  { Для вывода UTF-строк в консоль есть два подхода:
    1. Явно указать, что исходный код в кодировке UTF8. При этом все строки будут автоматически
       конвертироваться в кодировку UCS2 (внутреннюю кодировку FPC). А для вывода в консоль
       понадобится подключение модуля LazUTF - он автоматически преобразовывает выводимые в консоль
       строки в текущую кодировку консоли. При этом ограничивается возможность работать с
       UTF8-литералами, а также отображать символы не входящие в текущую кодовую страницу консоли.}
//       {$define UTF8mode} // Этот символ означает использование режима {$codepage UTF8}
       {$ifdef UTF8mode}
         {$codepage UTF8}  { требует от компилятора преобразовать все используемые в программе
                             строковые константы из кодировки UTF-8 в UCS2}
       {$endif}
  { 2. Смена системной кодировки windows на UTF-8 и изменение шрифта консоли на UTF-совместимый. }


program DemoProject; // Главный программный файл начинается ключевым словом PROGRAM
uses sysutils,  // Подключение внешних модулей. Модуль sysutils содержит много популярных функций.
  {$ifdef UTF8mode}
    LazUTF8, { Модуль для корректной работы терминала с кодировкой UTF8
               Если этот модуль автоматически не подключается, то нужно в IDE зайти в меню:
               Проект -> Инспектор проекта -> Правый клик по Требуемые пакеты -> Добавить ->
               ищем в имя пакета LazUtils -> OK }
    {$ifdef unix}    cwstring,  {$endif} // Модуль для корректной работы модуля LazUTF8 в Linux
  {$else}
    {$ifdef windows}
       SetWinConsoleFont, // Самописный модуль автоматической смены шрифта в консоли на UTF8-шрифт
    {$endif}
  {$endif}
  {$ifdef windows} windows, {$endif} // Модуль со специфичными функциями Windows
  Math; // Модуль с математическими функциями

{ РАБОТА С ПЕРЕМЕННЫМИ }
// Объявление имён и типов переменных.
  { Имя переменной должно начинаться с латинской буквы или символа подчеркивания,
    может также содержать цифры. Длина имени от 1 до 127 символов.
    Написание не чувствительно к регистру.
  }
const { Объявление имён неизменяемых переменных (констант). Производится
        до начала исполняемого блока. Константе автоматически присваивается
        "минимальный" тип данных, достаточный для её представления.}
    NUMB_PI = 3.14;     // Для удобства имена констант пишут заглавными буквами,
    Str_Hi = 'Привет';  // но строчными тоже допустимо

    {$J+}
    REALNUMB:Double = 789; { При включенной директиве $J+ можно создавать т.н. типизированные
       константы, которые по сути являются статическими переменными (т.е. их можно менять по ходу
       программы). Тип таких констант задаётся через двоеточие. }
    {$J-}

var // Объявление имён изменяемых переменных. Производится до начала исполняемого блока.
    // Целые числа
    numb_1b : Shortint; // 1 байт  (        -128 .. 127        )
    numb_2b : Smallint; // 2 байта (      -32768 .. 32767      ) синоним Integer в 32-битных ОС
    numb_4b : Longint;  // 4 байта ( -2147483648 .. 2147483647 ) синоним Integer в 64-битных ОС
    numb_1b_p : Byte;   // 1 байт без знака  ( 0 .. 255   )
    numb_2b_p : Word;   // 2 байта без знака ( 0 .. 65535 )
    numb_4b_p : DWord; // 4 байта без знака ( 0 .. 4294967295 ) синоним Cardinal и LongWord
    numb_8b_p : QWord;    // 8 байт без знака  ( 0 .. 18446744073709551615 )

    // Вещественные числа с плавающей точкой
    rnumb_4b : Single;    // 4 байта ( 2,9*10^-39   .. 1,7*10^38   )
    rnumb_6b : Real;      // 6 байт  ( 1,5*10^-45   .. 3,4*10^38   )
    rnumb_8b : Double;    // 8 байт  ( 5,0*10^-324  .. 1,7*10^308  )
    rnumb_10b : Extended; // от 4, 8 или 10 байт ( 3,4*10^-4932 .. 1,1*10^4932 )
    // Вещественные числа с фиксированной точкой
    rnumb_8bf : Currency; // 8 байт ( -922337203685477.5808 .. 922337203685477.5807 ) -

    // Логические типы
    bool1, bool2 : Boolean; // Занимает 1 байт. Принимает значения true или false

    v1 : Variant;   // Вариативная переменная может принимать значения любого значимого типа:

    // Символьные типы
    letter1 : char;  // 1 байт. Содержит символ в кодировке ASCII.
    wideletter1 : widechar;  // 2 байта. Unicode-символ в кодировке UCS2.

    // Строка
    ansistr1 : ansistring;   { Строка-ANSI в текущей однобайтной системной кодировке. Безразмерная -
          завершается нулём. Переменная является указателем на область памяти, где хранится текст. }
    str1 : string; // Строка ansistring при опции компилятора {H+}. Иначе - shortstring.
    unistr1: UnicodeString; { Эквивалент AnsiString, но в двухбайтной кодировке }

    widestr1 : widestring;   // Строка в двухбайтной кодировке UTF-16
    rawstr1: RawByteString; { Строка без указания кодировки. Операции с такими строками происходят
                              без автоматического преобразования из одной кодировки в другую }

    // Строковые типы старого стандарта. При codepage utf8 они работают некорректно.
    shortstr1 : shortstring; // Строка длиной 255 символов
    shortstr2 : string[10];  // Строка shortstring длиной 10 символов
    zerostr1 : PChar; { Указатель на массив символов char, как на строку, оканчивающуюся
                        нулевым байтом #0  (Стандарт языка C) }


    i, j, factorial1 :integer;

    arr1 : array [1..100] of integer; // Нумерация элементов может начинаться
                                      // не с нуля,а с любого целого числа.
    arr3d : array [1941..1945,1..12,1..31] of integer; { Трёхмерный массив - для
    хранения значений в ячейках с индексами указывающими на год, месяц, число.}

  label mimimi;  // Объявление метки с именем mimimi (для безусловного перехода)

BEGIN // Коммандами begin и end; обозначается начало и конец логического блока

begin { КОММАНДЫ ВЗАИМОДЕЙСТВИЯ С ПОЛЬЗОВАТЕЛЕМ }


  // Настройка windows-консоли для отображения UTF8-строк
  {$ifndef UTF8mode}
    {$ifdef windows} // Исходные параметры кодировок:
      writeln('Console output codepage: ', GetConsoleOutputCP());           // 866
      writeln('Console output stream codepage: ', GetTextCodePage(Output)); // 866
      writeln('System codepage: ', DefaultSystemCodePage);                  // 1251
      writeln('Console input codepage: ', GetConsoleCP());                  // 866
      writeln('Console input stream codepage: ', GetTextCodePage(Input));   // 866

      SetConsoleOutputCP(CP_UTF8); // Смена кодировки отображения консоли
      writeln('Console output codepage: ', GetConsoleOutputCP());  // Стало 65001 вместо 866
      SetTextCodePage(Output,CP_UTF8); // Смена кодировки потока вывода в консоль
      writeln('Console output stream codepage: ',GetTextCodePage(Output)); // Стало 65001 вместо 866
      SetMultiByteConversionCodePage(CP_UTF8); // Смена системной кодировки
      writeln('System codepage: ', DefaultSystemCodePage);  // Стало 65001 вместо 1251
    {$endif}
  {$endif} // После этих трёх изменений UTF8-строки будут нормально отображаться и вводиться

  // Вывод текстовых строк
  write('Hello world!');   // Вывод строки в консоль без перевода строки
  writeln('Привет мир!');  // и с переводом строки
  writeln('Буква Пси: Ψ, ψ');  // Вывод unicode-сиволов работает при отключенном режиме UTF8
  // Вывод чисел с выравниванием по правому краю
  writeln(123:6);    // (целое число : кол-во знаков)
  writeln(2.5:10:2); // (вещественное число : общее кол-во знаков : кол-во знаков после запятой)

  // Пауза работы
  if false then begin
  sleep(3000); // Пауза на 3000 мс. Требует uses windows
  // Ожидание нажатия любой клавиши. Требует устаревший модуль - uses Crt:
  // writeln('Нажмите любую клавишу:'); readkey;
  // Ожидание нажатия клавиши ENTER (ввода строки)
  write('Нажмите ENTER:'); readln;
  end;

end;

begin { РАБОТА С ПЕРЕМЕННЫМИ }
// Инициализация переменных
  numb_4b := 1234567890;     // Непроинициализированная переменная обычно хранит значение 0
  numb_1b := 12345;          // Число больше допустимого 127, поэтому сохранится
                             // неправильное значение (обрезанное до 8 бит)
  rnumb_4b := 12345.456789;  // В качестве разделителя используется точка
  rnumb_4b := 456.789;       // Проинициализированную переменную можно перезаписать новым значением

  numb_2b := $F57;           // Шестнадцатеричное число начинается с символа $
  numb_2b := &4651;          // Восьмеричное число начинается с символа &
  numb_2b := %10011110;      // Двоичное число начинается с символа %

  bool1:=true; bool2:=false; // Непроинициализированная переменная хранит значение FALSE
  letter1 := 'W';            // Непроинициализированная переменная хранит значение 'a'
  letter1 := #75;            // Символ с ASCII-кодом 75

  str1 := 'Тестовая строка';  // Непроинициализированная переменная хранит пустую сроку
  writeln(str1);
  str1 := 'граф д''Артаньян'; // Одинарную кавычку можно сохранить в строке, написав её дважды
  writeln(str1);
  str1 := 'граф д' + #39 + 'Артаньян';  // либо указав ASCII-код 39
  writeln(str1);
  str1 := 'Первая строка' + LineEnding  + 'Вторая строка'; // Перенос строки в стандарте текущей ОС
  writeln(str1);
  str1 := #13#10;  // Символы Carriage Return (возврат каретки) и Line feed (перенос строки)
  str1 := #9#8#12; // Символы  Tab | Backspace | Form feed (новая страница)

  // Вариативная переменная может принимать значения любого значимого типа:
  v1 := 78; v1 := 'строка'; v1 := TRUE;

// Использование констант и переменных

  numb_2b := numb_1b;
  writeln(numb_2b);
  writeln(' ',letter1,str1,bool2); // В функции вывода можно перечислять
                                   // выводимые аргументы через запятую.
  rnumb_4b := rnumb_4b / numb_4b;  // В выражениях для присвоения нового значения
  // можно использовать эту же переменную, пока в ней хранится старое значение.
end;

begin { ОПЕРАЦИИ }
  { Арифметические операторы }
    numb_1b := ( 7 + 2 - 3 ) * 4; // Сложение вычитание умножение для любых типов чисел.
    numb_1b_p := 1 - numb_1b; { Результирующее значение не проверяется на предмет
                                попадания в допустимый диапазон: }
    writeln('В переменной типа BYTE отрицательное значение ', 1 - numb_1b,
                                         ' сохранилось как ', numb_1b_p);

    numb_4b := 2147483647;
    numb_4b := numb_4b  + 2; // Пример арифметического переполнения
    writeln('В переменной типа Longint 33-битное значение ', 2147483647 + 2,
                                        ' сохранилось как ', numb_4b);

    {$Q+} // Эта директива компилятора включает режим проверки арифметического переполнения
    {$Q-} // Выключение режима проверки переполнения (значение по умолчанию)

    numb_4b := 2147483647;
    numb_4b := numb_4b  + 2;  // На этой строке при директиве {$Q+} программа остановится с ошибкой

    numb_2b := 31 div 8; // Целочисленное деление
    numb_2b := 31 mod 8; // Остаток от деления
    rnumb_6b := 31 / 8;  // Вещественное деление

    numb_4b := sqr(3); { Квадрат числа. Для целых чисел результат функции SQR
                         можно сохранить в т.ч. в целочисленную переменную.}
    numb_4b := 3**5; { Возведение в произвольную степень. Если операнды целочисленные,
                       то результат можно сохранить в целочисленную переменную.}
    rnumb_8b := power(2,3);   { Аналогичная функция POWER даже для целых
                                чисел возвращает вещественный результат.}
    rnumb_8b := 2**3.5;       // Возведение в дробную степень
    rnumb_8b := power(2,3.5);

    rnumb_10b := sqrt(9); // Корень квадратный из числа
    // Для вычисления корня можно использовать возведение в дробную степень:
    rnumb_8b := power(9, 1/2); // = 3

  { Унарные операторы }
    i := - numb_4b; // Унарный оператор смены знака.
    i := not i; { Побитовая инверсия - вычитание из -1. Т.е. смена знака
             и одновременный декремент. Полезна в связке с операцией смены знака.}
    i := -not i; // Инкремент. Унарный аналог i+1
    i := not- i; // Декремент. Унарный аналог i-1
    i := -not 2 * 6; { Результат равен 18, а не 13, поскольку у унарных операций
                       приоритет выше чем у операций умножения и деления.}

  { Комбинированные операторы }
    numb_4b += 5; numb_4b -= 5;  // Увеличить или уменьшить переменную на указанное число.
    numb_4b *= 3; rnumb_8b /= 3; // Умножить или поделить переменную на указанное число.

  { Битовые операции}
    inc(i); dec(i); // Функции увеличения и уменьшения значения переменной на 1 бит
    i := i << 3; i := i shl 2; { Побитовый сдвиг влево на указанное число бит
                               с сохранением знака (умножение на степень двойки )}
    i := i >> 2; i := i shr 3; { Побитовый сдвиг вправо на указанное число бит
                               с сохранением знака (деление на степень двойки)}
    i := i and 5; { Побитовое И (AND).
                    Используется для установки в нужные биты значения 0 }
    i := i or 5;  { Побитовое ИЛИ (OR).
                    Используется для установки в нужные биты значения 1 }
    i := i xor 5; { Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR).
                  Используется для смены значений нужных битов на противоположные}
  { Конкатенация строк }
    str1 := 'строка1' + 'строка2';

  { Операторы сравнения и логические операторы }
    // Во всех нижепреведенных сравнениях результат равен TRUE
    bool1 := (2 = 2)               and  // Равенство
             (2 <> 3)              and  // Неравенство
             (bool1 <> not bool1)  and  // Отрицание
             (1 >= 1) and (2 > 1)  and  // Логическое "И" (конъюнкция)
             (1 <= 1) or (2 < 1)   and  // Логическое "ИЛИ" (дизъюнкция)
            ((1 <= 1) xor (2 < 1)) and  // Логическое "ЛИБО" (исключение)
             ('Строка 2' > 'Строка 1'); // Строки сравниваются побуквенно
    writeln('Результат всех сравнений и логических операций: ',bool1);  // TRUE

end;

begin { ПРИВЕДЕНИЕ ПРОСТЫХ ТИПОВ ПРИ ОПЕРАЦИЯХ }
  { Автоматическое строковое преобразование }
    letter1 := 'R';
    str1 := 'Строка1' + letter1; // Символьный тип Char автоматически приводится к строке

  { Явное строковое преобразование }
    // Эти функции требуют uses sysutils
    str1 := intToStr(17);    // Преобразование целого числа в строку
    str1 := floatToStr(2.5); // Преобразование вещественного числа в строку
    WriteStr(str1,'2+2 = ', 2+2); // Аналог функции write - сохраняет результат в строку str1
    writeln(str1);

    ThousandSeparator := ' ';
    str1 := FloatToStrF(12345.5,ffNumber,2,2);
    writeln('Отформатированное число: ',str1);
    // Приведение числа к строке в разных системах счисления (второй параметр - число знаков)

    HexStr(175,10); // Шестнадцатеричное представление
    BinStr(175,10); // Двоичное представление
    OctStr(175,10); // Восьмиричное представление

    { Автоматическое численное преобразование }
    rnumb_4b := numb_1b; // Целые числа автоматически приводятся к вещественным
    numb_1b := numb_4b;  // При сохранении в тип меньшей разрядности биты обрезаются
                         // Директива {$Q+} это не считает переполнением и ошибку не выдаёт

    writeln('Число ',numb_4b,' хранилось в 4-х байтах. При сохранении в 1 байт стало = ',numb_1b);

end;

begin{ ИНИЦИАЛИЗАЦИЯ И ИСПОЛЬЗОВАНИЕ СОСТАВНЫХ НАБОРОВ ДАННЫХ }
  arr1[5] := 73; // Запись в массив значения - в ячейку с индексом 5.
  arr1[6] := arr1[5] + 2; // Элемент массива можно использовать как обычную переменную.
  arr3d[1943,7,23] := 398; // Запись значения в многомерный массив.
end;

begin { ОРГАНИЗАЦИЯ ВЕТВЛЕНИЙ В ЛОГИКЕ ПРОГРАММЫ }

  { Условие с одной ветвью }
    if bool1 then str1:='Yes';
    // Запись в несколько строк:
    if not bool1 then
      begin
        str1:='No';
      end;

  { Условие с двумя ветвями }
    if bool1 then str1:='Yes'
      // Перед ключевым словом ELSE точка с запятой не ставится:
      else str1:='No';
      // Запись в несколько строк:
    if bool1 then
      begin
        str1:='Yes';
      end
    else
      begin
        str1:='No';
      end;

  { Множественный выбор между несколькими условиями }
    case numb_4b of    // Значение переменной далее сравнивается с образцами:
      0        : j:=0; { Можно указать конкретное значение при совпадении
                         с которым выполняются операции после двоеточия. }
      1..100   : j:=2; // Можно указать диаппазон значений.
      647, 729 : j:=3; // Можно указать несколько значений через запятую.
      else j:=-1;      { Значение по умолчанию, если совпадений не найдено.
                         Эта строка не обязательна.}
    end;

{ БЕЗУСЛОВНЫЕ УПРАВЛЯЮЩИЕ КОММАНДЫ }
  goto mimimi; // Переход к метке с именем mimimi
    writeln('Этот оператор будет пропущен');
  mimimi:  // Имя метки, после которой должно быть двоеточие
end;

begin { ЦИКЛЫ }
  // Цикл со счётчиком
  for i:=1 to 9 do write(i); { На каждой итерации счётчик увеличивается на 1.
  Уменьшаться счётчик не может, поэтому ставить вторую цифру меньшей нет смысла}
  writeln;

  factorial1 := 1;
  for i:=2 to 5 do // Если в теле цикла несколько операторов,
    begin          // то они заключаются в логический блок BEGIN-END
      factorial1 := factorial1 * i;
      writeln (i,'! = ',factorial1,'; ');
    end;

  // Вложенный цикл со счётчиком
  writeln('Таблица сложения:');
  for i:=1 to 5 do
    begin
      for j:=1 to 5 do
        write(i+j,' ');
      writeln;
    end;
  writeln('После выполнения циклов значения счётчиков сохраняются: i = ',i,
                                                               ' и j = ',j);

  // Цикл с предусловием
  i:=12;
  while i<90 do
    begin // Удваиваем число если оно меньше 90
      i:=i*2;
      write(i,' ');
    end;  writeln(' Цикл с предусловием окончен.');

  // Цикл с постусловием
  repeat
    i := i div 3; // Можно использовать несколько операторов без заключения
    write(i,' '); // их в блок begin-end
  until i<10; // Уменьшаем число в 3 раза пока не преодолеем порог меньше 10
  writeln(' Цикл с постусловием окончен.');

  // Перерывание работы цикла
  repeat
    inc(i);
    if i mod 2 = 0 then continue; // Переход на следующую итерацию
    if i>30 then break; // Выход из цикла
    write(i,' ');
  until false; { При таком условии цикл будет повторяться вечно,
                 если его не прервать }
  writeln(' Вечный цикл окончен.');

  {$ifndef debug}
  write('Введите строку текста:');
  readln(str1); { Процедура READLN считывает введённый текст в переменную.
    Для надёжности лучше использовать переменную строкового типа,
    потому как если в численную переменную пользователь по невнимательности
    введёт буквы, то программа зависнет. }
  writeln(str1);
  {$endif}

end;

{
letter1:='q'; // 'Ψ';
writeln(letter1);
wideletter1:='q'; // 'Ψ';
writeln(wideletter1);



shortstr1 := 'абвгдеёзжиклмнопрстуфхцчшщэюя';
shortstr2 := 'абвгдеёзжиклмнопрстуфхцчшщэюя';  // Строка будет обрезана до 10 символов
ansistr1 := 'Строка ANSI Ψ';   // Строка-ANSI неограниченного размера
widestr1 := 'Строка в двухбайтной кодировке  UTF-16';
unistr1 := 'Строка - Unicodestring';
rawstr1 := 'Строка без указания кодировки Ψ';
zerostr1 := 'Строка - массив символов Char Ψ';

// DefaultSystemCodePage := 60051;
//SetConsoleOutputCP(CP_UTF8);
//SetConsoleOutputCP(CP_UTF16);

writeln(shortstr1);
writeln(shortstr2);
writeln(ansistr1);
writeln(widestr1);
writeln(unistr1);
writeln(rawstr1);
writeln(zerostr1);

writeln('Проверка!!!');

writeln(UTF8ToConsole('Проверка!!!'));
writeln(UTF8ToConsole(shortstr1));
writeln(UTF8ToConsole(shortstr2));
writeln(UTF8ToConsole(ansistr1));
writeln(UTF8ToConsole(widestr1));
writeln(UTF8ToConsole(unistr1));
writeln(UTF8ToConsole(rawstr1));
writeln(UTF8ToConsole(zerostr1));


writeln('Текущая кодовая страница - ',DefaultSystemCodePage);
}

writeln('На этом всё. Жмите ENTER для выхода.');
readln;

END. { После последнего end ставится точка, а не точка с запятой.}

