// Однострочный комментарий до конца строки задается двумя косыми чертами в начале комментария
{ Многострочный комментарий - обрамляется фигурными скобками.
  Этот файл сохранен в кодировке DOS-866. Для корректного открытия в Lazarus IDE следует в окне
  редактора кода выбрать Правой кнопкой мыши Параметры файла->Кодировка->CP866.
  ( ▌ЄюЄ Їрщы ёюїЁрэхэ т ъюфшЁютъх DOS-866. ─ы  ъюЁЁхъЄэюую юЄъЁ√Єш  т Lazarus IDE ёыхфєхЄ
    т юъэх ЁхфръЄюЁр ъюфр т√сЁрЄ№ ╧рЁрьхЄЁ√ Їрщыр->╩юфшЁютър->CP866.)
}

{$mode objfpc} //Специальная директива - включает режим совместимости с Object Pascal

program DemoProject; // Главный программный файл начинается ключевым словом PROGRAM
uses Crt, windows, Math;    // Подключение внешних модулей

{ РАБОТА С ПЕРЕМЕННЫМИ }
// Объявление имён и типов переменных.
  { Имя переменной должно начинаться с латинской буквы или символа подчеркивания,
    может также содержать цифры. Длина имени от 1 до 127 символов.
    Написание не чувствительно к регистру.
  }
const { Объявление имён неизменяемых переменных (констант). Производится
        до начала исполняемого блока. Константе автоматически присваивается
        "минимальный" тип данных, достаточный для её представления.}
    PI = 3.14;      // Для удобства имена констант пишут заглавными буквами,
    Hi = 'Привет';  // но строчными тоже допустимо
    realnumb:Double = 789; // Т.н. типизированная константа, которая по сути является
                           // статической переменной (её можно менять по ходу программы).
                           // Её тип задаётся через двоеточие

var  // Объявление имён изменяемых переменных. Производится до начала исполняемого блока.
    // Целые числа
    numb_1b : Shortint; // 1 байт  (        -128 .. 127        )
    numb_2b : Smallint; // 2 байта (      -32768 .. 32767      ) синоним Integer на 32-битных платформах
    numb_4b : Longint;  // 4 байта ( -2147483648 .. 2147483647 ) синоним Integer на 64-битных платформах
    numb_1b_p : Byte;   // 1 байт без знака  ( 0 .. 255   )
    numb_2b_p : Word;   // 2 байта без знака ( 0 .. 65535 )
    numb_4b_p : LongWord; // 4 байта без знака ( 0 .. 4294967295 ) синоним Cardinal
    numb_8b_p : QWord;    // 8 байт без знака  ( 0 .. 18446744073709551615 )

    // Вещественные числа с плавающей точкой
    rnumb_4b : Single;    // 4 байта ( 2,9*10^-39   .. 1,7*10^38   )
    rnumb_6b : Real;      // 6 байт  ( 1,5*10^-45   .. 3,4*10^38   )
    rnumb_8b : Double;    // 8 байт  ( 5,0*10^-324  .. 1,7*10^308  )
    rnumb_10b : Extended; // от 4, 8 или 10 байт ( 3,4*10^-4932 .. 1,1*10^4932 )
    // Вещественные числа с фиксированной точкой
    rnumb_8bf : Currency; // 8 байт ( -922337203685477.5808 .. 922337203685477.5807 ) -

    // Логические типы
    bool1, bool2 : Boolean; // Занимает 1 байт. Принимает значения true или false
    bool_1b : ByteBool; // Натуральное число 1 байт. 0 = false
    bool_2b : ByteBool; // Натуральное число 2 байта
    bool_4b : ByteBool; // Натуральное число 4 байта

    // Символьный тип
    letter1 : char;  // 1 байт. Все символы кодировки ASCII
    // Строка
    str1 : string; // Строка (одномерный массив из символов)

    i, j, factorial1 :integer;

    {ОБЪЯВЛЕНИЕ СОСТАВНЫХ НАБОРОВ ДАННЫХ}
    // Массив (набор фиксированной длины из элементов одного типа)
    arr1 : array [1..100] of integer; // Нумерация элементов может начинаться
                                      // не с нуля,а с любого целого числа.
    arr3d : array [1941..1945,1..12,1..31] of integer; { Трёхмерный массив - для
    хранения значений в ячейках с индексами указывающими на год, месяц, число.}

  label mimimi;  // Объявление метки с именем mimimi (для безусловного перехода)

BEGIN // Коммандой begin обозначается начало логического блока

begin { КОММАНДЫ ВЗАИМОДЕЙСТВИЯ С ПОЛЬЗОВАТЕЛЕМ }
  // Вывод текстовых строк
  write('Hello world!');   // Вывод строки в консоль без перевода строки
  writeln('Hello world!'); // и с переводом строки
  // Пауза работы
  {
  sleep(3000); // Пауза на 3000 мс. Требует uses windows
  // Ожидание нажатия любой клавиши. Требует uses Crt:
  writeln('Нажмите любую клавишу:'); readkey;
  // Ожидание нажатия клавиши ENTER (ввода строки)
  write('Нажмите ENTER:'); readln;
  }
end;

begin { РАБОТА С ПЕРЕМЕННЫМИ }
// Инициализация переменных
  numb_4b := 1234567890;     // Непроинициализированная переменная обычно хранит значение 0
  numb_1b := 12345;          // Число больше допустимого 127, поэтому сохранится
                             // неправильное значение (обрезанное до 8 бит)
  rnumb_4b := 12345.456789;  // В качестве разделителя используется точка
  rnumb_4b := 456.789;       // Проинициализированную переменную можно перезаписать новым значением

  numb_2b := $F57D;          // Шестнадцатеричное число начинается с символа $
  numb_2b := &4651;          // Восьмеричное число начинается с символа &
  numb_2b := %10011110;      // Двоичное число начинается с символа %

  bool1:=true; bool2:=false; // Непроинициализированная переменная хранит значение FALSE
  letter1 := 'Ф';            // Непроинициализированная переменная хранит значение 'a'
  str1 := 'Тестовая строка'; // Непроинициализированная переменная хранит значение ''

// Использование переменных

  numb_2b := numb_1b;
  write(rnumb_6b);
  writeln(' ',letter1,str1,bool2); // В функции вывода можно перечислять
                                   // выводимые аргументы через запятую.
  rnumb_4b := rnumb_4b / numb_4b;  // В выражениях для присвоения нового значения
  // можно использовать эту же переменную, пока в ней хранится старое значение.
//  write(rnumb_8b * 100);
end;

begin { ОПЕРАЦИИ }
  numb_1b := ( 7 + 2 - 3 ) * 4; // Сложение вычитание умножение для любых типов чисел.
  numb_1b_p := 1 - numb_1b; { Результирующее значение не проверяется на предмет
                              попадания в допустимый диапазон: }
  writeln('В переменной типа BYTE отрицательное значение ', 1 - numb_1b,
                                       ' сохранилось как ', numb_1b_p);
  numb_2b := 2147483647 + 2;
  writeln('В переменной типа INTEGER 33-битное значение ', 2147483647 + 2,
                                      ' сохранилось как ', numb_2b);

  numb_2b := 31 div 8; // Целочисленное деление
  numb_2b := 31 mod 8; // Остаток от деления
  rnumb_6b := 31 / 8;  // Вещественное деление

  numb_4b := sqr(3); { Квадрат числа. Для целых чисел результат функции SQR
                       можно сохранить в т.ч. в целочисленную переменную.}
  numb_4b := 3**5; { Возведение в произвольную степень. Если операнды целочисленные,
                     то результат можно сохранить в целочисленную переменную.}
  rnumb_8b := power(2,3);   { Аналогичная функция POWER даже для целых
                              чисел возвращает вещественный результат.}
  rnumb_8b := 2**3.5;       // Возведение в дробную степень
  rnumb_8b := power(2,3.5);

  { Унарные операторы }
  i := - numb_4b; // Унарный оператор смены знака.
  i := not i; { Побитовая инверсия - вычитание из -1. Т.е. смена знака
           и одновременный декремент. Полезна в связке с операцией смены знака.}
  i := -not i; // Инкремент. Унарный аналог i+1
  i := not- i; // Декремент. Унарный аналог i-1
  i := -not 2 * 6; { Результат равен 18, а не 13, поскольку у унарных операций
                     приоритет выше чем у операций умножения и деления.}

  { Комбинированные операторы }
  numb_4b += 5; numb_4b -= 5;  // Увеличить или уменьшить переменную на указанное число.
  numb_4b *= 3; rnumb_8b /= 3; // Умножить или поделить переменную на указанное число.

  { Битовые операции}
  inc(i); dec(i); // Функции увеличения и уменьшения значения переменной на 1 бит
  i := i << 3; i := i shl 2; { Побитовый сдвиг влево на указанное число бит
                             с сохранением знака (умножение на степень двойки )}
  i := i >> 2; i := i shr 3; { Побитовый сдвиг вправо на указанное число бит
                             с сохранением знака (деление на степень двойки)}
  i := i and 5; { Побитовое И (AND).
                  Используется для установки в нужные биты значения 0 }
  i := i or 5;  { Побитовое ИЛИ (OR).
                  Используется для установки в нужные биты значения 1 }
  i := i xor 5; { Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR).
                Используется для смены значений нужных битов на противоположные}

  { Операторы сравнения и логические операторы }
  bool1 := 2 = 2;       // Равенство
  bool1 := 2 <> 3;      // Неравенство
  bool1 := not bool1;   // Отрицание
  bool1 := (1 >= 1) and (2 > 1); // Логическое "И" (конъюнкция)
  bool1 := (1 <= 1) or (2 < 1);  // Логическое "ИЛИ" (дизъюнкция)
  bool1 := (1 <= 1) xor (2 < 1); // Логическое "ЛИБО" (исключение)
end;

{ ИНИЦИАЛИЗАЦИЯ И ИСПОЛЬЗОВАНИЕ СОСТАВНЫХ НАБОРОВ ДАННЫХ }
  arr1[5] := 73; // Запись в массив значения - в ячейку с индексом 5.
  arr1[6] := arr1[5] + 2; // Элемент массива можно использовать как обычную переменную.
  arr3d[1943,7,23] := 398; // Запись значения в многомерный массив.

begin { ОРГАНИЗАЦИЯ ВЕТВЛЕНИЙ В ЛОГИКЕ ПРОГРАММЫ }

  // Условие с одной ветвью
    if bool1 then str1:='Yes';
    // Запись в несколько строк:
    if not bool1 then
      begin
        str1:='No';
      end;
  // Условие с двумя ветвями
    if bool1 then str1:='Yes'
      // Перед ключевым словом ELSE точка с запятой не ставится:
      else str1:='No';
      // Запись в несколько строк:
    if bool1 then
      begin
        str1:='Yes';
      end
    else
      begin
        str1:='No';
      end;

  // Множественный выбор между несколькими условиями:
    case numb_4b of    // Значение переменной далее сравнивается с образцами:
      0        : j:=0; { Можно указать конкретное значение при совпадении
                         с которым выполняются операции после двоеточия. }
      1..100   : j:=2; // Можно указать диаппазон значений.
      647, 729 : j:=3; // Можно указать несколько значений через запятую.
      else j:=-1;      { Значение по умолчанию, если совпадений не найдено.
                         Эта строка не обязательна.}
    end;

{ БЕЗУСЛОВНЫЕ УПРАВЛЯЮЩИЕ КОММАНДЫ }
  goto mimimi; // Переход к метке с именем mimimi
    writeln('Этот оператор будет пропущен');
  mimimi:  // Имя метки, после которой должно быть двоеточие
end;

begin { ЦИКЛЫ }
  // Цикл со счётчиком
  for i:=1 to 9 do write(i); { На каждой итерации счётчик увеличивается на 1.
  Уменьшаться счётчик не может, поэтому ставить вторую цифру меньшей нет смысла}
  writeln;

  factorial1 := 1;
  for i:=2 to 5 do // Если в теле цикла несколько операторов,
    begin          // то они заключаются в логический блок BEGIN-END
      factorial1 := factorial1 * i;
      writeln (i,'! = ',factorial1,'; ');
    end;

  // Вложенный цикл со счётчиком
  writeln('Таблица сложения:');
  for i:=1 to 5 do
    begin
      for j:=1 to 5 do
        write(i+j,' ');
      writeln;
    end;
  writeln('После выполнения циклов значения счётчиков сохраняются: i = ',i,
                                                               ' и j = ',j);

  // Цикл с предусловием
  i:=12;
  while i<90 do
    begin // Удваиваем число если оно меньше 90
      i:=i*2;
      write(i,' ');
    end;  writeln(' Цикл с предусловием окончен.');

  // Цикл с постусловием
  repeat
    i := i div 3; // Можно использовать несколько операторов без заключения
    write(i,' '); // их в блок begin-end
  until i<10; // Уменьшаем число в 3 раза пока не преодолеем порог меньше 10
  writeln(' Цикл с постусловием окончен.');

  // Перерывание работы цикла
  repeat
    inc(i);
    if i mod 2 = 0 then continue; // Переход на следующую итерацию
    if i>30 then break; // Выход из цикла
    write(i,' ');
  until false; { При таком условии цикл будет повторяться вечно,
                 если его не прервать }
  writeln(' Вечный цикл окончен.');

  write('Введите строку текста:');
  readln(str1); { Процедура READLN считывает введённый текст в переменную.
    Для надёжности лучше использовать переменную строкового типа,
    потому как если в численную переменную пользователь по невнимательности
    введёт буквы, то программа зависнет. }
  writeln(str1);

  REALNUMB:=70000;
  writeln('REALNUM =', REALNUMB);
  readkey;
end;
END. { Коммандой end обозначается конец логического блока.
       После последнего end ставится точка, а не точка с запятой.}



