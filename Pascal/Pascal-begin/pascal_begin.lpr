// Однострочный комментарий до конца строки задается двумя косыми чертами в начале комментария
{ Многострочный комментарий - обрамляется
  фигурными скобками. }

// Наиболее важные специальные директивы компилятора:

{$mode objfpc} // Эта директива - включает режим совместимости с Object Pascal
{$H+} // Строкой по умолчанию является строка типа AnsiString неограниченной длины
{$J-} // Выключает возможность изменения типизированных констант
{$codepage UTF8} // Принуждает компилятор FPC работать в кодировке UTF8

// Дополнительные директивы

program DemoProject; // Главный программный файл начинается ключевым словом PROGRAM
uses sysutils, Math, // Подключение внешних модулей
  {$ifdef unix}    cwstring,   {$endif}
  {$ifdef windows} windows,    {$endif}

    LazUTF8; // Модуль для корректной работы проектов в кодировке UTF8
  // Если этот модуль автоматически не подключается, то нужно в IDE зайти в меню:
  // Проект -> Инспектор проекта -> Правый клик по Требуемые пакеты -> Добавить ->
  // ищем в имя пакета LazUtils -> OK


{ РАБОТА С ПЕРЕМЕННЫМИ }
// Объявление имён и типов переменных.
  { Имя переменной должно начинаться с латинской буквы или символа подчеркивания,
    может также содержать цифры. Длина имени от 1 до 127 символов.
    Написание не чувствительно к регистру.
  }
const { Объявление имён неизменяемых переменных (констант). Производится
        до начала исполняемого блока. Константе автоматически присваивается
        "минимальный" тип данных, достаточный для её представления.}
    NUMB_PI = 3.14;     // Для удобства имена констант пишут заглавными буквами,
    Str_Hi = 'Привет';  // но строчными тоже допустимо

    {$J+}
    REALNUMB:Double = 789; { При включенной директиве {$J+} можно создавать т.н. типизированные
       константы, которые по сути являются статическими переменными (т.е. их можно менять по ходу
       программы). Тип таких констант задаётся через двоеточие. }
    {$J-}

var // Объявление имён изменяемых переменных. Производится до начала исполняемого блока.
    // Целые числа
    numb_1b : Shortint; // 1 байт  (        -128 .. 127        )
    numb_2b : Smallint; // 2 байта (      -32768 .. 32767      ) синоним Integer на 32-битных платформах
    numb_4b : Longint;  // 4 байта ( -2147483648 .. 2147483647 ) синоним Integer на 64-битных платформах
    numb_1b_p : Byte;   // 1 байт без знака  ( 0 .. 255   )
    numb_2b_p : Word;   // 2 байта без знака ( 0 .. 65535 )
    numb_4b_p : DWord; // 4 байта без знака ( 0 .. 4294967295 ) синоним Cardinal и LongWord
    numb_8b_p : QWord;    // 8 байт без знака  ( 0 .. 18446744073709551615 )

    // Вещественные числа с плавающей точкой
    rnumb_4b : Single;    // 4 байта ( 2,9*10^-39   .. 1,7*10^38   )
    rnumb_6b : Real;      // 6 байт  ( 1,5*10^-45   .. 3,4*10^38   )
    rnumb_8b : Double;    // 8 байт  ( 5,0*10^-324  .. 1,7*10^308  )
    rnumb_10b : Extended; // от 4, 8 или 10 байт ( 3,4*10^-4932 .. 1,1*10^4932 )
    // Вещественные числа с фиксированной точкой
    rnumb_8bf : Currency; // 8 байт ( -922337203685477.5808 .. 922337203685477.5807 ) -

    // Логические типы
    bool1, bool2 : Boolean; // Занимает 1 байт. Принимает значения true или false

    v1 : Variant;   // Вариативная переменная может принимать значения любого значимого типа:

    // Символьный тип
    letter1 : char;  // 1 байт. Все символы кодировки ASCII
    // Строка
    str1 : string; // Строка (одномерный массив из символов) в текущей кодировке компилятора

    i, j, factorial1 :integer;

    arr1 : array [1..100] of integer; // Нумерация элементов может начинаться
                                      // не с нуля,а с любого целого числа.
    arr3d : array [1941..1945,1..12,1..31] of integer; { Трёхмерный массив - для
    хранения значений в ячейках с индексами указывающими на год, месяц, число.}

  label mimimi;  // Объявление метки с именем mimimi (для безусловного перехода)

BEGIN // Коммандами begin и end; обозначается начало и конец логического блока

begin { КОММАНДЫ ВЗАИМОДЕЙСТВИЯ С ПОЛЬЗОВАТЕЛЕМ }
  // Вывод текстовых строк
  write('Hello world!');   // Вывод строки в консоль без перевода строки
  writeln('Hello world!'); // и с переводом строки
  // Вывод чисел с выравниванием по правому краю
  writeln(123:6);    // (целое число : кол-во знаков)
  writeln(2.5:10:2); // (вещественное число : общее кол-во знаков : кол-во знаков после запятой)

  // Пауза работы
  {
  sleep(3000); // Пауза на 3000 мс. Требует uses windows
  // Ожидание нажатия любой клавиши. Требует uses Crt:
  writeln('Нажмите любую клавишу:'); readkey;
  // Ожидание нажатия клавиши ENTER (ввода строки)
  write('Нажмите ENTER:'); readln;
  }
end;

begin { РАБОТА С ПЕРЕМЕННЫМИ }
// Инициализация переменных
  numb_4b := 1234567890;     // Непроинициализированная переменная обычно хранит значение 0
  numb_1b := 12345;          // Число больше допустимого 127, поэтому сохранится
                             // неправильное значение (обрезанное до 8 бит)
  rnumb_4b := 12345.456789;  // В качестве разделителя используется точка
  rnumb_4b := 456.789;       // Проинициализированную переменную можно перезаписать новым значением

  numb_2b := $F57;           // Шестнадцатеричное число начинается с символа $
  numb_2b := &4651;          // Восьмеричное число начинается с символа &
  numb_2b := %10011110;      // Двоичное число начинается с символа %

  bool1:=true; bool2:=false; // Непроинициализированная переменная хранит значение FALSE
  letter1 := 'W';            // Непроинициализированная переменная хранит значение 'a'
  letter1 := #75;            // Символ с ASCII-кодом 75

  str1 := 'Тестовая строка';  // Непроинициализированная переменная хранит пустую сроку
  writeln(str1);
  str1 := 'граф д''Артаньян'; // Одинарную кавычку можно сохранить в строке, написав её дважды
  writeln(str1);
  str1 := 'граф д' + #39 + 'Артаньян';  // либо указав ASCII-код 39
  writeln(str1);
  str1 := 'Первая строка' + LineEnding  + 'Вторая строка'; // Перенос строки в стандарте текущей ОС
  writeln(str1);
  str1 := #13#10;  // Символы Carriage Return (возврат каретки) и Line feed (перенос строки)
  str1 := #9#8#12; // Символы  Tab | Backspace | Form feed (новая страница)

  // Вариативная переменная может принимать значения любого значимого типа:
  v1 := 78;
  v1 := 'строка'; v1 := TRUE;

// Использование констант и переменных

  numb_2b := numb_1b;
  writeln(numb_2b);
  writeln(' ',letter1,str1,bool2); // В функции вывода можно перечислять
                                   // выводимые аргументы через запятую.
  rnumb_4b := rnumb_4b / numb_4b;  // В выражениях для присвоения нового значения
  // можно использовать эту же переменную, пока в ней хранится старое значение.
end;

begin { ОПЕРАЦИИ }
  { Арифметические операторы }
    numb_1b := ( 7 + 2 - 3 ) * 4; // Сложение вычитание умножение для любых типов чисел.
    numb_1b_p := 1 - numb_1b; { Результирующее значение не проверяется на предмет
                                попадания в допустимый диапазон: }
    writeln('В переменной типа BYTE отрицательное значение ', 1 - numb_1b,
                                         ' сохранилось как ', numb_1b_p);
    numb_4b := 2147483647;
    numb_4b := numb_4b  + 2; // Пример арифметического переполнения
    writeln('В переменной типа Longint 33-битное значение ', 2147483647 + 2,
                                        ' сохранилось как ', numb_4b);

    {$Q+} // Эта директива компилятора включает режим проверки арифметического переполнения
    {$Q-} // Выключение режима проверки переполнения (значение по умолчанию)

    numb_4b := 2147483647;
    numb_4b := numb_4b  + 2;  // На этой строке при директиве {$Q+} программа остановится с ошибкой

    numb_2b := 31 div 8; // Целочисленное деление
    numb_2b := 31 mod 8; // Остаток от деления
    rnumb_6b := 31 / 8;  // Вещественное деление

    numb_4b := sqr(3); { Квадрат числа. Для целых чисел результат функции SQR
                         можно сохранить в т.ч. в целочисленную переменную.}
    numb_4b := 3**5; { Возведение в произвольную степень. Если операнды целочисленные,
                       то результат можно сохранить в целочисленную переменную.}
    rnumb_8b := power(2,3);   { Аналогичная функция POWER даже для целых
                                чисел возвращает вещественный результат.}
    rnumb_8b := 2**3.5;       // Возведение в дробную степень
    rnumb_8b := power(2,3.5);

    rnumb_10b := sqrt(9); // Корень квадратный из числа
    // Для вычисления корня можно использовать возведение в дробную степень:
    rnumb_8b := power(9, 1/2); // = 3

  { Унарные операторы }
    i := - numb_4b; // Унарный оператор смены знака.
    i := not i; { Побитовая инверсия - вычитание из -1. Т.е. смена знака
             и одновременный декремент. Полезна в связке с операцией смены знака.}
    i := -not i; // Инкремент. Унарный аналог i+1
    i := not- i; // Декремент. Унарный аналог i-1
    i := -not 2 * 6; { Результат равен 18, а не 13, поскольку у унарных операций
                       приоритет выше чем у операций умножения и деления.}

  { Комбинированные операторы }
    numb_4b += 5; numb_4b -= 5;  // Увеличить или уменьшить переменную на указанное число.
    numb_4b *= 3; rnumb_8b /= 3; // Умножить или поделить переменную на указанное число.

  { Битовые операции}
    inc(i); dec(i); // Функции увеличения и уменьшения значения переменной на 1 бит
    i := i << 3; i := i shl 2; { Побитовый сдвиг влево на указанное число бит
                               с сохранением знака (умножение на степень двойки )}
    i := i >> 2; i := i shr 3; { Побитовый сдвиг вправо на указанное число бит
                               с сохранением знака (деление на степень двойки)}
    i := i and 5; { Побитовое И (AND).
                    Используется для установки в нужные биты значения 0 }
    i := i or 5;  { Побитовое ИЛИ (OR).
                    Используется для установки в нужные биты значения 1 }
    i := i xor 5; { Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR).
                  Используется для смены значений нужных битов на противоположные}
  { Конкатенация строк }
    str1 := 'строка1' + 'строка2';

  { Операторы сравнения и логические операторы }
    // Во всех нижепреведенных сравнениях результат равен TRUE
    bool1 := (2 = 2)               and  // Равенство
             (2 <> 3)              and  // Неравенство
             (bool1 <> not bool1)  and  // Отрицание
             (1 >= 1) and (2 > 1)  and  // Логическое "И" (конъюнкция)
             (1 <= 1) or (2 < 1)   and  // Логическое "ИЛИ" (дизъюнкция)
            ((1 <= 1) xor (2 < 1)) and  // Логическое "ЛИБО" (исключение)
             ('Строка 2' > 'Строка 1'); // Строки сравниваются побуквенно
    writeln('Результат всех сравнений и логических операций: ',bool1);  // TRUE

end;

begin { ПРИВЕДЕНИЕ ПРОСТЫХ ТИПОВ ПРИ ОПЕРАЦИЯХ }
  { Автоматическое строковое преобразование }
    letter1 := '2';
    str1 := 'Строка1' + letter1; // Символьный тип Char автоматически приводится к строке

  { Явное строковое преобразование }
    // Эти функции требуют uses sysutils
    str1 := intToStr(17);    // Преобразование целого числа в строку
    str1 := floatToStr(2.5); // Преобразование вещественного числа в строку
    WriteStr(str1,'2+2 = ', 2+2); // Аналог функции write - сохраняет результат в строку str1
    writeln(str1);

    ThousandSeparator := ' ';
    str1 := FloatToStrF(12345.5,ffNumber,2,2);
    writeln('Отформатированное число: ',str1);
    // Приведение числа к строке в разных системах счисления (второй параметр - число знаков)

    HexStr(175,10); // Шестнадцатеричное представление
    BinStr(175,10); // Двоичное представление
    OctStr(175,10); // Восьмиричное представление

    { Автоматическое численное преобразование }
    rnumb_4b := numb_1b; // Целые числа автоматически приводятся к вещественным
    numb_1b := numb_4b;  // При сохранении в тип меньшей разрядности биты обрезаются
                         // Директива {$Q+} это не считает переполнением и ошибку не выдаёт

    writeln('Число ',numb_4b,' хранилось в 4-х байтах. При сохранении в 1 байт стало = ',numb_1b);


end;

begin{ ИНИЦИАЛИЗАЦИЯ И ИСПОЛЬЗОВАНИЕ СОСТАВНЫХ НАБОРОВ ДАННЫХ }
  arr1[5] := 73; // Запись в массив значения - в ячейку с индексом 5.
  arr1[6] := arr1[5] + 2; // Элемент массива можно использовать как обычную переменную.
  arr3d[1943,7,23] := 398; // Запись значения в многомерный массив.
end;

begin { ОРГАНИЗАЦИЯ ВЕТВЛЕНИЙ В ЛОГИКЕ ПРОГРАММЫ }

  { Условие с одной ветвью }
    if bool1 then str1:='Yes';
    // Запись в несколько строк:
    if not bool1 then
      begin
        str1:='No';
      end;

  { Условие с двумя ветвями }
    if bool1 then str1:='Yes'
      // Перед ключевым словом ELSE точка с запятой не ставится:
      else str1:='No';
      // Запись в несколько строк:
    if bool1 then
      begin
        str1:='Yes';
      end
    else
      begin
        str1:='No';
      end;

  { Множественный выбор между несколькими условиями }
    case numb_4b of    // Значение переменной далее сравнивается с образцами:
      0        : j:=0; { Можно указать конкретное значение при совпадении
                         с которым выполняются операции после двоеточия. }
      1..100   : j:=2; // Можно указать диаппазон значений.
      647, 729 : j:=3; // Можно указать несколько значений через запятую.
      else j:=-1;      { Значение по умолчанию, если совпадений не найдено.
                         Эта строка не обязательна.}
    end;

{ БЕЗУСЛОВНЫЕ УПРАВЛЯЮЩИЕ КОММАНДЫ }
  goto mimimi; // Переход к метке с именем mimimi
    writeln('Этот оператор будет пропущен');
  mimimi:  // Имя метки, после которой должно быть двоеточие
end;

begin { ЦИКЛЫ }
  // Цикл со счётчиком
  for i:=1 to 9 do write(i); { На каждой итерации счётчик увеличивается на 1.
  Уменьшаться счётчик не может, поэтому ставить вторую цифру меньшей нет смысла}
  writeln;

  factorial1 := 1;
  for i:=2 to 5 do // Если в теле цикла несколько операторов,
    begin          // то они заключаются в логический блок BEGIN-END
      factorial1 := factorial1 * i;
      writeln (i,'! = ',factorial1,'; ');
    end;

  // Вложенный цикл со счётчиком
  writeln('Таблица сложения:');
  for i:=1 to 5 do
    begin
      for j:=1 to 5 do
        write(i+j,' ');
      writeln;
    end;
  writeln('После выполнения циклов значения счётчиков сохраняются: i = ',i,
                                                               ' и j = ',j);

  // Цикл с предусловием
  i:=12;
  while i<90 do
    begin // Удваиваем число если оно меньше 90
      i:=i*2;
      write(i,' ');
    end;  writeln(' Цикл с предусловием окончен.');

  // Цикл с постусловием
  repeat
    i := i div 3; // Можно использовать несколько операторов без заключения
    write(i,' '); // их в блок begin-end
  until i<10; // Уменьшаем число в 3 раза пока не преодолеем порог меньше 10
  writeln(' Цикл с постусловием окончен.');

  // Перерывание работы цикла
  repeat
    inc(i);
    if i mod 2 = 0 then continue; // Переход на следующую итерацию
    if i>30 then break; // Выход из цикла
    write(i,' ');
  until false; { При таком условии цикл будет повторяться вечно,
                 если его не прервать }
  writeln(' Вечный цикл окончен.');

  write('Введите строку текста:');
  readln(str1); { Процедура READLN считывает введённый текст в переменную.
    Для надёжности лучше использовать переменную строкового типа,
    потому как если в численную переменную пользователь по невнимательности
    введёт буквы, то программа зависнет. }
  writeln(str1);

end;

writeln('На этом всё. Жмите ENTER для выхода.');
readln;

END. { После последнего end ставится точка, а не точка с запятой.}

