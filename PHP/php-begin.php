<!DOCTYPE HTML> <html><head><meta charset="utf-8"></head><body>
<!-- Откройте этот файл в Notepad++ чтобы свернуть блоки в удобное меню простой комбинацией клавиш:
	 (Alt + 4) - свернуть и (Alt + Shift + 0)  - развернуть.
	 То же самое можно сделать в Visual Studio Code:
	 (Ctrl + K) + (Ctrl + 2) - свернуть, (Ctrl + K) + (Ctrl + J) - развернуть
	 -->

<div>
<h1>ОСНОВЫ РАБОТЫ С ЯЗЫКОМ ПРОГРАММИРОВАНИЯ PHP</h1>
    
<div> <h2> ОБЩИЕ СИНТАКСИЧЕСКИЕ ПРАВИЛА </h2>
	<p> При классическом использовании PHP-код встраивается фрагментарно в содержимое HTML-файла, 
	     добавляя необходимую функциональность на страницу. В этом документе объясняется только 
		 синтаксис PHP (подразумевая что читатель уже знает синтаксис HTML). </p>
	
	<!-- Фрагменты PHP-кода добавляются в HTML-документ путём заключения этого кода внутри тега:
		 <?php   ?>
	-->
	
	<?php // Однострочный комментарий до конца строки задается двумя слэшами в начале комментария
		  #  Однострочный комментарий в стиле UNIX Задаётся символом # в начале строки
		  /*  Многострочный комментарий - обрамляется парой символов "/" и "*" 
			  В начале комментария символы / и * идут в прямом порядке, а в конце - в обратном.
				https://www.php.net/manual/ru/language.basic-syntax.comments.php
		  */
	?>
		
	<?php  /* Это открывающий тег, который  сообщает интерпретатору, 
				что текст внутри тега является php-кодом, который нужно выполнять.
	
	?>  // Это закрывающий тег. Он не действует внутри многострочного комментария, и наоборот, */
		// срабатывает внутри однострочного комментария, действуя аналогично концу строки:  ?> 
	
	<p>Текст вне php-тегов выводится браузером как обычный html-код.</p>
	
	<p> Рекомендуется не ставить закрывающий тег ?> в самом конце файла, чтобы иметь возможность 
			импортировать внешние скрипты и не иметь проблем с выводом в html-документ 
			невидимых символов	после закрывающего тега ?> </p>
	
	<p> Команды в PHP разделяются символом точки с запятой ";"
		 Cимвол ";" можно не писать перед закрывающим тегом ?> </p>

	<p> Блок операторов выделяется фигурными скобками {}
         Отключить выполнение кода можно поместив его внутрь блока if(0){  } </p>
	
		<?php  // В коде не должно быть ошибок. Для включения нужно 0 заменить на 1 :
			if(0){ echo "Невыполняющийся код"; } 
		?>
	<!-- Если PHP-код перемежается с HTML, то HTML-код в невыполняющемся блоке игнорируется: -->
		<?php if(0){ ?> 
			Этот HTML-текст не будет выведен на страницу. 
		<?php } ?>
		
  </div>
</div>

<div> <h2> КОМАНДЫ ВЗАИМОДЕЙСТВИЯ С ПОЛЬЗОВАТЕЛЕМ </h2>	
	 
  <div>    <h3> ВЫВОД ТЕКСТОВЫХ СТРОК </h3>
  	  <!-- Языковая конструкция echo выводит html-текст в текущее место веб-страницы
		   https://www.php.net/manual/ru/function.echo.php -->
	  <?php echo "Hello World!" ?>
	  <?= "Hello World!" ?>  <!-- Этот сокращённый вызов echo делает то же самое -->
	  <?php 
		echo "<br>HTML <b>работает!!!</b>"; // html-теги при этом обрабатываются
		echo "<br>","А", "Б", "В";          // Строки указанные через запятую - соединяются
		echo "<br> Дважды два ", 2*2;       // При выводе можно использовать выражения.
		echo "<br> Строка 1
		           Строка 2 ";              // Перенос строки тоже выводится.
	    echo("Строка 3");  // Можно вызов сделать как функцию, но на самом деле это не функция
				
		/* Языковая конструкция print выводит html-текст в текущее место веб-страницы,
		   возвращая при этом значение 1
		   https://www.php.net/manual/ru/function.print.php */
		
		print "<br>Вывод строки print";     // Допустимо использовать только один аргумент
		echo print "<br> Вызов print возвращает значение ";  // 1
		print("<br>"); // Можно сделать вызов как функцию, при этом print 
	  ?>
  </div> 
  
  <div>    <h3> ВВОД ДАННЫХ ЧЕРЕЗ GET/POST ЗАПРОСЫ </h3>
	    
	<!-- Самый простой способ ввести данные, которые сможет прочитать php-скрипт - это
	         добавить к URL-строке текст со значением переменной  в формате:
		  ?var1="demotext"  (<имя переменной>=<значение> ) 
	   -->
	<a href="?var1=demotext"> Нажмите эту ссылку для отправки значения переменной через URL </a><br>
	    <?php // Значение можно прочитать в глобальном ассоциативном массиве $_GET
			if (isset($_GET['var1'])) {   // Проверяется существование значения с ключом "var1"
				echo "Через URL передано значение для var1: ";
				echo htmlspecialchars($_GET['var1']); }
		?> <!-- В целях безопасности при выводе переменной применяется функция htmlspecialchars -->
	
	<!-- То же самое можно сделать путём заполнения формы и её отправки GET-запросом -->
		<form action="" method="get">
			Введите значение для var2: <input type="text" name="var2" /><input type="submit" />
		</form>	  
	
	    <?php if (isset($_GET['var2'])) {  
			echo "Через GET-запрос передано значение для var2: ";
			echo htmlspecialchars($_GET['var2']); }   
		?>	 
		
	<!-- Аналогичная передача POST-запросом позволяет оставить URL неизменным  -->
		<form action="" method="post">
			Введите значение для var3: <input type="text" name="var3" /> <input type="submit" />
		</form>	  
	
	    <?php // Для POST запросов используется аналогичный массив $_POST
			if (isset($_POST['var3'])) {
				echo "Через POST-запрос передано значение для var3: ";
				echo htmlspecialchars($_POST['var3']); }  
		?>	 
		
  </div>

  <div>    <h3> ПАУЗА ВЫПОЛНЕНИЯ СКРИПТА </h3>
	  <?php   	  
		sleep(1);       // Пауза в 1 секунду;  Эта функция возвращает 0 при успешном выполнении
		usleep(500000); // Пауза в полсекунды (в микросекундах);  Эта функция ничего не возвращает
		time_nanosleep(0, 500); /* Пауза в 0 секунд и 500 наносекунд. Эта функция возвращает 
                                   TRUE, FALSE или массив в случае прерывания сигналом: 
								   https://www.php.net/manual/ru/function.time-nanosleep.php   */
	  ?>
  </div> 
</div>  

<div> <h2> ХРАНЕНИЕ И ОБРАБОТКА ДАННЫХ В ОПЕРАТИВНОЙ ПАМЯТИ </h2>

  <div>    <h3> РАБОТА С ПЕРЕМЕННЫМИ  </h3>
	<?php   /* https://www.php.net/manual/ru/language.variables.basics.php 
		php-переменные начинаются с символа $, следующей за ней буквой или символом "_" и далее 
		произвольным количеством букв, цифр и символа "_" 
		Длина имени не ограничена. Регистр имеет значение.
		Переменные не требуют специального объявления и создаются во время инициализации: */
		
			$numb1 = 213; // Создана переменная, в которую записано число 213
			$numb1 = 789; // Проинициализированную переменную можно заменить новым значением.
			echo "numb1 == ",$numb1; // Echo выводит на экран значение переменной
			
			$numb1 = "Строка"; /* Тип переменной не фиксирован и в любую переменную могут быть 
								записаны данные любого типа */
			echo "<br>numb1 == ",$numb1;
			// Переменную можно создать как ссылку (псевдоним) на другую переменную:
			$numb1b = &$numb1; // numb1b ссылается на ту же область памяти что и numb1
			
		/* ПЕРЕМЕННОЕ ИМЯ ПЕРЕМЕННОЙ
		Использование символа "$" перед именем переменной в сочетании с интерпретацией скрипта во
		время исполнения позволяет создавать переменные с именем, хранящися в другой переменной.
		Для этого надо перед именем переменной поставить второй символ "$"  */
		
			$var_name = "numb2";
			$$var_name = 456;  // Создана переменная $numb2:
			echo "<br>В переменной ", $var_name, " хранится значение ", $$var_name;
	?>  
	
	<h4> Работа с константами (неизменяемыми переменными) </h4>
	<?php  /* https://www.php.net/manual/ru/language.constants.php
			  Для имён констант используется тот же набор символов, что и для переменных. 
	          При этом не используется символ $ перед именем. 
			  Создать константу можно либо функцией define() либо конструкцией const: */
		
		define("PI", 3.14);  // Имя константы пишут заглавными буквами, но строчными тоже допустимо
		const HI = "Привет"; // Такое объявление не допустимо внутри циклов, условий и функций 
		echo "Константа PI: ", PI, "; Константа HI: ", HI;
		
		/* Если имя константы хранится в переменной, то получить для этого имени значение можно 
		   с помощью функции constant() */
		$const_name = "PI";
		echo "<br>В константе ", $const_name, " хранится значение ", constant($const_name);
		
	?>  

	
	<h4> Простые типы данных </h3>
	<?php // https://www.php.net/manual/ru/language.types.php  
		
		// ЦЕЛЫЕ ЧИСЛА ТИПА INTEGER (количество бит зависит от ОС):
			$numb1 = 456;  // Десятичное целое число
			$numb1 = 0xF0; // Шестнадцатиричное число начинается с 0x
			$numb1 = 070;  // Восьмиричное число начинается с 0
			$numb1 = 0b11001;  // Двоичное число начинается с 0b
		
		// ВЕЩЕСТВЕННЫЕ ЧИСЛА ТИПА FLOAT И DOUBLE
			$numb2 = 123.789;  // Для задания вещественного числа используется разделитель - точка
			$numb2 = 3.2e5;    /* = 320000   Запись в научном формате. После символа "e" задаётся 
								сдвиг запятой вправо для десятичного числа */
	
			$numb2 = 3.2e-5;   /* = 0.000032 Отрицательное число сдвигает запятую влево, 
								задавая десятичную дробь */
        
		$numb3 = NAN;  //Спец.значение "Not a Number" используется для обозначения ошибки вычислений
		
        $bool1 = true;   // Логический тип "истина"
        $bool1 = false;  // и "ложь"

        $str2 = null;        // Специальный тип означающий "неизвестное значение"
		
		
		// СТРОКИ
			$str1 = "Тестовая строка";       // Строки задаются двойными или одинарыми кавычками
			// Для использования в строке двойных кавычек можно обрамлять её в одинарные кавычки:
			$str1 = 'Тестовые "кавычки"';    
			$str1 = "Тестовые \"кавычки\"";  // либо использовать экранирующий символ  "\"
			$str1 = " \\ ";  // Для сохранения экранирующего символа его нужно написать дважды 
			$str1 = " \$ ";  // Знак доллара нужно экранировать 
			$str1 = "Первая строка\nВторая строка"; // Перенос строки: \n
			$str1 = "\t \r \b \f"; // Символы  Tab | Return | Backspace | Form feed (новая страница)
			
		// ОБРАБОТКА ИМЁН ПЕРЕМЕННЫХ ВНУТРИ СТРОК
			/* https://www.php.net/manual/ru/language.types.string.php#language.types.string.parsing
			   Если строка обрамлена двойными (а не одинарными) кавычками,  
		       то переменные в ней обрабатываются (т.е. вместо имён подставляются значения): */
			echo "<br>numb1 == $numb1"; // На экране появится число 789
			/* Если после имени переменной идёт допустимый для имён переменных символ, то нужно
			использовать полный синтаксис - заключать переменую в фигурные скобки:  */
			echo "<br>numb1 == {$numb1}_"; 
	?>  

	<h4> Использование переменных </h3>
	<?php   
		// Проверка, инициализирована переменная значением, отличным от NULL :
			if (isset($numb1)) echo "Переменная numb1 инициализирована.";  
									 // https://www.php.net/manual/ru/function.isset.php
		/* Проверка типа переменной. Список возможных значений:
		   boolean,integer,double,string,array,object,resource,NULL,"unknown type" */
			$str1 = gettype($numb2); // https://www.php.net/manual/ru/function.gettype.php
	?>  
  </div>
  
  <div>    <h3> ОПЕРАЦИИ </h3>
	<?php  // https://www.php.net/manual/ru/language.operators.php  	  
	
	    $numb1 = $numb2 = 5;   /* Оператор присваивания тоже возвращает значение, которое можно 
                                  использовать в предыдущем операторе присваивания               */
		echo $numb1 = 7 + 5;   /* или в выводе на экран. Сам оператор правоассоциативный - т.е. 
                                  вычисления последовательности операторов идут справа налево.   */
		$bool1 = $numb2 == 5;  // Оператор == сравнивает два значения и возвращает true или false
		$bool1 = $numb2 === 5; // Оператор === сравнивает два значения b и проверяет равенство типов 
		?>	
	
	<h4> Арифметические операции </h4>
	<?php 
		$numb1 = ( 7+2-3 ) * 4/5;  // Сложение вычитание умножение и деление для любых типов чисел.
     // $numb1 = intdiv(31,8);     // Целочисленное деление (в версиях PHP 7 и выше)
        $numb1 = 31.1 % 8.9;       // == 7     Остаток от деления целочисленных частей чисел
        $numb1 = fmod(4,1.9);      // == 0.2   Остаток от деления вещественных чисел
        $numb1 = 2 ** 3.5;         // Возведение в степень (в версиях PHP 5.6 и выше)
        $numb1 = 2 ** -2;  // == 0.25 Отрицательная степень (сколько раз разделить единицу на число)      
        // Для вычисления корня можно использовать возведение в дробную степень:
        echo $numb1 = 9 ** (1/2);  // == 3   Корень квадратный из числа 9
	?>

	<h4> Унарные операции </h4>
	<?php 
        $i = +$numb1;   // Унарный оператор подтверждения знака (приводит другие типы к числу)
        $i = -$numb1;   // Унарный оператор смены знака

        $i++; /* Постфиксный инкремент переменной. Возвращает значение переменной ДО операции 
                 инкремента и увеличивает значение переменной на 1. */
        $i--; /* Постфиксный декремент переменной. Возвращает значение переменной ДО операции 
                 декремента и уменьшает значение переменной на 1. */
        ++$i; /* Префиксный инкремент переменной. Возвращает значение переменной ПОСЛЕ операции 
                 инкремента. Унарный аналог i = i+1. */
        --$i; /* Префиксный декремент переменной. Возвращает значение переменной ПОСЛЕ операции 
                 декремента. Унарный аналог i = i-1. */
		echo $i;
	?>

	<h4> Побитовые операции  </h4>
	<?php /* Побитовые операции производятся с целой частью числа. Дробая часть теряется. 
             Имеют низкий приоритет поэтому часто требуют обрамления скобками. */
        $j = ~$i;       /* Побитовая инверсия - вычитание из -1 (смена знака и декремент). 
                           Инверсия полезна в связке с операцией смены знака: */
        $j = -~$i;      // Инкремент числа. Унарный аналог j = i+1 
        $j = ~-$i;      // Декремент числа. Унарный аналог j = i-1
        echo $i = -~ 2 * 6;  /* Результат равен 2, а не 13, поскольку у унарных операторов 
                               приоритет выше чем у операций умножения и деления."  */

        $i = $i << 5;   /* Побитовый сдвиг влево на указанное число бит с сохранением знака 
                           (умножение на степень двойки ). */
        $i = $i >> 2;   /* Побитовый сдвиг вправо на указанное число бит с сохранением знака 
                           (деление на степень двойки). */
        $i = $i & 5;    // Побитовое И (AND). Используется для установки в нужные биты значения 0.
        $i = $i | 5;    // Побитовое ИЛИ (OR). Используется для установки в нужные биты значения 1.
        $i = $i ^ 2;    /* Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR). 
                           Используется для смены значений нужных битов на противоположные. */
		// echo $i;
	?>

    <h4> Конкатенация строк: через бинарный оператор +  </h4>
    <?php
        echo $str1 = "строка1 " . "строка2"; 
	?>    

    <h4>  Комбинированные операторы присваивания </h4> 
    <?php
        $i += 5; $i -= 5;   // Увеличить или уменьшить переменную на указанное число.
        $i *= 3; $i /= 3;   // Умножить или поделить переменную на указанное число.   
        $i %= 10;           // Записать в переменную остаток от деления её на указанное число; 
        $i <<= 2; $i >>= 2; // Сдвинуть биты переменной влево или вправо на указанное число позиций.
        $i &= 5; $i |= 5; $i ^= 2;   // Поменять значение нужных бит на 0, 1 или противоположное.
		echo $str1 .= " строка3"; // Добавить строку к переменной;
 	?>
	
	<h4> Операторы сравнения и логические операторы </h4> 
    <?php // Во всех нижепреведенных сравнениях результат равен true  
        $b = 2 == '2'   and // Нестрогое равенство (c приведением типов)
             2 != '3'   and //     и нестрогое неравенство
             2 === 2    and // Строгое равенство (без приведения типов)
             2 !== '2'  and //     и строгое неравенство
             $bool1 != !$bool1    and // Отрицание
            (1 >= 1) && (2 > 1)   and // Логическое "И" (конъюнкция)
            (1 <= 1) || (2 < 1)   and // Логическое "ИЛИ" (дизъюнкция)
            (1 >= 1) and (2 > 1)  and // Альтернативная конъюнкция (с низким приоритетом)
           ((1 <= 1) xor (2 < 1)) and // Логическое "ИСКЛЮЧАЮЩЕЕ ИЛИ" (ещё ниже приоритет)
           ((1 <= 1) or  (2 < 1)) and // Альтернативная дизъюнкция - самый низкий приоритет
             NAN != NAN           and // NaN не равен ничему - даже самому себе
             null == 0            and // В отличие от JavaScript, где null != 0.
             "Строка 2" > "Строка 1"; // Строки сравниваются побуквенно по кодам символов
        echo "Результат всех сравнений и логических операций: ", $b;
   	?>
	
    <h4> Особенности арифметического переполнения и искажений хранения </h4>
    <?php 
		// Операция умножения целой части числа на 2 путем сдвига влево вызовет переполнение:
        echo "Переполнение: вместо 20000000000 получаем " . (10000000000 << 1) . "<br>" .
		     "Максимальное целое число которое сохранится без искажений: " .
			 $numb1 = PHP_INT_MAX ; /* 2147483647 - это максимальное целое число которое сохранится 
		     как integer. Цeлочисленные операции, дающие результат превышающий значение PHP_INT_MAX, 
			 меняют тип переменной с integer на double: */
		echo "<br> Тип PHP_INT_MAX : " . gettype($numb1);         // integer
		echo "<br> Тип (PHP_INT_MAX + 1) : " . gettype(++$numb1); // double
	?>
	
  </div> 

</div>
</body>
</html>

