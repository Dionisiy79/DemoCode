<!DOCTYPE HTML> <html><head><meta charset="utf-8"></head><body>
<!-- Откройте этот файл в Notepad++ чтобы свернуть блоки в удобное меню простой комбинацией клавиш:
	 (Alt + 4) - свернуть и (Alt + Shift + 0)  - развернуть.
	 То же самое можно сделать в Visual Studio Code:
	 (Ctrl + K) + (Ctrl + 2) - свернуть, (Ctrl + K) + (Ctrl + J) - развернуть
	 -->

<div>
<h1>ОСНОВЫ РАБОТЫ С ЯЗЫКОМ ПРОГРАММИРОВАНИЯ PHP</h1>
    
<div> <h2> ОБЩИЕ СИНТАКСИЧЕСКИЕ ПРАВИЛА </h2>
	<p> При классическом использовании PHP-код встраивается фрагментарно в содержимое HTML-файла, 
	     добавляя необходимую функциональность на страницу. В этом документе объясняется только 
		 синтаксис PHP (подразумевая что читатель уже знает синтаксис HTML). </p>
	
	<!-- Фрагменты PHP-кода добавляются в HTML-документ путём заключения этого кода внутри тега:
		 <?php   ?>
	-->
	
	<?php // Однострочный комментарий до конца строки задается двумя слэшами в начале комментария
		  #  Однострочный комментарий в стиле UNIX Задаётся символом # в начале строки
		  /*  Многострочный комментарий - обрамляется парой символов "/" и "*" 
			  В начале комментария символы / и * идут в прямом порядке, а в конце - в обратном.
				https://www.php.net/manual/ru/language.basic-syntax.comments.php
		  */
	?>
		
	<?php  /* Это открывающий тег, который  сообщает интерпретатору, 
				что текст внутри тега является php-кодом, который нужно выполнять.
	
	?>  // Это закрывающий тег. Он не действует внутри многострочного комментария, и наоборот, */
		// срабатывает внутри однострочного комментария, действуя аналогично концу строки:  ?> 
	
	<p>Текст вне php-тегов выводится браузером как обычный html-код.</p>
	
	<p> Рекомендуется не ставить закрывающий тег ?> в самом конце файла, чтобы иметь возможность 
			импортировать внешние скрипты и не иметь проблем с выводом в html-документ 
			невидимых символов	после закрывающего тега ?> </p>
	
	<p> Выражения в PHP выделяются круглыми скобками "()" и разделяются символом точки с запятой ";"
		 Cимвол ";" можно не писать перед закрывающим тегом ?> </p>
		<?php  
			1 + 2;        // Символ ";" означает конец выражения.
			3 * (1 + 2);  // Выражение в скобках вычисляется первым
		?>

	<p> Если выражение содержит ошибку и некорректный результат вычисления, то интерпретатор PHP 
	    выведет предупреждение прямо в HTML-документ. Это предупреждение можно принудительно скрыть, 
		если прямо перед выражением поставить символ "@"</p>
		<?php  
			 (1 + "Z");  // Это выражение в новых версиях PHP выведет предупреждение WARNING
			@(1 + "Z");  // Символ "@" отключает вывод предупреждения
		?>
	
	<p> Блок операторов выделяется фигурными скобками {}
         Отключить выполнение кода можно поместив его внутрь блока if(0){  } </p>
	
		<?php  // В коде не должно быть ошибок. Для включения нужно 0 заменить на 1 :
			if(0){ echo "Невыполняющийся код"; } 
		?>
	<!-- Если PHP-код перемежается с HTML, то HTML-код в невыполняющемся блоке игнорируется: -->
		<?php if(0){ ?> 
			Этот HTML-текст не будет выведен на страницу. 
		<?php } ?>
		
  </div>
</div>

<div> <h2> КОМАНДЫ ВЗАИМОДЕЙСТВИЯ С ПОЛЬЗОВАТЕЛЕМ </h2>	
	 
  <div>    <h3> ВЫВОД ТЕКСТОВЫХ СТРОК </h3>
  	  <!-- Языковая конструкция echo выводит html-текст в текущее место веб-страницы
		   https://www.php.net/manual/ru/function.echo.php -->
	  <?php echo "Hello World!" ?>
	  <?= "Hello World!" ?>  <!-- Этот сокращённый вызов echo делает то же самое -->
	  <?php 
		echo "<br>HTML <b>работает!!!</b>"; // html-теги при этом обрабатываются
		echo "<br>","А", "Б", "В";          // Строки указанные через запятую - соединяются
		echo "<br> Дважды два ", 2*2;       // При выводе можно использовать выражения.
		echo "<br> Строка 1
		           Строка 2 ";              // Перенос строки тоже выводится.
	    echo("Строка 3");  // Можно вызов сделать как функцию, но на самом деле это не функция
				
		/* Языковая конструкция print выводит html-текст в текущее место веб-страницы,
		   возвращая при этом значение 1
		   https://www.php.net/manual/ru/function.print.php */
		
		print "<br>Вывод строки print";     // Допустимо использовать только один аргумент
		echo print "<br> Вызов print возвращает значение ";  // 1
		print("<br>"); // Можно сделать вызов как функцию, при этом print 
	  ?>
  </div> 
  
  <div>    <h3> ВВОД ДАННЫХ ЧЕРЕЗ GET/POST ЗАПРОСЫ </h3>
	    
	<!-- Самый простой способ ввести данные, которые сможет прочитать php-скрипт - это
	         добавить к URL-строке текст со значением переменной  в формате:
		  ?var1="demotext"  (<имя переменной>=<значение> ) 
	   -->
	<a href="?var1=demotext"> Нажмите эту ссылку для отправки значения переменной через URL </a><br>
	    <?php // Значение можно прочитать в глобальном ассоциативном массиве $_GET
			if (isset($_GET['var1'])) {   // Проверяется существование значения с ключом "var1"
				echo "Через URL передано значение для var1: ";
				echo htmlspecialchars($_GET['var1']); }
		?> <!-- В целях безопасности при выводе переменной применяется функция htmlspecialchars -->
	
	<!-- То же самое можно сделать путём заполнения формы и её отправки GET-запросом -->
		<form action="" method="get">
			Введите значение для var2: <input type="text" name="var2" /><input type="submit" />
		</form>	  
	
	    <?php if (isset($_GET['var2'])) {  
			echo "Через GET-запрос передано значение для var2: ";
			echo htmlspecialchars($_GET['var2']); }   
		?>	 
		
	<!-- Аналогичная передача POST-запросом позволяет оставить URL неизменным  -->
		<form action="" method="post">
			Введите значение для var3: <input type="text" name="var3" /> <input type="submit" />
		</form>	  
	
	    <?php // Для POST запросов используется аналогичный массив $_POST
			if (isset($_POST['var3'])) {
				echo "Через POST-запрос передано значение для var3: ";
				echo htmlspecialchars($_POST['var3']); }  
		?>	 
		
  </div>

  <div>    <h3> ПАУЗА ВЫПОЛНЕНИЯ СКРИПТА </h3>
	  <?php   	  
		sleep(1);       // Пауза в 1 секунду;  Эта функция возвращает 0 при успешном выполнении
		usleep(500000); // Пауза в полсекунды (в микросекундах);  Эта функция ничего не возвращает
		time_nanosleep(0, 500); /* Пауза в 0 секунд и 500 наносекунд. Эта функция возвращает 
                                   TRUE, FALSE или массив в случае прерывания сигналом: 
								   https://www.php.net/manual/ru/function.time-nanosleep.php   */
	  ?>
  </div> 
</div>  

<div> <h2> ХРАНЕНИЕ И ОБРАБОТКА ДАННЫХ В ОПЕРАТИВНОЙ ПАМЯТИ </h2>

  <div>    <h3> РАБОТА С ПЕРЕМЕННЫМИ  </h3>
	<?php   /* https://www.php.net/manual/ru/language.variables.basics.php 
		php-переменные начинаются с символа $, следующей за ней буквой или символом "_" и далее 
		произвольным количеством букв, цифр и символа "_" 
		Длина имени не ограничена. Регистр имеет значение.
		Переменные не требуют специального объявления и создаются во время инициализации: */
		
			$numb1 = 213; // Создана переменная, в которую записано число 213
			$numb1 = 789; // Проинициализированную переменную можно заменить новым значением.
			echo "numb1 == ",$numb1; // Echo выводит на экран значение переменной
			
			$numb1 = "Строка"; /* Тип переменной не фиксирован и в любую переменную могут быть 
								записаны данные любого типа */
			echo "<br>numb1 == ",$numb1;
		
		### ССЫЛКИ-ПСЕВДОНИМЫ ###
			// https://www.php.net/manual/ru/language.references.whatare.php
			// Переменную можно создать как ссылку (псевдоним) для другой переменной:
			$numb1b = &$numb1; // numb1b ссылается на значение numb1 (на контейнер с данными) 
			// Теперь numb1 и numb1b являются равноценными ссылками на один и тот же контейнер
			$numb1 = 1;        // При изменении значения numb1 значение numb1b тоже поменялось:
			echo "<br> После смены значения переменная и псевдоним равны: " . ($numb1 == $numb1b);
			
			// Если меняется не значение переменной, а связь с ним, то псевдоним не изменяется:
			$numb2 = 2;       // Создадим новую переменную и сделаем numb1 ссылкой на неё:
			$numb1 = &$numb2; /* Здесь поменялось не значение переменной numb1, 
					а создана новая связь numb1 с другим значением (контейнером для numb2) */
			echo "<br>После смены связи numb1 стала ",$numb1," а numb1b осталась ",$numb1b; // 1,2
		
		### УДАЛЕНИЕ ПЕРЕМЕННОЙ ###		
			unset($numb1); /* Удаление переменной (разрушение связи со значением)
						      https://www.php.net/manual/ru/function.unset.php  */
			echo "<br>numb1 удалена, а её значение, связанное с numb1b, осталось: ", $numb1b;
			// Значение удаляется из памяти, если с ним больше не связано ни одного имени переменной
			
		### ПЕРЕМЕННОЕ ИМЯ ПЕРЕМЕННОЙ ###
		/* Использование символа "$" перед именем переменной в сочетании с интерпретацией скрипта во
		время исполнения позволяет создавать переменные с именем, хранящися в другой переменной.
		Для этого надо перед именем переменной поставить второй символ "$"  */
		
			$var_name = "numb2";
			$$var_name = 456;  // Создана переменная $numb2:
			echo "<br>В переменной ", $var_name, " хранится значение ", $$var_name;
	?>  
	
	<h4> Работа с константами (неизменяемыми переменными) </h4>
	<?php  /* https://www.php.net/manual/ru/language.constants.php
			  Для имён констант используется тот же набор символов, что и для переменных. 
	          При этом не используется символ $ перед именем. 
			  Создать константу можно либо функцией define() либо конструкцией const: */
		
		define("PI", 3.14);  // Имя константы пишут заглавными буквами, но строчными тоже допустимо
		const HI = "Привет"; // Такое объявление не допустимо внутри циклов, условий и функций 
		echo "Константа PI: ", PI, "; Константа HI: ", HI;
		
		/* Если имя константы хранится в переменной, то получить для этого имени значение можно 
		   с помощью функции constant() */
		$const_name = "PI";
		echo "<br>В константе ", $const_name, " хранится значение ", constant($const_name);
		
	?>  
	
	<h4> Простые типы данных </h3>
	<?php // https://www.php.net/manual/ru/language.types.php  
		
		### ЦЕЛЫЕ ЧИСЛА ТИПА INTEGER (количество бит зависит от ОС) ###
		
			$numb1 = 456;  // Десятичное целое число
			$numb1 = 0xF0; // Шестнадцатиричное число начинается с 0x
			$numb1 = 070;  // Восьмиричное число начинается с 0
			$numb1 = 0b11001;  // Двоичное число начинается с 0b
		
		### ВЕЩЕСТВЕННЫЕ ЧИСЛА ТИПА FLOAT И DOUBLE ###
		
			$numb2 = 123.789;  // Для задания вещественного числа используется разделитель - точка
			$numb2 = 3.2e5;    /* = 320000   Запись в научном формате. После символа "e" задаётся 
								сдвиг запятой вправо для десятичного числа */
	
			$numb2 = 3.2e-5;   /* = 0.000032 Отрицательное число сдвигает запятую влево, 
								задавая десятичную дробь */
        
		$numb3 = NAN;  //Спец.значение "Not a Number" используется для обозначения ошибки вычислений
		$numb3 = INF;  //Спец.значение "Infinity"  - бесконечно большое число
		
        $bool1 = true;   // Логический тип "истина"
        $bool1 = false;  // и "ложь"

        $str2 = null;        // Специальный тип означающий "неизвестное значение"
		
		
		### СТРОКИ ###
		
			$str1 = "Тестовая строка";       // Строки задаются двойными или одинарыми кавычками
			// Для использования в строке двойных кавычек можно обрамлять её в одинарные кавычки:
			$str1 = 'Тестовые "кавычки"';    
			$str1 = "Тестовые \"кавычки\"";  // либо использовать экранирующий символ  "\"
			$str1 = " \\ ";  // Для сохранения экранирующего символа его нужно написать дважды 
			$str1 = " \$ ";  // Знак доллара нужно экранировать 
			$str1 = "Первая строка\nВторая строка"; // Перенос строки: \n
			$str1 = "\t \r \b \f"; // Символы  Tab | Return | Backspace | Form feed (новая страница)
			
		### ОБРАБОТКА ИМЁН ПЕРЕМЕННЫХ ВНУТРИ СТРОК ###
		
			/* https://www.php.net/manual/ru/language.types.string.php#language.types.string.parsing
			   Если строка обрамлена двойными (а не одинарными) кавычками,  
		       то переменные в ней обрабатываются (т.е. вместо имён подставляются значения): */
			echo "<br>numb1 == $numb1"; // На экране появится число 789
			
			/* Если после имени переменной идёт допустимый для имён переменных символ, то нужно
			использовать полный синтаксис - заключать переменую в фигурные скобки:  */
			echo "<br>numb1 == {$numb1}_"; 
	?>  

	<h4> Использование переменных </h3>
	<?php   
		### ПРОВЕРКА, ИНИЦИАЛИЗИРОВАНА ЛИ ПЕРЕМЕННАЯ ЗНАЧЕНИЕМ, ОТЛИЧНЫМ ОТ NULL ###
			if (isset($numb1)) echo "Переменная numb1 инициализирована.";  
									 // https://www.php.net/manual/ru/function.isset.php
		
		### ПРОВЕРКА ТИПА ПЕРЕМЕННОЙ ###
		   /* Список возможных значений:
		      boolean,integer,double,string,array,object,resource,NULL,"unknown type" */
			$str1 = gettype($numb2); // https://www.php.net/manual/ru/function.gettype.php
			
		### ВЫВОД ИНФОРМАЦИИ О ПЕРЕМЕННОЙ В ТЕКСТОВОМ ВИДЕ ###
			
			echo "<br>Тип и содержимое переменной: ";   var_dump($numb1);
			// Функция print_r удобна для оперативного просмотра массивов и объектов:
			echo "<br>Cодержимое переменной: ";   print_r($numb1);  
	?>  
  </div>
  
  <div>    <h3> ОПЕРАЦИИ </h3>
	<?php  // https://www.php.net/manual/ru/language.operators.php  	  
	
	    $numb1 = $numb2 = 5;   /* Оператор присваивания тоже возвращает значение, которое можно 
                                  использовать в предыдущем операторе присваивания               */
		echo $numb1 = 7 + 5;   /* или в выводе на экран. Сам оператор правоассоциативный - т.е. 
                                  вычисления последовательности операторов идут справа налево.   */
		$bool1 = $numb2 == 5;  // Оператор == сравнивает два значения и возвращает true или false
		$bool1 = $numb2 === 5; // Оператор === сравнивает два значения b и проверяет равенство типов 
		?>	
	
	<div>     <h4> Арифметические операции </h4>
	<?php 
		$numb1 = ( 7+2-3 ) * 4/5;  // Сложение вычитание умножение и деление для любых типов чисел.
     // $numb1 = intdiv(31,8);     // Целочисленное деление (в версиях PHP 7 и выше)
        $numb1 = 31.1 % 8.9;       // == 7     Остаток от деления целочисленных частей чисел
        $numb1 = fmod(4,1.9);      // == 0.2   Остаток от деления вещественных чисел
        $numb1 = pow(2, 3.5);      // Возведение в степень 
        $numb1 = 2 ** 3.5;         // Возведение в степень (в версиях PHP 5.6 и выше)
        $numb1 = 2 ** -2;  // == 0.25 Отрицательная степень (сколько раз разделить единицу на число)      
        // Для вычисления корня можно использовать возведение в дробную степень:
        echo $numb1 = 9 ** (1/2);  // == 3   Корень квадратный из числа 9
		$numb1 = sqrt(9);          // == 3   Функция вычисления квадратного корня
	?>
	</div>
	<div>     <h4> Унарные операции </h4>
	<?php 
        $i = +$numb1;   // Унарный оператор подтверждения знака (приводит другие типы к числу)
        $i = -$numb1;   // Унарный оператор смены знака

        $i++; /* Постфиксный инкремент переменной. Возвращает значение переменной ДО операции 
                 инкремента и увеличивает значение переменной на 1. */
        $i--; /* Постфиксный декремент переменной. Возвращает значение переменной ДО операции 
                 декремента и уменьшает значение переменной на 1. */
        ++$i; /* Префиксный инкремент переменной. Возвращает значение переменной ПОСЛЕ операции 
                 инкремента. Унарный аналог i = i+1. */
        --$i; /* Префиксный декремент переменной. Возвращает значение переменной ПОСЛЕ операции 
                 декремента. Унарный аналог i = i-1. */
		echo $i;
	?>
	</div>
	<div>     <h4> Побитовые операции  </h4>
	<?php /* Побитовые операции производятся с целой частью числа. Дробая часть теряется. 
             Имеют низкий приоритет поэтому часто требуют обрамления скобками. */
        $j = ~$i;       /* Побитовая инверсия - вычитание из -1 (смена знака и декремент). 
                           Инверсия полезна в связке с операцией смены знака: */
        $j = -~$i;      // Инкремент числа. Унарный аналог j = i+1 
        $j = ~-$i;      // Декремент числа. Унарный аналог j = i-1
        echo $i = -~ 2 * 6;  /* Результат равен 2, а не 13, поскольку у унарных операторов 
                               приоритет выше чем у операций умножения и деления."  */

        $i = $i << 5;   /* Побитовый сдвиг влево на указанное число бит с сохранением знака 
                           (умножение на степень двойки ). */
        $i = $i >> 2;   /* Побитовый сдвиг вправо на указанное число бит с сохранением знака 
                           (деление на степень двойки). */
        $i = $i & 5;    // Побитовое И (AND). Используется для установки в нужные биты значения 0.
        $i = $i | 5;    // Побитовое ИЛИ (OR). Используется для установки в нужные биты значения 1.
        $i = $i ^ 2;    /* Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR). 
                           Используется для смены значений нужных битов на противоположные. */
	?>
	</div>
    <div>     <h4> Конкатенация строк: через бинарный оператор +  </h4>
    <?php
        echo $str1 = "строка1 " . "строка2"; 
	?>    
	</div>
    <div>     <h4> Комбинированные операторы присваивания </h4> 
    <?php
        $i += 5; $i -= 5;   // Увеличить или уменьшить переменную на указанное число.
        $i *= 3; $i /= 3;   // Умножить или поделить переменную на указанное число.   
        $i %= 10;           // Записать в переменную остаток от деления её на указанное число; 
        $i <<= 2; $i >>= 2; // Сдвинуть биты переменной влево или вправо на указанное число позиций.
        $i &= 5; $i |= 5; $i ^= 2;   // Поменять значение нужных бит на 0, 1 или противоположное.
		echo $str1 .= " строка3"; // Добавить строку к переменной;
 	?>
	</div>
	<div>     <h4> Операторы сравнения и логические операторы </h4> 
    <?php // Во всех нижепреведенных сравнениях результат равен true  
        $b = 2 == '2'   && // Нестрогое равенство (c приведением типов)
             2 != '3'   && //     и нестрогое неравенство
             2 === 2    && // Строгое равенство (без приведения типов)
             2 !== '2'  && //     и строгое неравенство
             $bool1 != !$bool1    && // Отрицание
            (1 >= 1) && (2 > 1)   && // Логическое "И" (конъюнкция)
           ((1 <= 1) || (2 < 1))  && // Логическое "ИЛИ" (дизъюнкция)
           ((1 >= 1) and (2 > 1)) && // Альтернативная конъюнкция (с низким приоритетом)
           ((1 <= 1) xor (2 < 1)) && // Логическое "ИСКЛЮЧАЮЩЕЕ ИЛИ" (ещё ниже приоритет)
           ((1 <= 1) or  (2 < 1)) && // Альтернативная дизъюнкция - самый низкий приоритет
             null == 0            && // В отличие от JavaScript, где null != 0.
             "Строка 2" > "Строка 1"; // Строки сравниваются побуквенно по кодам символов
        echo "Результат всех сравнений и логических операций: ", $b;
		
		// Приоритет операторов and, xor и or ниже приоритета даже оператора =
			$b = 5 && 0;    // $b == false;  
			$b = 5 and 0;   // Неправильно: $b == 5;
			$b = (5 and 0); // Правильно: $b == false;
   	?>
	</div>
    <div>     <h4> Операции с особыми float-числами INF и NAN </h4>
    <?php 
        // Справедливы следующие соответствия (результат нижеприведенных сравнений == true)
        $b =  1 + INF  ===  INF  &&  
              1 - INF  === -INF  &&
              1 / INF   ==  0    &&  // Деление на бесконечность нестрого равно нулю
              1 / INF  !==  0    && 
             -1 / INF  ==  -0    &&  // минус ноль (бесконечно малое отрицательное число)
                   -0  ===  0    &&  
        "".   0 * INF  === "NAN" &&  // умножение нуля на бесконечность,
        "".  (5 + NAN) === "NAN" &&  // арифметические операции с NaN,
        "". INF / INF  === "NAN" &&  // деление двух бесконечностей,
        "".(INF - INF) === "NAN" &&  // вычитание двух бесконечностей.
                  NAN  !=   NAN  && // NaN не равен ничему - даже самому себе
           is_nan(NAN)           &&  // Функция is_nan(n) возвращает true если её аргумент NAN
           is_finite(5)          &&  // Функция проверки, что значение - конечное число
           is_infinite(INF) ;        // Функция проверки, что значение - бесконечное число
        echo "Результат проверки всех операций с особыми числами: $b";
	?>
	</div>	
    <div>     <h4> Особенности арифметического переполнения и искажений хранения </h4>
    <?php 
		// Операция умножения целой части числа на 2 путем сдвига влево вызовет переполнение:
        echo "Переполнение: вместо 20000000000 получаем " . (10000000000 << 1) . "<br>" .
		     "Максимальное целое число которое сохранится без искажений: " .
			 $numb1 = PHP_INT_MAX ; /* 2147483647 - это максимальное целое число которое сохранится 
		     как integer. Цeлочисленные операции, дающие результат превышающий значение PHP_INT_MAX, 
			 меняют тип переменной с integer на double: */
		echo "<br> Тип PHP_INT_MAX : " . gettype($numb1);         // integer
		echo "<br> Тип (PHP_INT_MAX + 1) : " . gettype(++$numb1); // double
	?>
	</div>	
  </div> 

  <div>    <h3> ПРИВЕДЕНИЕ ПРОСТЫХ ТИПОВ ПРИ ОПЕРАЦИЯХ </h3>
	<div>     <h4> Преобразование в строку </h4>
	<?php   	  
		### АВТОМАТИЧЕСКОЕ СТРОКОВОЕ ПРЕОБРАЗОВАНИЕ ###
			
			echo $numb1 . " - там где ожидается строка простые типы приводятся к строке.<br>" ; 

		### ЯВНОЕ СТРОКОВОЕ ПРЕОБРАЗОВАНИЕ ###
			
			strval($bool1);    // Функция strval() возвращает строковое значение переменной.
			$str1 = (string)5; // Конструкция (string) перед выражением приводит любой тип к строке.
			$str1 = "$bool1";  // Использование переменной внутри двойных кавычек приводит к строке.
			$str1 = "{$bool1}"; // Тот же эффект при использовании фигурных скобок вокруг переменной
			$str1 = "" . true . 25 . null; // Конкатенация с пустой строкой даёт строку
			
			// Справедливы следующие равенства:
			$b = "". null  === ""      &&
				 "". NAN   === "NAN"   &&
				 "". true  === "1"     &&
				 "". false === "";     
			echo "<br>Результат проверки всех преобразований в строку: $b <br>"; // 1
        
        ### ПРИВЕДЕНИЕ ТИПА ЗНАЧЕНИЯ К СТРОКЕ ###
		
			// Справедливы следующие равенства:
			$b = "". gettype("")   === "string"  &&
				 "". gettype(1)    === "integer" &&
				 "". gettype(1.2)  === "double"  &&
				 "". gettype(NAN)  === "double"  &&  // "не число" тем не менее имеет тип double
				 "". gettype(true) === "boolean" &&
				 "". gettype(null) === "NULL";  
			echo "<br>Результат проверки всех приведений типов к строке: $b <br>"; // 1


			### ПРИВЕДЕНИЕ ЧИСЛА К СТРОКЕ В РАЗНЫХ СИСТЕМАХ СЧИСЛЕНИЯ ### 
			// Справедливы следующие равенства:
			$b = (string)(175) === "175"   && // По умолчанию используется десятичная система
				dechex(175) === "af"       && // Представление числа как шестнадцатиричное,
				decbin(175) === "10101111" && // двоичное,
				decoct(175) === "257";        // восьмиричное.
			echo "Результат проверки сравнений для разных систем счисления: $b <br>"; // true
			echo decoct(175);
	?>
	</div>     	
	<div>     <h4> Преобразование в число </h4>
	<?php   
		### АВТОМАТИЧЕСКОЕ ЧИСЛЕННОЕ ПРЕОБРАЗОВАНИЕ 					   ###
		
            // Происходит при арифметических операциях и сравнениях с числами 
			   
			// Если при сложении среди операндов нет строки, то все операнды приводятся к числу:
				echo $i = 1 + null + true ."<br>"; // 2
			// С другими арифметическими операциями все строки всегда приводятся к числу:
				echo $i = '1' / '2' - '3' * '4' % '5' .'<br>';  // -1.5
			/* Строки считываются слева направо, и если встречается нечисленный символ, 
			то в документ выводится предупреждение NOTICE и возвращается результат преобразования 
			в число считанной части строки. При этом начальные пробелы отбрасываются, 
			а идущие после цифр приводят к остановке разбора.
			В отличие от JS, не отбрасываются идущие в начале символы переноса строки. */
				echo $i = @('1' - ' 8z5') .'<br>';  // == -7 (В отличие от JS, который выдаст NaN)
			/* Операции сравнения == < <= > >= приводят свои операнды к числу 
			(за исключением если они оба - строки)  */  

		### ЯВНОЕ ЧИСЛЕННОЕ ПРЕОБРАЗОВАНИЕ ###
			
			$i = + '789';       // Унарный плюс приводит любой операнд к числу
			
			// Cправедливы следующие равенства
			$bool1 = @(+ "")    === 0   && // Пустая строка даёт 0
					 @(+ "abc") === 0   && // Строка символов даёт 0
					 + null     === 0   && 
					 + true     === 1   &&
					 + false    === 0;         
			echo "Результат проверки всех преобразований в число: $bool1 <br>"; // true
			
			###	ПРИВЕДЕНИЕ К ВЕЩЕСТВЕННОМУ ЧИСЛУ ###
				// Функция floatval() возвращает значение выражения в виде вещественного числа
					$i = floatval(789); echo gettype($i); // double
				// Конструкции (real), (float) и (double) приводят к double
					$i = (real)789;   echo gettype($i);   // "double"
					$i = (float)789;  echo gettype($i);   // "double"
					$i = (double)789; echo gettype($i);   // "double"
				
			### ПРИВЕДЕНИЕ К ЦЕЛОМУ ЧИСЛУ ###
				// Функция intval() возвращает значение выражения в виде целого числа
					$i = intval(789.87);  // == 789 
				// Конструкции (int) и (integer) приводят выражение к integer, отсекая дробь:
					$i = (int)789.87;     // == 789 
					$i = (integer)789.87; // == 789 
					echo gettype($i);     // "integer"
				
			### ФУНКЦИИ ОКРУГЛЕНИЯ, ВОЗВРАЩАЮЩИЕ ВЕЩЕСТВЕННОЕ ЧИСЛО ###
					$numb1 = floor(3.2);  // == 3  Округление числа вниз
					$numb1 = ceil(3.2);   // == 4  Округление числа вверх
					$numb1 = round(3.2);  // == 3  Округление до ближайшего целого
					// Вторым аргументом можно задать точность знаков после запятой, :
					round(3.14159,2); // == 3.14 
					// Отрицательная точность задаёт количество знаков ПЕРЕД запятой:
					round(4652,-2);   // == 4700  
				
		### ПАРСИНГ ЧИСЛА ИЗ СТРОКИ ###	
        
			// Справедливы следующие равенства для конструкций int и float:
        $b = (int)'45px'     ==  45 &&  // На незначимых символах парсинг прекращается   
             (int)' 5px'     ==   5 &&  // Допустимы пробелы вначале 
             (int)'$25'      ==   0 &&  // ==0 если первый значимый символ не цифра или пробел
             (int)' \n 5px'  ==   0 &&  // Перенос строки не считается пробельным символом 
             (int)'87.95 р'  ==  87 &&  // Парсинг целого числа заканчивается на точке 
             (int)'3.2e5'    ==   3 &&  // Научный формат как целое число НЕ распознаётся
             (int)'0x10'     ==   0 &&  // Формат шестнадцатиричного числа НЕ распознаётся
             (int)'010'      ==  10 &&  // Восьмиричное число обрабатывается как десятичное 
             (int)'0b100'    ==   0 &&  // Формат двоичного числа НЕ распознаётся
             (int)""         ==   0 &&  // Если в строке нет цифр, то результат 0
             (float)'5.8px'  == 5.8 &&  // Вещественные числа используют точку для дроби
             (float)'7.9.38' == 7.9 &&  // На второй точке парсинг останавливается
             (float)'3.2e-2' == 0.032;  // Научный формат парсится корректно для вещ.чисел
        echo "<br>Результат проверки всех парсингов чисел: $b"; // 1

		### ПАРСИНГ ЧИСЛА ИЗ СТРОКИ ДЛЯ ПРОИЗВОЛЬНЫХ СИСТЕМ СЧИСЛЕНИЯ ###
		
				/* Производится функцией intval(), у которой задан второй аргумент, как основание 
				нужной системы счисления. При этом первый аргумент - обязательно строка: */
				  
		    // Справедливы следующие равенства для функции intval():	
		   $b = intval('FF',16)    == 255 &&  // 255 записанное как шестнадцатиричное
				intval('0xFF',16)  == 255 &&  // 255 записанное как шестнадцатиричное
				intval("77",8)     == 63  &&  // 63 записанное как восьмиричное
				intval("077",8)    == 63  &&  // 63 записанное как восьмиричное
				intval("1000",2)   == 8   &&  // 8 записанное как двоичное  	
				// Если основание 0, то система счисления подбирается согласно формату строки:
				intval('0xFF',0)   == 255 &&  // 255 записанное как шестнадцатиричное
				intval("077",0)    == 63  &&  // 63 записанное как восьмиричное
				intval("77",0)     == 77  &&  // 77 десятичное 	
				// при этом формат двоичных чисел начинающихся с 0b вообще не поддерживается:
				intval("0b1000",0) == 0   &&  // 0
				intval("0b1000",2) == 0;      // 0
			echo "<br>Результат проверки всех парсингов недесятичных чисел: $b"; // 1
				
        ### ПРОВЕРКА, ЯВЛЯЕТСЯ ЛИ ВЫРАЖЕНИЕ ЧИСЛОМ ИЛИ СТРОКОЙ, ПРИВОДЯЩЕЙСЯ К ЧИСЛУ ###

			if (is_numeric($numb1))	echo "<br> numb1 является числом";

	?>
	</div>     	
	<div>     <h4> Преобразование в логическое значение </h4>
	<?php   
		### АВТОМАТИЧЕСКОЕ ЛОГИЧЕСКОЕ ПРЕОБРАЗОВАНИЕ ### 
	    
			// Производится там где ожидается логическое значение.
				if ($numb1) $j=5; // Если число numb1 отлично от 0, то выполнится операция j=5
				if ($str1) $j=5;  // Если строка str1 не пустая, то выполнится операция j=5.

			/* Операции && и || используют логический эквивалент операндов и возвращают true/false,
			   а не значение операндов как в JS: */
				$bool1 = $numb1 && $str1;  // В bool1 запишется true или false 
        
			/* В последовательности логических И/ИЛИ находится первое слева значение, 
               которое приводится к false/true. При этом оставшиеся выражения не вычисляются: */
				($n1 = 0) || ($n2 = 5) || ($n3 = 10); /* В n3 ничего не будет записано, так как 
                                                     на операнде (n2 = 5) вычисления прекратятся */

		### ЯВНОЕ ЛОГИЧЕСКОЕ ПРЕОБРАЗОВАНИЕ ###      
		
			$bool1 = boolval(789);  // Функция boolval возвращает логическое значение выражения    
			$bool1 = (boolean)789;  // Конструкция (boolean) приводит любой операнд к логическому    
			$bool1 = !!789;         // Тот же эффект у двух логических НЕ подряд 
			// Проверка что переменная содержит пустое значение либо не существует:
			$bool1 = empty($numb1); // Функция возвращает true, если переменная приводится к false
			
		    // Справедливы следующие равенства:
			$bool1 = ( !! " "  === true  ) &&  // Пробел не является пустой строкой
					 ( !! ""   === false ) && 
					 ( !! 0    === false ) &&  // Все остальные числа  дают true
					 ( !! NAN  === true  ) &&  // В отличие от JS, где !!NAN === false
					 ( !! null === false );    
			echo "<br>Результат проверки преобразований в логическое значение: $bool1"; // 1
			
		### ПРОВЕРКА СООТВЕТСТВИЯ ПЕРЕМЕННОЙ ИЛИ ВЫРАЖЕНИЯ НУЖНОМУ ТИПУ ###
		    // Справедливы следующие равенства:
			$bool1 = ( is_scalar(1)   === true ) && // Проверка что выражение имеет простой тип
					 ( is_string("1") === true ) && // Проверка что тип строковый
					 ( is_int(1)      === true ) && // Проверка что тип integer
					 ( is_float(1.2)  === true ) && // Проверка что тип float
					 ( is_bool(true)  === true ) && // Проверка что тип boolean
					 ( is_null(NULL)  === true );   // Проверка что тип null
			echo "<br>Результат проверки соответствий типов: $bool1"; // 1

	?>
	</div>     
  </div> 

  <div>    <h3> МАТЕМАТИЧЕСКИЕ ФУНКЦИИ И КОНСТАНТЫ </h3>
	<?php 	// https://www.php.net/manual/ru/math.constants.php
	    $numb1 = M_PI;  // Число Пи == 3.141592653589793
		$numb1 = M_E;   // Число e  == 2.718281828459045
		// $numb1 = Math.random();    // Генерация псевдослучайного числа:  0 <= Math.random() < 1. 
		
		$numb1 = abs(-3.14);  // == 3.14  Абсолютное значение числа (модуль числа)
		$numb1 = log(10);     /* Натуральный логарифм числа. 
								 log(x) - степень в которую нужно возвести e чтобы получить x. */
		$numb1 = exp(1);      // Натуральная экпонента. exp(x) == e в степени x.
			echo "<br>Число e: $numb1";
		$numb1 = max(2,-1,7); // Максимальное число из перечисленных аргументов
		$numb1 = min(2,-1,7); // Минимальное число из перечисленных аргументов
		
		// Тригонометрические функции
		$numb1 = sin(3.14/2); // Синус числа (для числа Пи/2 равен 1)
		$numb1 = cos(3.14);   // Косинус числа (для числа Пи равен -1)
		$numb1 = tan(3.14/4); // Тангенс числа (для числа Пи/4 равен 1)
		
		$numb1 = asin(1);     /* Арксинус числа (для числа 1 равен Пи / 2). 
										Аргумент должен быть <= 1 по модулю. Иначе - NAN */
		$numb1 = acos(-1);    /* Аркосинус числа (для числа 0 равен Пи). 
										Аргумент должен быть <= 1 по модулю. Иначе - NAN */
		$numb1 = atan(1);     // Арктангенс числа (для числа 1 равен Пи/4)
		// Арктангенс по координатам точки (y,x) на плоскости:
		$numb1 = atan2(-5,5);  // для угла 315 градусов равен Пи/4
	?>
  </div> 

  <div>    <h3> РАБОТА СО СТРОКАМИ </h3>
	<div>     <h4> Кодировки и длина строки </h4>
		<!-- https://www.php.net/manual/ru/book.strings.php 
			 https://www.php.net/manual/ru/ref.mbstring.php -->
		<?php  
		$str1 = "Тестовая строка Test String"; // Этот код (и строка) хранится в кодировке UTF-8. 
		echo "Внутренняя кодировка скрипта: ".mb_internal_encoding();  // UTF-8

		$strw1 = iconv('utf-8', 'CP1251', $str1);  // Преобразование str1 в кодировку 1251
		$numb1 = strlen($str1);  // Длина строки в байтах
			echo "<br> Длина строки UTF-8 в байтах: $numb1";
			echo "<br> Длина строки windows-1251 в байтах: " . strlen($strw1); 
		
		// Для работы с многобайтными кодировками есть функция mb_strlen()
		$numb1 = mb_strlen($str1,'utf-8');  // Длина строки в символах 
			echo "<br> Длина строки UTF-8 в символах: $numb1";
			echo "<br> Длина строки windows-1251 в символах: " . mb_strlen($strw1,'CP1251'); 
		?>
	</div>
	<div>     <h4> Посимвольное чтение и запись строки </h4>
		<?php // Посимвольное чтение строки для однобайтных кодировок (типа windows-1251): 
			$str2 = $strw1[0]; // Доступ к строке как к массиву (нумерация элементов с 0)
			$str2 = $strw1{0}; // Альтернативный способ получения N-го символа
			// Если индекс за пределами длины строки, то выведется предупреждение (NOTICE)

			// В строке с многобайтной кодировкой символ можно прочитать как подстроку:
			mb_substr($str1, 0, 1, 'utf-8'); // Из строки str1 начиная с 0 прочитать 1 символ utf-8
		
			$strw1[21] = "$";  // Замена латинского символа в однобайтной строке.
			// Замена кириллического символа требует указания кодировки этого символа:
			$strw1[0] = iconv('utf-8', 'CP1251', "Ш");
				$str2 = iconv('CP1251', 'utf-8', $strw1);  // Обратная смена кодировки на UTF-8
				echo "<br>Результат замены символов в строке: $str2";
			
		?>
	</div> 
	<div>     <h4> Смена регистра символов </h4>
		<?php 		
			// Смена регистра символов для однобайтных кодировок
			// Однобайтные функции требуют установки текущих локальных настроек в нужную кодировку 
			setlocale(LC_ALL, 'Russian_Russia.1251');          // Смена локали на 1251 
			echo "<br>Текущая локаль: ". setlocale(LC_ALL, 0); // Вывод текущего значения локали
			
			$str2up = strtoupper($strw1); // в верхний регистр 
			$str2lo = strtolower($strw1); // в нижний регистр 
			setlocale(LC_ALL, 'C'); // Возвратить системные настройки локали
			echo "<br>Текущая локаль: ". setlocale(LC_ALL, 0);
			echo "<br>Результат смены регистра :<br>".iconv('CP1251', 'utf-8', $str2up)."<br>".
			                                          iconv('CP1251', 'utf-8', $str2lo);

			// Смена регистра символов для многобайтных кодировок:
			$str2up = mb_strtoupper($str1, 'utf-8'); // в верхний регистр 
			$str2lo = mb_strtolower($str1, 'utf-8'); // в нижний регистр 
				echo "<br>Результат смены регистра UTF-8 :<br> $str2up <br> $str2lo";
		?>
	</div>
	<div>     <h4> Поиск подстроки в строке </h4>
		<?php 	
		// Для однобайтных кодировок используются функции:    strpos,    stripos и    strripos
		// Аналогичные многобайтные функции:               mb_strpos, mb_stripos и mb_strripos
			// Функция strpos принимает строку и подстроку, возвращая первую позицию подстроки:
			$n1 = mb_strpos($str1, 'ст');    // == 2   
			$n2 = mb_strpos($str1, 'ст', 6);    // == 9  Третий аргумент - позиция начала поиска
			$n3 = mb_strpos($str1, 'ст', -22);  // == 9  Отрицательное число: отступ с конца строки
			
			$n4 = mb_strpos($str1, 'Ст');  // === false  (поиск чувствителен к регистру)
			$n5 = mb_stripos($str1, 'Ст');  // == 2  : регистронезависимый поиск 

			$n6 = mb_strrpos($str1, 'ст', 1);  // == 9 : аналогичный поиск справа налево
			$n7 = mb_strripos($str1, 'Ст', 1); // == 9 : регистронезависимый поиск справа налево

				echo 'Подстрока "ст" начинается в строке strw1 с символа № '. $n1;
				echo '<br>С отступом 6 подстрока "ст" найдена в позиции '. $n2;
				echo '<br>Подстрока "ст" при задании правого отступа найдена в позиции '. $n3;
				if ($n4 === false) echo '<br>Подстрока "Cт" не найдена.';
				echo '<br>Подстрока "Cт" найдена в позиции '. $n5;
				echo '<br>При поиске с конца подстрока "ст" найдена в позиции '. $n6;
				echo '<br>При поиске с конца подстрока "Ст" найдена в позиции '. $n7;
				
			// Поиск всех вхождений подстроки в строку
			$i = -1; echo "<br>Подстрока найдена в позициях ";
			while (($i = mb_stripos($str1,'т', $i+1) ) !== false)  
				echo "$i ";  // == 0 , 3 , 10
				
		    // Проверка входит ли подстрока в строку - функцией возвращающей количество вхождений:
			if (mb_substr_count($str1,'ока','utf-8') > 0) echo "<br>Подстрока найдена.";
		?>
	</div>
	<div>     <h4> Получение подстроки </h4>
		<?php 		
		/* Универсальная функция substr() возвращает подстроку для указанной строки.
		   2-й аргумент: позиция старта в виде отступа слева (если +) или справа (если -)
		   3-й аргумент: задаёт конец в виде длины результата (если +) или отступа справа (если -)*/
		
		// В однобайтных кодировках:
			$strw2 = substr($strw1, 0, 4); // Начиная с 0 прочитать 4 символа 
		
		// В многобайтных кодировках:
			$str2 = mb_substr($str1, 0, 4, 'utf-8');    // То же самое, но в кодировке utf-8
			$str3 = mb_substr($str1, 9, null, 'utf-8'); // Если длина null, строка читается до конца
			$str4 = mb_substr($str1, -4, 4, 'utf-8');   // Начать, отступив справа 4 символа
			$str5 = mb_substr($str1, 9, -4, 'utf-8');   // Закончить перед 4-м символом с конца
			// Прямо указать позицию конца можно выражением, отняв стартовую позицию:
			$str6 = mb_substr($str1, 9, (17-9), 'utf-8'); // Закончить 17-м символом 
			
				echo "Первые 4 символа строки CP1251: ".iconv('CP1251', 'utf-8', $strw2); 
				echo "<br>Первые 4 символа строки UTF-8: $str2";                         
				echo "<br>Строка без первых 9 символов: $str3";                         
				echo "<br>Последние 4 символа: $str4";                         
				echo "<br>Строка начиная с (9+1) и без последних 4-х символов: $str5";                         
				echo "<br>Строка с (9+1) по 17-й символ: $str6";                         

		?>
	</div>
	<div>     <h4> Сравнение строк </h4>
		<?php 		
		### СРАВНЕНИЕ СТРОК ПО КОДАМ СИМВОЛОВ ###
			// Для кодировки UTF-8 cправедливы следующие равенства:
			$b= "ежик"== "ежик" &&  // Строки равны, если все их символы совпадают
				"ежик" > "еж"   &&  // При совпадении символов более длинная строка - больше 
				"ежик" < "лис"  &&  // Если код 1-го неравного символа больше, то вся строка больше
				"ежик" > "Лис"  &&  // Коды строчных букв больше прописных
				"ёжик" > "лис"  &&  // Буква ё идёт после основного алфавита
				"Ёжик" < "Лис";     // Буква Ё идёт перед основным алфавитом
			echo "Результат сравнения строк по кодам символов: $b"; // 1
			// В других кодировках картина может отличаться
		
		### СРАВНЕНИЕ СТРОК ПО АЛФАВИТУ ### 
			// Для этого требуется включение модуля intl в php.ini 
			$c1 = collator_create( 'ru_RU' ); // Cоздание спец.объекта collator:
			$n1 = collator_compare( $c1, "лис", "лис" );   // == 0  для равных строк
			$n2 = collator_compare( $c1, "ежик", "лис" );  // == -1 если первая строка меньше
			$n3 = collator_compare( $c1, "ежик", "аист" ); // == 1 если первая строка больше
				echo "<br>Результат работы коллатора: $n1 $n2 $n3";
	
			// Справедливы следующие равенства:
        $b= collator_compare($c1,"ежик","Ежик") == -1 && // Строчная буква меньше такой же прописной
            collator_compare($c1,"Ежик","лис")  == -1 && // Алфавит идёт в порядке аАбБвВгГ и т.д.
            collator_compare($c1,"ёжик","лис")  == -1;   // Буквы ёЁ обрабатываются корректно
			echo "<br>Результат сравнения строк по алфавиту: $b"; // 1
		?>
	</div>
  </div> 
</div>

<div> <h2> ПРОЦЕДУРНОЕ ПРОГРАММИРОВАНИЕ </h2>

  <div>    <h3>  ФУНКЦИИ-ПРОЦЕДУРЫ </h3>
	<?php  /*     Функция   - это блок программы, который принимает на вход аргументы 
                и возвращает некое значение (или значения).
    Процедура - блок программы, которому могут передаваться или не передаваться на вход аргументы, 
                но который (в отличие от функции) не возвращает значения, а просто совершает некие 
                побочные действия (ввод/вывод, изменение значений глобальных переменных и т.д.).
    В PHP в качестве процедуры можно использовать функцию, которая не возвращает значения. */
  
    /* Объявление функции (допустимо в любом месте кода).
       После имени функции и круглых скобок задается блок операторов, являющийся телом функции: */
        function proc1() {  
             // Эта функция просто совершает побочное действие - выводит строку в документ:                               
            echo '<br>Выполняется процедура proc1';  
        }
    
	// Вызов функций без аргументов
        proc1(); // Вызов функции без аргументов
        proc2(); // Вызов функции можно делать до объявления функции 
	?> 		
  </div>   

  <div>    <h3>  ОБЛАСТЬ ВИДИМОСТИ ПЕРЕМЕННЫХ СПОСОБЫ ИНИЦИАЛИЗАЦИИ </h3>
	<?php   	  
        function proc2() { 
			/* При использовании переменной создаётся локальная переменная, 
			   а глобальная с этим же именем остаётся нетронутой:  */
			$str2="Локальная переменная";
				echo "<br>str2: $str2"; // Выведется локальное значение
			/* Ключевое слово global перед именем переменной указывает, что отныне 
			   нужно использовать глобальную переменную с этим именем, а не локальную: */
			global $str2;
				echo "<br>str2: $str2<br>"; // Выведется глобальное значение
			// Другой способ - использование коллекции GLOBALS, хранящей глобальные переменные:
				echo "<br>str2: ".$GLOBALS['str2']; // Выведется глобальное значение для str2
			
			
				
			$str2 = "Новое значение";       // Глобальную переменную можно перезаписать
		}
		echo "<br>Содержимое глобальной переменной str2 после вызова функции: $str2";

		### ПОВЕДЕНИЕ СТАТИЧЕСКИХ ПЕРЕМЕННЫХ В ФУНКЦИЯХ ###
		
        function proc3() { 
			$s1="Начальное значение"; // При каждом вызове функции переменная получает это значение
			static $s2="Начальное значение"; /* Эта инициализация сработает только на этапе 
			    компиляции и при последующих вызовах функции значение не перезапишется */
				echo "s1: $s1; s2: $s2"; 
			$s1 .= " + дополнение"; // Это присвоение бесполезно, т.к. нигде не сохранится
			$s2 .= " + дополнение"; // Новое значение s2 будет доступно при следующем вызове функции
		} 
        echo "<br> Первый вызов: "; proc3(); //	"Начальное значение" 	
        echo "<br> Второй вызов: "; proc3(); // "Начальное значение + дополнение" 	
        echo "<br> Третий вызов: "; proc3(); // "Начальное значение + дополнение + дополнение"
	?>
  </div>   

  <div>    <h3>  РАБОТА С АРГУМЕНТАМИ ФУНКЦИИ </h3>
	<?php   	  
	### ДОСТУП К НЕОБЪЯВЛЕННЫМ АРГУМЕНТАМ В ТЕЛЕ ФУНКЦИИ ###
	
		// Осуществляется через функцию func_get_arg()
        function proc4() { 
            echo "<br>Первые два полученных аргумента: ".func_get_arg(0)." и ".func_get_arg(1);  
		    echo "<br>Всего аргументов: ".func_num_args(); // Количество аргументов
		    $arr1 = func_get_args(); // Эта ф-я возвращает массив полученных аргументов
			echo "<br>Третий аргумент: ".$arr1[2]; 
        }

    ### ВЫЗОВ ФУНКЦИЙ С АРГУМЕНТАМИ ###
	
        /* В круглых скобках через запятую можно передать в функцию произвольное количество 
            аргументов, даже если они не были объявлены при объявлении функции: */
        proc1("Строка1", "Строка2", 15, true );
		proc4("А","Б","В");
	
	### РАБОТА С ИМЕНОВАННЫМИ АРГУМЕНТАМИ ###
	
        function proc5($width, $height) { /* Можно указать имена аргументов. 
                                            Они станут локальными переменными внутри функции */
            echo "<br>Ширина: $width; Высота: $height"; 
            $width = 75; /* Значение аргументов можно по неосторожности заменить на другое.
                Интерпретатор ошибки не покажет. Эту особенность можно использовать 
				для коррекции неправильных значений: */
            if ($height <= 0) $height = 0; 
			echo "<br>Новые ширина: $width; высота: $height"; 
        }
		proc5(3,-1); // Вызывать такую функцию можно передав не менее двух аргументов
		             // (меньшее число аргументов вызовет фатальную ошибку).
		
		function proc6($width=0, $height=0) { // Так можно задать значения по умолчанию
            echo "<br>Ширина: $width; Высота: $height"; 
		} // При наличии значений по умолчанию ф-ю можно вызывать с меньшим количеством аргументов: 
		proc6(7);  
	
	### ТИПИЗИРОВАННЫЕ АРГУМЕНТЫ ###
	
		/* В версиях PHP >= 7.0 можно указать тип аргумента (для надёжности). Вызов функции 
		   с аргументами которые автоматически не приводятся к указанному типу выдаёт ошибку: */
		function proc7(int $a, float $b, string $c, bool $d) { 
			echo "<br>Получены все 4 аргумента.";
		};  
		proc7("1",2,3,"*"); // Вызов корректен, так как работает автоматическое приведение типов
		/*Если в начале скрипта прописать директиву  declare(strict_types=1);   
		  то автоматическое приведение типов работать не будет и такой вызов выдаст ошибку*/
		
	### ПЕРЕДАЧА В ФУНКЦИЮ НЕ ЗНАЧЕНИЯ, А ССЫЛКИ НА ЗНАЧЕНИЕ ДРУГОЙ ПЕРЕМЕННОЙ ### 
	
		function proc8(&$a) {      // Для этого при объявлении аргумента нужно указать символ "&"
			$a .= " + дополнение"; // Это присвоение меняет значение глобальной переменной по ссылке
		}
		$str2 = "Изначальное значение";
		proc8($str2);  // Изменяем значение переменной str2
		echo "<br>Новое значение переменной str2: $str2"; // == "Изначальное значение + дополнение"
	?>
  </div> 
</div> 

<div> <h2> ФУНКЦИОНАЛЬНОЕ ПРОГРАММИРОВАНИЕ </h2>

  <div>    <h3> ВОЗВРАЩЕНИЕ ЗНАЧЕНИЙ И ССЫЛОК ИЗ ФУНКЦИИ </h3>
	<?php  /* ФП предполагает использование функций без взаимодействия с внешними переменными и без 
        произведения побочных действий. Все нужные данные передаются в функцию в виде аргументов и
        функция взаимодействует с внешним миром только путем возврата значений. */ 
		
        function summ_sqr($a, $b) { 
            return $a**2 + $b**2;  /* Возврат значения осуществляется ключевым словом return и 
                возвращаемым выражением после него (которое может быть произвольного типа). 
				После return компилятор прекращает выполнение тела функции.  */
            echo "Это сообщение не отобразится"; 
            return; /* Если указать return без возвращаемого выражения, то это аналогично директиве 
                break в цикле - будет прервано выполнение тела функции без возврата конкретного 
                значения (т.е. ведёт себя как процедура). */
        }
		echo "Сумма квадратов 2 и 3 равна: " . summ_sqr(2,3);  // 13
		
	### ВОЗВРАТ ТИПИЗИРОВАННОГО ЗНАЧЕНИЯ ###
			function summ_sqr_int($a, $b): int { // Через ":" задаётся тип возвращаемого значения
				return $a**2 + $b**2;  // Результат выражения будет приведён к типу int
			} // Аналогично типизированным аргументам при strict_types=1 вместо приведения - ошибка
			echo "<br>Целая часть суммы квадратов 2.5 и 3.5 равна: " . summ_sqr_int(2.5,3.5); // 18
			
			// Если перед названием типа поставить символ "?" то можно также возвращать NULL
			function sqrt2($a): ?float {   // Этот синтаксис работает в версиях PHP >= 7.1
				if ($a > 0) { return sqrt($a); }
					else { return NULL; }
			} // Эта функция выдаёт NULL, а не ошибку, если в аргументе по ошибке оказалась строка:
			echo "<br>При ошибочном аргументе возвращается : " . gettype(sqrt2("b")); 
			
		// Функция-процедура также возвращает null:
			function emptyFunc() {} 
				echo "<br>Пустая функция возвращает " . gettype(emptyFunc()); // NULL

	### ВОЗВРАТ ССЫЛКИ НА ЗНАЧЕНИЕ ###		
		    // https://www.php.net/manual/ru/language.references.return.php
			function &return_ref() { // Для этого нужен символ "&" перед именем функции
				$a = 1;	 return $a;
			}
			$i = &return_ref(); // При получении ссылки также нужно использовать символ &
				echo "<br>По ссылке получено значение: $i";  // 1
	
	?>
  </div>

  <div>    <h3> ЗАМЫКАНИЯ И ДРУГИЕ ОСОБЕННОСТИ РАБОТЫ С ФУНКЦИЯМИ </h3>
	<?php  				
				
	### ВЫЗОВ ФУНКЦИИ, ИМЯ КОТОРОЙ ХРАНИТСЯ В СТРОКОВОЙ ПЕРЕМЕННОЙ ###
	
		$f = "summ_sqr";  // Эта строка совпадает с именем функции summ_sqr()
		// Если после имени переменной указfть скобки () то будет вызвана функция с именем в строке:
			$i = $f(2,3);     // Равносильно выражению $i = summ_sqr(2,3);
		// function_exists() проверяет, существует ли функция, имя которой совпадает со строкой:
			if (function_exists($f)) echo "<br>Функция $f существует.";
		// is_callable() проверяет, может ли значение переменной быть вызвано в качестве функции:
			if (is_callable($f)) echo "<br>Функция $f может быть вызвана.";

    ### ОБЛАСТЬ ВИДИМОСТИ ФУНКЦИЙ ###
	
        { function localFunc1() {
		      function localFunc2() { echo "#";} // Эта функция создастся при вызове localFunc1
	      } 
	    } // Функция объявленная внутри блока {} или другой функции - видна снаружи 
		localFunc1(); // Вызов работает - будет создана функция localFunc2
		localFunc2(); // Если localFunc2() создана, то она видна на глобальном уровне 

    ### ПЕРЕДАЧА ФУНКЦИИ В КАЧЕСТВЕ АРГУМЕНТА ДРУГОЙ ФУНКЦИИ ###  
	
        function applyFunc3($f,$a,$b,$c){ // Объявление функции принимающей на вход другую функцию
            $x = $f($a,$b); // В этом примере к аргументам a,b,c попарно применяется функция f
            return $f($x,$c);
        }
        function sum($a,$b) { // Функция сложения, используемая для передачи в качестве аргумента
            return $a + $b;
        }
		// При вызове имя функции нужно передавать в виде строки:
        $i = applyFunc3("sum", 2, 3, 4); // К числам применяется функция сложения
        echo "<br>Результат применения функции sum к числам: $i"; // i == 9

    ### АНОНИМНЫЕ ФУНКЦИИ (ЗАМЫКАНИЯ) ###
	   
	    /* https://www.php.net/manual/ru/functions.anonymous.php 
	      Это функции которые объявляются прямо там где используются без указания имени.
	      Такие функции замыкают на себя (хранят) своё лексическое окружение (переменные и т.п.), 
		  поэтому называются замыканиями */
        
        // К числам применяется функция умножения, созданная на лету:
			$i = applyFunc3( function($a,$b){return $a*$b;}, 2, 3, 4 ); 
			echo "<br>Результат применения анонимной функции умножения к числам: $i"; //  24
        
        // Анонимную функцию можно создать, обернув её объявление в скобки:
			(function($s){
				echo "<br>Удвоенная строка: $s$s";
			}) ("АБВГД");  // Выведется "АБВГДАБВГД"
		
		// Анонимную функцию можно записать в переменную (в отличие от именованных функций):
			$doubleStr = function($s) { return $s.$s; };
			echo "<br>" . $doubleStr("Чау");  // "ЧауЧау"
			echo "<br>" . $doubleStr(123);    // "123123"
	?>
  </div>   
  
</div>

<div> <h2> ОРГАНИЗАЦИЯ ЛОГИКИ ПРОГРАММЫ </h2>
 
  <div>    <h3> ВЕТВЛЕНИЯ В ЛОГИКЕ ПРОГРАММЫ </h3>
	<?php  $bool1 = true;	  
	
	### УСЛОВИЕ С ОДНОЙ ВЕТВЬЮ ###
		if ($bool1) echo 'Yes';
		// Запись в несколько строк:
		if (!$bool1) {
			echo 'No';
		}
	### УСЛОВИЕ С ДВУМЯ ВЕТВЯМИ ###
		if ($bool1) echo 'Yes'; 
			else echo 'No';
		// Запись в несколько строк:
		if ($bool1) {
			echo 'Yes'; 
		} else {
			echo 'No';
		}

	###  МНОЖЕСТВЕННЫЙ ВЫБОР МЕЖДУ НЕСКОЛЬКИМИ УСЛОВИЯМИ ###
		if        ($numb2 == 0)  { $j = 0; 
		} else if ($numb2 < 10)  { $j = 2; // Можно после else поставить if,
		} elseif  ($numb2 < 100) { $j = 5; // а можно использовать ключевое слово elseif
		} else                   { $j = 10;
		}
		
	###  АЛЬТЕРНАТИВНЫЙ СИНТАКСИС БЕЗ ФИГУРНЫХ СКОБОК ###
		/* https://www.php.net/manual/ru/control-structures.alternative-syntax.php
		  Такой синтаксис поддерживается и в циклах. Удобен для перемежания PHP-кода с HTML */
		  
		if ($bool1):   					// Перед выполняемыми инструкциями ставится символ ":"
			?> <p>HTML-код 1</p> <?php  // Фигурные скобки не используются,
		elseif ($bool2): 				// их заменяет следующее ключевое слово ветвления
			?> <p>HTML-код 2</p> <?php
		else:
			?> <p>HTML-код 3</p> <?php
		endif;           				// В конце конструкции ставится ключевое слово endif

	### СРАВНЕНИЕ ПО ОБРАЗЦУ ###
         
	    $i = 2;
        switch($i) {    // В скобках задается выражение, для сравнения с приведением типов
            case  1:    // Директива case действует аналогично оператору if (i == 1)
                $j='а';  /* От двоеточия до следующего case перечисляются инструкции, 
                          которые выполнятся в случае истинности сравнения */
                break;  // Если директива break выполнится, то она прервёт работу блока switch.
            case  2: $j='б'; break; /* Поскольку i===2 эта инструкция будет выполнена и работа всего 
                                     блока switch закончится (присутсвует break) */
            case  3: $j='в'; break; // Эту и последующие строки интерпретатор пропустит
            case  4: $j='д'; break;
            default: $j='_';        /* Если бы ни один образец не совпал, то сработают инструкции 
                                     заданные после директивы default */
        }  
        echo "<br>Числу $i соответствует буква $j"; // j == "б"

        /* Если break не указать, то будут выполнены все остальные инструкции блока БЕЗ СРАВНЕНИЙ 
           с образцами. Т.е. в этом случае конструкция switch действует как переход по метке  */
        $j="";
        switch($i) {     
           case 1: $j.='а'; // i!==1 и значит инструкция не выполнится
           case 2: $j.='б'; // i===2, инструкция выполнится и отключится режим сравнения с образцами
           case 3: $j.='в'; // Все интсрукции выполнятся, т.к. сравнение больше не производится
           case 4: $j.='д'; // Директиву default можно опускать
        }                    
        echo "<br>Начиная с числа $i идет набор букв $j"; // j == "бвд"
		
		// Альтернативный синтаксис без {} использует в конце конструкции слово endswitch;
		
	### ТЕРНАРНАЯ УСЛОВНАЯ ОПЕРАЦИЯ ###
        /* https://www.php.net/manual/ru/language.operators.comparison.php
		   Это операция, возвращающая свой второй или третий операнд 
           в зависимости от значения логического выражения, заданного первым операндом. */
        $bool1 = ($numb1 > 10) ? true : false; // Формат записи:    условие ? значение1 : значение2
        $bool1 = $numb1 > 10 ? true : false;   // То же без скобок (у оператора ? низкий приоритет)
        
		/* В отличие от JS в PHP цепочка тернарных может вычисляться неочевидно, поэтому важно 
		   обрамлять каждое тернарное выражение дополнительными скобками (начиная справа).  */
		$numb2 = 5;
        $j =  $numb2 == 0  ? 0 :
             ($numb2 < 10  ? 2 :
             ($numb2 < 100 ? 5 :
                            10)) ;	
        echo "<br>Числу $numb2 соответсвует число $j"; 
		
	?>
  </div>   

  <div>    <h3> БЕЗУСЛОВНЫЕ УПРАВЛЯЮЩИЕ КОММАНДЫ </h3>
	<?php  // https://www.php.net/manual/ru/control-structures.goto.php 	  
	
	### БЕЗУСЛОВНЫЙ ПЕРЕХОД К ИМЕНОВАННОЙ МЕТКЕ В КОДЕ ###
        $i = 2;
		goto label1; // Переход к метке с указанным именем
        $i = 3;      // Этот оператор не будет выполнен
        label1:      // Именованная метка
        echo "<br>Произошёл переход по метке, i == $i"; // i == 2
	?>
  </div>   
  
  <div>    <h3> ЦИКЛЫ </h3>
	<?php  

    ### ЦИКЛ СО СЧЁТЧИКОМ ###
        $str1 = "";
        // В этом примере на каждой итерации счётчик увеличивается на 1 в порядке возрастания:
        for ($i=1; $i<10; $i++) // (начало; условие; шаг) 
            $str1 .= "$i "; 
        
        for (; $i>0; ) // Операторы в условии цикла можно оставлять пустыми  
            $str1 .= $i-- ." "; 
        echo "<br>Счет от 1 до 10 и обратно: $str1";
            
        $factorial1 = 1;
        // Если в теле цикла несколько операторов, то они заключаются в логический блок {} :
        for ($i=2; $i<=5; $i++) { 
            $factorial1 = $factorial1 * $i; 
            echo "<br>$i! = $factorial1";
        }

    ### ВЛОЖЕННЫЙ ЦИКЛ СО СЧЁТЧИКОМ ###
        echo '<br>Таблица сложения:'; 
        for ($i=1; $i<=5; $i++) {
            $str1 = "";
            for ($j=1; $j<=5; $j++) {
                $str1 .= $i+$j . ' '; 
            }
            echo "<br>$str1";
        }
        echo "<br>После выполнения циклов значения счётчиков сохраняются: i == $i и j == $j";

    ### ЦИКЛ С ПРЕДУСЛОВИЕМ ###
        $i = 12;
        while ($i < 90) { // Удваиваем число если оно меньше 90
            $i *= 2;
        }
        echo "<br>Цикл с предусловием окончен. i == $i"; // 96

    ### ЦИКЛ С ПОСТУСЛОВИЕМ ###
        $i = 12;
        do {
            $i /= 3;   
		} while ($i > 10); // Уменьшаем число в 3 раза пока не преодолеем порог меньше 10
        echo "<br>Цикл с постусловием окончен. i == $i"; // 4

    ### ПЕРЕРЫВАНИЕ РАБОТЫ ЦИКЛА ###
        for (;;$i++) { // При таком условии цикл будет повторяться вечно, если его не прервать
            if ($i % 2 == 0) continue; // Переход на следующую итерацию текущего цикла
            if ($i > 30) break; // Выход из текущего цикла
        }
        echo "<br>Вечный цикл окончен. i == $i"; //31

        // С помощью break сделаем таблицу сложения треугольной:
        echo "<br>Нечетные строки треугольной таблицы сложения:"; 
        for ($i=1; $i<=5; $i++) { 
            $str1 = "";
            for ($j=1; $j<=5; $j++) {
                if ($j>$i) break;          // Выход из текущего цикла 
                if ($i%2 == 0) continue 2; // Переход на следующий шаг цикла 2-го уровня (внешнего)
                $str1 .= $i+$j.' ';
            }    
            echo "<br>$str1";
        } 
	?>
  </div>   
  
  <div>    <h3> РЕКУРСИЯ </h3>
	<?php // В PHP рекурсие имеет ограничение - не более 200 итераций
    
	### РЕКУРСИЯ С ВЕТВЛЕНИЕМ ПО УСЛОВИЮ ###
        function factorial($n){  // Вычисление факториала от n
            if ($n==0) return 1; /* else можно не писать, поскольку в случае n==0 на этой строке 
                                   функция завершит работу  */
            return $n * factorial($n-1); 
        }
        echo "10! = " . factorial(10); //  == 3628800

        function summNatural($n){  // Сумма натуральных чисел от 1 до n
            return $n ? $n + summNatural($n-1) : $n;  // Тернарный оператор ? делает код компактнее
        }
        echo "<br>1 + .. + 10 = " . summNatural(10); //  == 55

   ### РЕКУРСИЯ ЧЕРЕЗ МНОЖЕСТВЕННЫЙ ВЫБОР ##
        function factorial2($n){    /* Эта версия функции корректно обрабатывает всё что 
                                       не является положительным числом, возвращая NaN   */
            return $n > 199 ? INF :        // Для запредельных значений сразу возвращаем Infinity
                  ($n > 0   ? $n * factorial2($n-1) : // Цепочка ??? проверяет несколько условий.
                  ($n === 0 ? 1   : 
				              NaN)); 
        }
        echo "<br>10! = " . factorial2(10); //  == 3628800

    ### РЕКУРСИЯ СО ВСПОМОГАТЕЛЬНОЙ ФУНКЦИЕЙ ДЛЯ ХРАНЕНИЯ ПРОМЕЖУТОЧНОГО ЗНАЧЕНИЯ ###
		
		function prime($n) { // Функция проверки простое ли число (даёт true или false)
           return $n>0 ? prime_($n,2) : NaN; /* Для положительного числа запускаем вспомогательную 
                                              функцию проверки кандидатов на делители начиная с 2 */
        }  
		// Вспомогательная функция - аргумент m хранит число, до которого проверили:
        function prime_($n,$m) {  
            return $m*$m > $n ? true  : // Все кандидаты на делители проверены - возвращаем true 
                  ($n%$m == 0 ? false : // Делитель найден - возвращаем false
                   prime_($n,$m+1)); // Рекурсивный вызов проверки следующего кандидата на делителя
            };
			
    ### РЕКУРСИЯ СО ВСПОМОГАТЕЛЬНОЙ ВЛОЖЕННОЙ ФУНКЦИЕЙ  ###

		/* Вложенная вспомогательная функция полезна, чтобы не засорять пространство имён функций. 
		   Поскольку PHP делает видимыми вложенные функции снаружи, то такая функция должна быть 
		   анонимной и храниться в переменной - иначе функция не только будет видна, но и при втором 
		   вызове основной функции выведется ошибка о попытке объявить вложенную функцию повторно.
		   И опять проблема: внешние переменные не видны в анонимных функциях. А это значит что для 
		   того чтобы функция могла рекурсивно вызвать саму себя нужно эту переменную  
		   подключить к функции ключевым словом use (с указанием ссылки на значение переменной). */

		function prime2($n) { 
            $pr_ = function($n,$m) use (&$pr_) {  
                return $m*$m > $n ? true  : 
                      ($n%$m == 0 ? false : 
                      $pr_($n,$m+1)); 
            };
            return $n > 0 ? $pr_($n,2) : NaN;
        }  
        $str1='';
        for ($i=2; $i<128; $i++)   // Формируем список простых чисел в цикле
            if (prime($i)) $str1 .= " " . $i . " ";   
        echo "<br>Простые числа: $str1";
 	
	?>
  </div>   

  <div>    <h3> ПЕРЕХВАТ ИСКЛЮЧЕНИЙ И ОШИБОК ВЫПОЛНЕНИЯ </h3>
	<?php   /*  http://phpfaq.ru/debug/error_reporting
		        https://www.php.net/manual/ru/language.errors.php
		        https://habr.com/ru/post/100137/      
			    https://prowebmastering.ru/exception-php.html
            */
		// Символ @ перед выражением подавляет вывод нефатальных ошибок и предупреждений
		   @ $n = 1/0; // Сообщение "Warning: Division by zero" не отобразится
		   if(0){ // Целочисленное (а не вещественное) деление на ноль выдаёт фатальную ошибку
				@$n = intdiv(1,0); // Это выражение приводит к остановке работы скрипта
		   } // Сообщение "Warning: Division by zero" не отобразится
	
    ### ПРОСТАЯ ОБРАБОТКА ОШИБОК, ВЫЯВЛЯЕМЫХ ИНТЕРПРЕТАТОРОМ ###

        try { // Конструкция try…catch позволяет перехватывать исключения и часть фатальных ошибок
            $n = intdiv(1,0); // Фатальная ошибка
			echo "Это сообщение не будет отображено"; // После ошибки код в блоке не выполняется
		} catch (Throwable $t) {  // Перехват ошибок в версии PHP 7 и выше
			echo '<br>Ошибка PHP7: '.  $t->getMessage();
		} catch (Exception $e) {  // Перехват исключений в PHP 5 и выше
			echo '<br>Исключение: '.  $e->getMessage();
        } // В блоке finally - завершающие действия, которые выполняются в любом случае:
		  finally { echo '<br>Выполнение блока закончилось.'; } 
	
    ### ПРИНУДИТЕЛЬНАЯ ГЕНЕРАЦИЯ ИСКЛЮЧЕНИЯ ОПЕРАТОРОМ THROW ###
	
        $i=200;
        try { // throw вызывается в связке с функциями SyntaxError, ReferenceError, RangeError и пр.
            if ($i > 100)  throw new Exception("Число больше допустимого.");
        } catch(Exception $e) {
			echo '<br>Исключение: '.  $e->getMessage();
        }

    ### ИЗБИРАТЕЛЬНАЯ ОБРАБОТКА ИСКЛЮЧЕНИЙ ###
	
        function checkNumb($a) {
            try { // Для ошибки диаппазона используем подкласс исключений - RangeException
                if ($a > 100) throw new RangeException("Число больше допустимого.");
				// Другую ошибку значения генерируем с обычным классом
                if ($a % 10 != 0) throw new Exception("Число не кратно 10.");
            } catch(RangeException $e) { // Ловим только исключения класса RangeException
				echo '<br>Исключение внутри функции checkNumb: '.  $e->getMessage();
        }}
        
        try { // В функции обрабатываются ошибки диаппазона, а в этом блоке - все остальные ошибки
            checkNumb(150);  // Пробуем вызвать функцию проверки числа
        } catch(Exception $e) { // Поймали другую ошибку, отличную от ошибки диаппазона
            echo "<br>Ошибка checkNumb: ". $e->getMessage(); 
        }
	
	###	ПРОБРОС ИСКЛЮЧЕНИЯ С ЦЕЛЬЮ ОБРАБОТКИ УРОВНЕМ ВЫШЕ ##

        function checkNumb2($a) {
            try { // Генерируем разыне исключения (вторым аргументом можно указать свой код ошибки):
                if ($a > 100) throw new Exception("Число больше допустимого.",1);
                if ($a % 10 != 0) throw new Exception("Число не кратно 10.",2);
            } catch(Exception $e) { // Ловим исключение и отправляем его дальше, , как 3-й аргмент
				throw new Exception("Ошибка checkNumb2: ",0,$e); // Новое звено в цепочке исключений
		}}
        
        try { // В функции ошибки диаппазона НЕ обрабатываются, их нужно обработать в этом блоке
            checkNumb2(55);  // Пробуем вызвать функцию проверки  числа
        } catch(Exception $e) { // Тут обрабатываются все исключения:
          echo "<br>Ошибка вызова checkNumb2 : ". $e->getMessage(). 
				   "Код ошибки " . $e->getPrevious()->getCode(). // Доступ к предыдущему исключению
				   ". Текст: "   . $e->getPrevious()->getMessage(); 
        }
	?>
  </div>   

  <div>    <h3> ДИНАМИЧЕСКОЕ СОЗДАНИЕ КОДА И ДАННЫХ </h3>
	<?php 

        ### СОЗДАНИЕ ПЕРЕМЕННОЙ В ЗАВИСИМОСТИ ОТ УСЛОВИЯ ###
            if (true) { $condiVar = "Новый текст"; }
			if (isset($condiVar)) // Проверка того что переменная создана прежде обращения к ней
				echo "Условие выполнилось и создана переменная с содержимым: $condiVar"; 

        ### СОЗДАНИЕ ФУНКЦИИ В ЗАВИСИМОСТИ ОТ УСЛОВИЯ ###
            if (true) { 
                function condiFunc(){ 
				    echo '<br>Условие выполнилось и создана функция condiFunc.'; 
			}} 
            // Проверка того что функция создана перед ее вызовом (иначе - Fatal error):
            if (function_exists("condiFunc")) condiFunc(); 

		### ГЕНЕРАЦИЯ КОДА ИЗ ТЕКСТОВОЙ СТРОКИ ###
			// Можно создать код и поместить его в переменную
            $str1 = "{ echo '<br>Выполняется сгенерированный код'; }";  
            eval($str1); // Небезопасная функция eval вполняет код переданный в текстовой строке 
	?>
  </div>   
  
</div>

<div> <h2> СОСТАВНЫЕ СТРУКТУРЫ ДАННЫХ </h2>
 
  <div>    <h3> ДИНАМИЧЕСКИЕ НЕТИПИЗИРОВАННЫЕ МАССИВЫ </h3>
	<div>     <h4> Создание массивов. Чтение и запись элементов. </h4>
	  <!-- https://www.php.net/manual/ru/language.types.array.php
		   В PHP массивы являются ассоциативными, т.е. элементы являются парой (ключ, значение) -->
	<?php	

    ### СОЗДАНИЕ МАССИВОВ ###
        $arr1 = [];  // Пустой массив
        $arr1 = array(); // Альтернативная запись, совместимая со старыми версиями PHP
		
		### СОЗДАНИЕ ИНДЕКСИРОВАННОГО МАССИВА ###
			// В PHP индексированные массивы эмулируются ассоциативными массивами
			$arr1 = [ 
				0 => "ноль",  // Создастся два элемента с индексами 0,1 и значениями в виде текста
				1 => "один"
			];
			$arr1 = ["ноль","один"]; // То же сокращённо. Числовые индексы добавятся автоматически
			$arr1 = [3 => "три","четыре","пять"]; // У этого массива индекс начинается с 3
			$arr2 = ["А", "Б", 456, 12.5, true];  // Создание массива с разнотипными элементами
			$arr2b = [1, "Б", [5,6,7]];  // Элементами могут быть массивы и объекты
		
		### СОЗДАНИЕ АССОЦИАТИВНОГО МАССИВА ###
			$arr3 = [ // Ключи могут быть либо целыми числами, либо строками
				"Ключ 1" => "Значение 1", 
				      23 => "Значение", // Можно смешивать ключи разных типов
				"Ключ 2" => "Значение 2", 
				      -5 => "Значение", // Допустимо отрицательное число для ключа
				     7.5 => "Значение", // Ключ станет == 7 т.к. другие типы приводятся к integer
				     "8" => "Значение", // Ключ == 8 (строка с целым числом приводится к integer)
				// Если ключ не указан, то ему присвоится индекс = (максимальный индекс + 1)
				            "Значение"  // Ключ станет == 9 
			];
			
	### ЧТЕНИЕ И ЗАПИСЬ ИНДЕКСИРОВАННЫХ ЭЛЕМЕНТОВ ###
        $k = $arr2[0]; // Считать первый элемент массива (нумерация элементов - с нуля)
        $k = $arr2{0}; // Альтернативный синтаксис - использование фигурных скобок
		// Несуществующие и неинициализированные элементы - это неинициализированные переменные
        if (!isset($arr2[5])) echo "Элемент не существует или неинициализирован.";
        $arr2[2] = "Новое значение"; // Записать данные в элемент с индексом 2
        $arr1[5] = "А"; /* Можно записать данные в ячейку с индексом, выходящим за "границы" массива,
                           то максимальный индекс станет равным указанному числу */
		// Если ключ не указан, то ему присвоится индекс = (максимальный индекс + 1)
		$arr1[] = "Б";  // Присвоен индекс 6
        unset($arr1[5]); // Удаление элемента без переиндексации массива

	### ЧТЕНИЕ И ЗАПИСЬ ЛЮБЫХ ЭЛЕМЕНТОВ ###
		$k = $arr3["Ключ 1"]; // Считать элемент с указанным текстовым ключём
		$arr3["Ключ"] = "Новое значение"; // Записать в элемент новое значение
		// В выражении, заключённом в кавычки, значение ключа следует указывать без кавычек:
			echo "<br>В элементе с ключём 'Ключ' хранится: $arr3[Ключ]";
		// Но если ключ содержит пробелы, то следует использовать сложный синтаксис фигурных скобок:
			echo "<br>В элементе с ключём 'Ключ 1' хранится: {$arr3["Ключ 1"]}";
		unset($arr3["Ключ"]); // Удаление элемента 
		

	### КОЛИЧЕСТВО ЭЛЕМЕНТОВ И ДЛИНА МАССИВА ###
		// Количество элементов массива можно узнать функцией count()
		$arr1 = [0,1,2,3,4,5];
		echo "<br>Количество элементов массива: ". count($arr1); // 6
		unset($arr1[3]); 
		echo "<br>Количество элементов после удаления элемента: ". count($arr1);  // 5
		echo "<br>При этом индексы остались от 0 до 5. 5-й элемент == $arr1[5]";  // 5
		/* Если элементы массива являются массивами или объектами, то можно подсчитать количество
           элементов рекурсивно, указав второй параметр COUNT_RECURSIVE (или 1) */
		count($arr2b,COUNT_RECURSIVE);
		
	    /* Поскольку в PHP массивы ассоциативные и неупорядоченные, то длина массива может быть 
		   определена только условно - как разница между максимальным и минимальным индексами.
		   Для нахождения этих крайних индексов можно использовать функцию array_keys(), 
		   которая возвращает массив из всех ключей входного массива: */
			$numb1 = 1 + ( max(array_keys($arr1)) - min(array_keys($arr1)) );
			echo "<br>Длина массива: " . $numb1; 
	
	### ПЕРЕБОР ЭЛЕМЕНТОВ МАССИВА ###
		// https://www.php.net/manual/ru/control-structures.foreach.php
		echo "<br>Все значения массива: ";
		foreach ($arr1 as $value) echo "$value, "; // Доступ к значениям для чтения
		echo "<br>Все ключи и значения массива: ";
		foreach ($arr1 as $key => $value) echo "$key => $value, "; // Доступ в т.ч. к ключам
		
		// Для доступа к элементам для записи, нужно обращаться к ним по ссылке:
		foreach ($arr1 as &$value) { $value = $value * 2; }
		unset($value); // Важно удалить ссылку, иначе она продолжит ссылаться на последний элемент
			echo "<br>Все значения изменённого массива: ";
			foreach ($arr1 as $value) echo "$value, "; 
		
		// Индексированные элементы можно перебрать такой конструкцией:
		echo "<br>Все индексированные значения массива: ";
		unset($arr1[2]); // Удалим элемент, чтобы продемонстрировать что цикл сработает и без него
		for ($i=min(array_keys($arr1)); $i<=max(array_keys($arr1)); $i++) {
			// Поскольку могут быть удалённые элементы, индексы нужно проверять на существование:
			if (array_key_exists($i,$arr1)) echo $arr1[$i].", ";		
		}
		
    ### МНОГОМЕРНЫЕ МАССИВЫ ###
        // Создание двухмерного массива
        $tableSum = [    // Двухмерный массив таблица сложения
            [0,1,2],    
            [1,2,3],
            [2,3,4] ];  // Первые три элемента созданы массивами

        $b = $tableSum[2][2] == 4;  // Обращение к элементу многомерного массива 
                 
        // 4-мерный массив хранения пикселей движущейся голограммы размером 10x10x10
        $holo3d = [];
        for ($i=0; $i < 10; $i++) {
            $holo3d[$i] = [];  // Создание двумерного массива путём добавления ячеек-массивов
            for ($j=0; $j < 10; $j++) {
                $holo3d[$i][$j] = []; // Создание трехмерного массива
                for ($k=0; $k < 10; $k++) {
                    $holo3d[$i][$j][$k] = []; // Создание 4x-мерного массива
        }   }   }
        $holo3d[3][1][7][2] = 80; // Запись значения в созданный 4x-мерный массив;
	?>
	</div>
	<div>     <h4> Методы вставки и выемки элементов массива с перестройкой индекса </h4>
	<?php	
        // Реализация стека
        $arr1[] = 15; // Добавить значение 15 в конец массива
		$i = array_push($arr1,7,8,9); // Добавить несколько элементов. i == новая длина массива.
        $k = array_pop($arr1); // Вынуть последний элемент массива, возвратив его значение.
        
        // Реализация очереди. Дополнительно используются медленные операции с началом массива:
        $i = array_unshift($arr1,7,8,9); // Вставить элементы в начало массива. i == новая длина 
        $k = array_shift($arr1); // Вынуть первый элемент массива, возвратив его значение. 

        // Универсальная функция splice может вынимать и вставлять элементы в любом месте массива.
            $arr1 = [0,1,2,3,4,5,6,7,8,9];
			/* Вынуть все элементы начиная с указанного смещения от начала массива и вернуть их 
		  	   в виде нового массива. При этом смещение не является индексом и отсчитывает в том 
			   числе и строковые ключи: */
			$k = array_splice($arr1,9); 
				echo "Содержимое вынутого подмассива: "; print_r($k); // 9
			$k = array_splice($arr1,-1); // Отрицательный индекс указывает отступ с конца массива:
				echo "<br>Вынут последний элемент: "; print_r($k);  

            // Третьим аргументом можно указать количество вынимаемых элементов (длину фрагмента):
			$k = array_splice($arr1,0,2);   
				echo "<br>Вынуты первые два элемента: "; print_r($k); // 0,1
			$k = array_splice($arr1,1,0);   
				echo "<br>При нулевом третьем аргументе возвращается пустой массив: "; print_r($k);
				// Отрицательное число задаёт для вынимаего фрагмента отступ справа от конца массива
			$k = array_splice($arr1,2,-2);   
				echo "<br>Вынуты все элементы кроме двух первых и двух последних: "; print_r($k);
            
            // В четвёртом аргументе - вставляемый элемент или массив вставляемых элементов:
            array_splice($arr1,1,0,5); // Вставить без удаления начиная с позиции 1 значение 5
            array_splice($arr1,1,3,[7,8]); // На позиции 1 удалить 3 элемента и вставить числа 7,8
            echo "<br>Массив arr1 после всех операций splice: "; print_r($arr1); // 2,7,8,7 
	?>
	</div>	
	<div>     <h4> Методы обработки групп элементов </h4>
	<?php	
	### Копирование участков массива в новый массив без изменения исходного массива ###
		// Функция slice работает аналогично splice, но исходный массив остаётся нетронутым:
        $arr1a = array_slice($arr1,0); // Полное копирование массива
        
		// Если указать четвёртый аргумент true, то индексы в новом массиве не будут перестроены: 
        $arr1a = array_slice($arr1,1,-1); // Скопировать массив кроме первого и последнего элемента
		echo "Обычный результат копирования (с перестроенными индексами): "; print_r($arr1a); 
        $arr1a = array_slice($arr1,1,-1,true); // Скопировать так же, но индексы не перестраивать
		echo "<br>Результат копирования без перестройки индексов: "; print_r($arr1a); 

    ### Склейка индексированных массивов ###
		$arr1 = [5=>1,2,"b"=>1]; 
		$arr2 = [   3,4,"b"=>2];
		
		/* Добавить второй массив к первому и возвратить в виде нового массива. Все индексированные 
		элементы будут перенумерованы, а элементы с равными текстовыми ключами - перезаписаны : */
		$arr3 = array_merge($arr1,$arr2);
		echo "<br>Результат склейки массивов: "; print_r($arr3); 

    ### Сложение (дополнение и синхронизация) ассоциативных массивов ###
		
		// Добавить второй массив к первому БЕЗ ЗАМЕНЫ элементов и без переиндексации ключей.
		$arr3 = $arr1 + $arr2;
		echo "<br>Результат дополнения массивов: "; print_r($arr3); 

		// Добавить второй массив к первому С ЗАМЕНОЙ элементов и без переиндексации ключей.
		$arr3 = array_replace($arr1,$arr2);
		echo "<br>Результат дополнения массивов с заменой: "; print_r($arr3); 

    ### Приведение значений массива к строке ###
		// Функция возвращает строку из элементов массива, разделённых символами в первом аргументе:
		$str2 = implode(" ;",$arr2);
		echo "<br>Содержимое массива arr2: $str2"; 
    
	### Приведение строки к индексированному массиву (парсинг) ###
		// Функция возвращает массив строк, полученный разбиением строки указанным разделителем:
		$arr2b = explode(" ;",$str2);
			echo "<br>Обычный парсинг строки: "; print_r($arr2b); // 3, 4, 2
		/* Третий аргумент - конечное число элементов в массиве. При достижении этого лимита
		   в послений элемента массива будет помещена оставшаяся часть строки : */
		$arr2b = explode(" ;",$str2,2); 
			echo "<br>Парсинг строки в два элемента: "; print_r($arr2b); // 3, "4 ;2"
		// Отрицательный лимит задаёт итоговое количество элементов равное (максимум - limit)
		$arr2b = explode(" ;",$str2,-1); // Спарсить все элементы кроме последнего
			echo "<br>Парсинг строки  без последнего элемента: "; print_r($arr2b); // 3, 4

    ### Сортировка элементов массива на месте (без создания нового массива) ###
        // https://www.php.net/manual/ru/array.sorting.php
		
		### Сортировка индексированных массивов ###
			$arr1 = [2=>2,3,5,7,11,13,17,"A"=>"W"];
		
		// Эти функции удалят все ключи, с последующим присвоением новых целочисленных индексов:
		shuffle($arr1); // Функция sort случайным образом перемешивает элементы
			echo "<br>Перемешивание с переиндексацией: "; print_r($arr1); 
		sort($arr1); // Сортировка в порядке возрастания
			echo "<br>Сортировка с переиндексацией: "; print_r($arr1); // W,2,3,5,7,11,13,17
		rsort($arr1); // Сортировка в порядке убывания
			echo "<br>Обратная сортировка: "; print_r($arr1); // 17,13,11,7,5,3,2,W

        /* Для сортировки по пользовательскому критерию нужно создать функцию сравнения, 
		   которая возвращает положительное или отрицательное ЦЕЛОЕ число:  */
			function compareNumbs($a, $b) { // Функция сравнения
			    if ($a == $b) return 0;    
				return ($a < $b) ? -1 : 1;  // Вернет -1 если a < b и +1 если a > b
			}
		// Функция usort сортирует массив с переданной во втором аргументе функцией сравнения:
		usort($arr1, "compareNumbs");
			echo "<br>Пользовательская сортировка: "; print_r($arr1); // W,2,3,5,7,11,13,17

		### Сортировка ассоциативных массивов ###
			$arr1 = [1=>"a",3=>"б",2=>"в"];
		
		// Эти функции сохраняют связь ключ-значение:
		asort($arr1); // Сортировка по значению в порядке возрастания
			echo "<br>Сортировка по значению: "; print_r($arr1); //  1=>a, 3=>б, 2=>в 
		arsort($arr1); // Сортировка по значению в порядке убывания
			echo "<br>Обратная по значению: "; print_r($arr1);   //  2=>в, 3=>б, 1=>a
		ksort($arr1); // Сортировка по ключу в порядке возрастания
			echo "<br>Сортировка по ключу: "; print_r($arr1);    //  1=>a, 2=>в, 3=>б
		krsort($arr1); // Сортировка по ключу в порядке возрастания
			echo "<br>Обратная по ключу: "; print_r($arr1);      //  3=>б, 2=>в, 1=>a

		// Функция uasort сортирует массив с переданной во втором аргументе функцией сравнения:
		uasort($arr1, "compareNumbs"); // Сортирока по значению
			echo "<br>Пользовательская по значению: "; print_r($arr1); // 1=>a, 3=>б, 2=>в 
 		uksort($arr1, "compareNumbs"); // Сортировка по ключу
			echo "<br>Пользовательская по ключу: "; print_r($arr1);    // 1=>a, 2=>в, 3=>б
       
    ### Инверсия массива на месте (изменение порядка элементов на обратный) ###
        $arr1rev = array_reverse($arr1); // С переиндексацией целочисленных ключей
			echo "<br>Инверсия индексированного массива: "; print_r($arr1rev); // 0=>б, 1=>в, 2=>а
        $arr1rev = array_reverse($arr1,true); // С сохранением связей ключ-значение
			echo "<br>Инверсия ассоциативного массива: "; print_r($arr1rev);   // 3=>б, 2=>в, 1=>а
	
	### Поиск по массиву ###
		/* Функция array_search ищет значение (указанное в первом аргументе) в массиве (переданном
		   во втором аргументе). Если значение не найдено, то возвращается FALSE */ 
		$i = array_search("в",$arr1);  // Возратит ключ для элемента, у которого значение ==  "в"
		$i = array_search("в",$arr1,TRUE);                 // Строгое сравнение, значение === "в"
			echo "<br>Значение 'в' хранится в элементе с ключом $i";  // 2
		// Функция in_array проверяет наличие значения в массиве, возвращая TRUE или FALSE:
		if (in_array("в",$arr1))      echo "<br>Значение 'в' найдено при нестрогом сравнении";
		if (in_array("в",$arr1,TRUE)) echo "<br>Значение 'в' найдено при строгом сравнении";
		// Функция array_key_exists проверяет наличие ключа в массиве, возвращая TRUE или FALSE:
		if (array_key_exists(2,$arr1)) echo "<br>Ключ 2 найден";
	?>
	</div>	
	<div>     <h4> Применение функций к элементам массива: </h4>
	<?php
	### Перебор элементов массива с вызовом функции для каждого (альтернатива циклу foreach) ###
		echo "<br> Содержимое архива: ";
		// Функция array_walk () применяет к массиву функцию их второго аргумента:
		array_walk($arr1, function($value, $key, $userVar){ // Функции передаётся значение и ключ 
			echo "[$key: $value]" . $userVar; 
		}, ", "); // Третьий аргумент userVar опциональный. Тут им передём строку-разделитель
	
	### Фильтрация элементов массива ###
		/* Функция array_filter() возвращает массив из элементов входного массива, для которых 
		   фильтрующая функция (во втором аргументе) возвращает TRUE. */
		$arr1a = array_filter($arr1, function($val,$key) {
			return ($key & 1); // Проверка ключа элемента на нечётность
		}, ARRAY_FILTER_USE_BOTH); /* Если третий аргумент не равен нулю либо задана эта константа, 
		                         то помимо значения в функцию будет передаваться и ключ элемента */
		echo "<br>Элементы с нечётными индексами: "; print_r($arr1a); 

    ### Трансформация массива ( или создание нового массива,      ###
	### в котором к каждому элементу применена указанная функция) ###
		$arr1a = array_map(function($elem){ 
			return $elem.$elem; // Удваиваем строку
		}, $arr1);
		echo "<br>Массив с удвоенными строками: "; print_r($arr1a); 
		
		// В функцию array_map() можно передавать не один массив, а несколько:
		$arr1b = array_map(function($elem1,$elem2){ 
			return $elem1."|".$elem2; // Конкатенируем значения элементов
		}, $arr1, $arr1a);
		echo "<br>Результат соединения элементов из двух массивов: "; print_r($arr1b); 
		
		### Zip-операция - создание массива, каждый элемент которого   ### 
		### является массивом из элементов входящих массивов           ###
			$arr1b = array_map(NULL, $arr1, $arr1a); // Если вместо функции NULL - массивы зипуются
			echo "<br>Результат zip-операции с массивами: "; print_r($arr1b); 

    ### Свёртка массива (рекурсивное применение функции к элементам с накопительным параметром) ###
        $k = array_reduce($arr1, function($concat,$elem){
            return $concat . "|" . $elem; // Конкатенируем значения элементов
        }, "!"); // Второй аргумент необязательный, указывает начальное значение накопителя
        echo "<br>Склеенные слева направо элементы массива arr1: $k"; 

	?>
	</div>	
 </div>   

</div>

<div> <h2> ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ </h2>

  <div>    <h3> КЛАССЫ И ОБЪЕКТЫ </h3>
	
	<div>     <h4> Создание классов и объектов. </h4>
	  <!-- https://www.php.net/language.oop5 -->
	<?php	

		/* Класс - это шаблон для создания объектов в котором объявляются константы, 
		   переменные (свойства класса) и функции (методы класса). 
		   Константы, свойства и методы задаются в одном из трёх вариантов их области видимости:
				public - общедоступные 
				protected - доступ только из самого класса, классов-потомков и классов-предков 
				private   - доступ только из самого класса */
		
		### Объявление пустого класса ### 
			class EmptyClass {} // Для удобства имена классов называют с заглавной буквы
		
		### Создание пустого объекта (на основе класса) ###
			$obj1 = new EmptyClass(); // Создан экземпляр класса EmptyClass
			$className = "EmptyClass";
			$obj2 = new $className(); // Подстановка имени класса в виде переменной тоже работает
			echo "<br>Объекты: "; print_r($obj1);  print_r($obj2);
		
		### Объявление констант класса ###  
			class Class1 { // Константы доступны в версиях PHP 7.1+
				public    const CON1 = 1;   
				protected const CON2 = 2;
				private   const CON3 = 3;
			}
		
		### Объявление свойств класса ###
			class Class2 { 
				public    $numb1 = 5;   
				protected $numb2 = 6, $numb2b = 0; // Можно задать несколько свойств через запятую
				private   $numb3 = 7;
			}
		
		### Объявление методов класса ###
			class ClassHello { 
				public    function showHello1() { echo "<br>Hello"; } 
				protected function showHello2() { echo "<br>Hello"; } 
				private   function showHello3() { echo "<br>Hello"; } 
			}
	?>
	</div>
	<div>     <h4> Использование объектов. </h4>
	  <!-- https://www.php.net/language.oop5 -->
	<?php	
		
		### Копирование ссылки на объект ###
			// https://evilinside.ru/kopirovanie-obektov-v-php/
			$obj1 = new EmptyClass(); // В значении переменной сохранена ссылка на объект
			$obj2 = $obj1; // Создано новое значение (новый контейнер), хранящее такую же ссылку
			$obj3 = &$obj1; // $obj3 ссылается на существующий контейнер со ссылкой

			### Сравнение ссылок на объект ###
			if ($obj1 == $obj2) echo "<br>Переменные obj1 и obj2 ссылаются на один объект.";
			if ($obj2 == $obj3) echo "<br>Переменные obj2 и obj3 ссылаются на один объект.";

			### Проверка существования объекта ###
			if (gettype($obj1) == "object") echo "<br>Объект существует.";
		
			### Поведение копий ссылок на объект при их обнулении ###
			$obj3 = null; // Обнуление значения obj3 стирает ссылку в контейнере и у obj1.
			$b = is_null($obj1)             &&  
				 gettype($obj2) == "object" && // Контейнер obj2 остался нетронутым
				 is_null($obj3);
			echo "<br>Результат проверки ссылок на объект: $b"; // 1

		### Доступ к публичным константам ###
			$n = Class1::CON1; // Константа хранится в классе - общая для всех объектов класса
				echo "<br>Костанта CON1 == $n";
			$className = "Class1"; 
			$n = $className::CON1; // Альтернативный способ через переменную, хранящую имя класса
			$n = Class1::class; // Встроенная константа class хранит полное имя класса
				echo "<br>Костанта class == $n";
			
		### Доступ к публичным свойствам ###
			$obj2 = new Class2();
			$obj2->numb1 = 15; // Запись в свойство
			$n = $obj2->numb1; // Чтение публичного свойства		
				echo "<br>Свойство numb1 == $n";
			$propName = "numb1";
			$n = $obj2->$propName; // Альтернативный способ - через переменную хранящую имя свойства		
		
		### Вызов публичного метода ###
			$obj1 = new ClassHello();
			$obj1->showHello1(); // Защищённые и приватные методы так вызывать нельзя
			$methodName = "showHello1";
			$obj1->$methodName(); // Альтернативный вызов через переменную, хранящую имя метода

		### Доступ к константам класса текущего объекта из метода объекта ###
		class ClassCon1 { 
			public const CON1 = 5;
			public function showCon1() {  
				echo "<br>Константа CON1: " . self::comment; 
			} // Ключевое слово self указывает на класс объекта, в контексте которого вызван метод
		}
		
		### Доступ к свойствам текущего объекта из метода объекта ###
		class Comment1 { 
			public $comment = 5;
			public function showComment() {  
				echo "<br>Свойство comment: " . $this->comment; 
			} // Ключевое слово this указывает на объект, в контексте которого вызван метод
		}


	?>
	</div>
	<div>     <h4> Преобразование объектов в примитивные типы. </h4>
	<?php	
		### Строковое преобразование (производится там где ожидается получение строки) ###
		
        /* Для того чтобы объект автоматически преобразовывался к строке, в нем необходимо объявить
           специальный магический метод __toString(), который будет возвращать строку. Магическими 
		   называются такие методы, которые автоматически запускаются в определённых ситуациях.
		   __toString() срабатывает когда объект используется в выражении, где ожидается строка	*/

			class PixelStr { 
				public $x = 3, $y = 4;
				public function __toString() { 
					return "Координаты точки: ". $this->x ." и ". $this->y;
			}}
			$pixel1 = new PixelStr();
			echo "<br>Объект pixel1 при строковом преобразовании возвращает строку: $pixel1";
		
		### Получение имени класса в виде строки ###
			echo "<br>Объект pixel1 принадлежит к классу ". get_class($pixel1);

		### Логическое преобразование (производится там где ожидается получение boolean) ###
			if ($pixel1) {echo "<br>Объект существует!";} // Объекты преобразуются к TRUE
	?>
	</div>
	<div>     <h4> Сериализация объектов. </h4>
	<?php	
		### Простая сериализация объекта "как есть" ###
			$str1 = serialize($pixel1);   // Сохраняются в строку свойства и имя класса объекта
			$str2 = json_encode($pixel1); // В формат JSON. Сохраняются только свойства
			echo "<br>Объект в сериализированном виде: $str1";
			echo "<br>Объект в формате JSON: $str2";
			$pixel1a = unserialize($str1); // Обратная операция - создаётся объект того же класса
				echo "<br>Восстановленный объект: "; print_r($pixel1a);  
			$pixel1b = json_decode($str2); // Декодирование JSON создаёт объект типа stdClass
				echo "<br>Восстановленный из JSON объект: "; print_r($pixel1b);
		
		### Выборочная сериализация "как есть" ###
			/* Объявленный магический метод __sleep() автоматически вызывается перед процессом 
			   сериализации и возвращает массив с именами свойств, которые надо сериализовать. */
			class Pixel3dSleep { 
				public $x = 3, $y = 4, $z = 5;
				public function __sleep() {	return ['y','z']; } // Имена свойств для сериализации
			}
			$pixel1 = new Pixel3dSleep();
			$pixel1->x = 6; $pixel1->y = 7; $pixel1->z = 8; // Меняем значения свойств
			$str1 = serialize($pixel1);    // Сохранились только свойства y и z
			$pixel1b = unserialize($str1); // Восстанавливаем 
				echo "<br>Восстановленный объект: "; print_r($pixel1b);  // x == 3, а не 6

		### Пользовательская сериализация - с преобразованием значений  ###
			/* В PHP 7.3 и ниже доступна только для формата JSON. При этом нужно указать, 
			   что класс реализует интерфейс JsonSerializable */
			class VcardSerial implements JsonSerializable { 
				public $name ="", $age = 0, $phone = 0;
				/* Для JSON-сериализации отдельных свойств должна быть объявлена функция 
				   jsonSerialize() которая возвращает массив, который должен быть сериализован */
				public function jsonSerialize() {  
					return [ 'name' => $this->name,
							 'age'  => $this->age . " лет" ];  // К значению добавлена строка
			}}
			$str2 = json_encode($vcard1); // Сериализуется массив, возвращённый jsonSerialize()
			$vcard1b = json_decode($str2);
				echo "<br>Восстановленный из JSON объект: "; print_r($vcard1b); 

	?>
	</div>

  </div>   

</div>

<div> <h2> *** </h2>
 
  <div>    <h3> *** </h3>
	<?php   	  
	?>
  </div>   
</div>

<div> <h2> *** </h2>
 
  <div>    <h3> *** </h3>
	<?php   	  
	?>
  </div>   
</div>


</body>
</html>

