> ### [Democode-гид по Laravel](./README.md)

# Уровень 1. Добавление логики реагирования на веб-запросы

## Лирическое введение

Когда на сайте есть только несколько десятков фиксированных ссылок, ведущих на те или иные страницы, то здесь нет особого места каким-либо алгоритмам. Собственно говоря, даже использование фреймворка тут может быть излишним - ведь можно просто создать нужные HTML-документы и расположить их в соответсвующих папках на сервере.

Но как только появляется необходимость получить от пользователя сайта какую-то информацию, то возникают вопросы: во первых, как это сделать, а во вторых, каким образом и в какой части серверного кода эту информацию лучше обрабатывать. Освещению этих тем и посвящён уровень 1 нашего гида.

## Создание маршрутов получения информации от пользователя

### Обработка параметров запроса

#### Получение GET-параметров

В PHP cамый стандартный и старый способ передачи каких-то значений через веб-запросы - это использование GET-параметров в адресной строке. Для этого сразу после URL ставится знак `?` и перечисляются имена параметров с их значениями после знака `=`. Несколько параметров разделяются знаком `&`. Например для страницы поиска можно в адресную строку добавить параметры c именами `s_string` (строка поиска) и `lang` (язык). Выглядеть это будет так: http://127.0.0.1:8000/search/?s_string=тест&lang=ru

Чтобы получить параметры из этого запроса в замыкании маршрута или в контроллере нужно предварительно объявить использование класса Request:

>⇩⇩⇩ `routes\web.php` ⇩⇩⇩

```php
	use Illuminate\Http\Request;
```

Теперь можно создать маршрут, а в качестве параметра в замыкании указать объект класса Request. В этом случае сработает система автоматического внедрения зависимостей Laravel. В частности произойдёт следующее:

1. Фреймфорк увидит, что в функцию или метод должен быть передан какой-то объект.
2. Определит имя класса для этого объекта.
3. Создаст экземпляр этого класса (т.е. создаст объект).
4. В случае, если это Request-объект - автоматически заполнит все его свойства данными из веб-запроса.

Получив внутри функции автоматически оформленный Request-объект, мы можем воспользоваться его методом `query()` для получения значений нужных GET-параметров. Для этого в первый аргумент метода нужно написать имя GET-параметра - и метод возвратит его значение. На случай, если вдруг окажется что такого GET-парметра нет в веб-запросе, можно вторым аргументом передать в метод значение по умолчанию, которое метод и возвратит в случае неудачи:
```php
    Route::get('/search', function (Request $request) {
        return 'Ищем текст ' . $request->query('s_string') .
               ' на языке ' . $request->query('lang','ru');
    });
```

В качестве альтернативы можно обойтись без внедрения зависимости и подключения класса, а использовать глобальную функцию-хелпер `request()`. Вызванная без аргумента, она возвращает Request-объект - экземпляр рекущего запроса. С одной стороны это проще, с другой - снижает читаемость кода и затрудняет внедрение тестов:
```php
    Route::get('/search2', function () {
        return 'Ищем текст ' . request()->query('s_string') .
               ' на языке ' . request()->query('lang','ru');
    });
```

Вызов `query()` без аргументов возвратит массив всех GET-параметров:

```php
    Route::get('/search3', function () {
        $s = 'Все GET-параметры запроса: ';
        foreach ( request()->query() as $key=>$value ) 
            $s .= "$key => $value | ";
        return $s;
    });
```
#### Получение URL-параметров

Более удобный и красивый способ - передавать параметры внутри URL. Обычно их принято разделять наклонной чертой (другие символы допустимы, но не практичны). Для того чтобы иметь возможность выудить параметры из URL, нужно в строке-образце для URI указывать имена этих параметров в фигурных скобках.  При этом имена переменных функции не имеют значения, важен только их порядок, т.к. именно в порядке расположения внутри URL эти параметры будут переданы в функцию:

```php
    Route::get('/cat/{cat_name}/page/{page_number}', function (string $n, $m) {
        return 'Запрошена страница ' . $m . ' для категории ' . $n;
    });
```

Знак вопроса после имени параметра означает, что он необязателен. В этом случае у колбэк-функции соответствующие аргументы тоже должны быть  необязательными (т.е. с заданными значениями по-умолчанию). В этом примере параметры передаются в методы контроллера, а они в свою очередь выдают ответ в виде списка полученных параметров:

```php
	use App\Http\Controllers\ParamController; // Подключаем класс контоллера
	Route::get('showpar/{par1}/{par2?}/{par3?}', [ParamController::class, 'showParams']);
```

```php
	Route::get('showallpar/{par1}/{par2?}/{par3?}', [ParamController::class, 'showAllParams']);
```

Разумеется, в самом контроллере нужно прописать вызываемые методы-колбэки.

Колбэк, принимающий в обработку три URL-параметра из веб-запроса. Второй и третий параметры не обязательны - если они не будут переданы в запросе, то подставятся значения по умолчанию:

>⇩⇩⇩ `app\Http\Controllers\ParamController.php` ⇩⇩⇩

```php
    public function showParams($param1, $param2='', $param3='') {
        return ' Параметр 1 = ' . $param1 .
               ' Параметр 2 = ' . $param2 .
               ' Параметр 3 = ' . $param3;
    }
```

Если помимо URL-параметров нужны GET-параметры, и их хочется получить не просто через хелпер `request()`, а через внедрение зависимости в виде Request-объекта, то эту зависимость нужно указать в первом аргументе функции:

```php
    public function showAllParams(Request $request,
                                  $param1, $param2='', $param3='') {
        $s = 'Все GET-параметры запроса: ';
        foreach ( $request->query() as $key=>$value )
            $s .= "$key => $value | ";

        return $s . '<br> URL-параметры: ' .
               ' Параметр 1 = ' . $param1 .
               ' Параметр 2 = ' . $param2 .
               ' Параметр 3 = ' . $param3;
    }
```

#### Проверка URL-параметров на допустимый формат

Чтобы внутри колбэк-функции не проверять допустимость значения полученного параметра можно воспользоваться для этого методами самого route-объекта. Метод `where()` сверяет значение параметра с регулярным выражением и меняет статус route-объекта на "отвергаемый" в случае несовпадения:

>⇩⇩⇩ `routes\web.php` ⇩⇩⇩

```php
    Route::get('/nametest/{nameLatin}', function ($name) {
        return 'Имя ' . $name . 'корректно, т.к. написано латинницей.';
    })->where('name', '[A-Za-z]+');
```

Для нескольких параметров можно выстраивать цепочки из методов сверки, либо в один метод передавать ассоциативный массив соответствий:

```php
    Route::get('/adress/{streetName}/{homeNumber}', function ($x, $y) {
        return 'Адрес ' . $x . ' ' . $y . ' корректен';
    })->where('streetName', '[A-Za-zА-Яа-я]+')->where('homeNumber', '[0-9]+');

	Route::get('/adress2/{streetName}/{homeNumber}', function ($x, $y) {
        return 'Адрес ' . $x . ' ' . $y . ' корректен';
    })->where(['streetName' => '[A-Za-zА-Яа-я]+', 
               'homeNumber' => '[0-9]+'         ]);
```

Методы `whereNumber()`, `whereAlpha()`, `whereAlphaNumeric()`, `whereUuid()` позволяют проверить сразу несколько параметров на то, содержат ли они соответсвенно только цифры, только латинские буквы, только латинские буквы и цифры, только корректный идентификатор UUID:

```php
    Route::get('/coord/{x}/{y}/{z}', function (string $x, $y, $z) {
        return 'Все три координаты корректны, т.к. записаны цифрами';
    })->whereNumber(['x','y','z']);
```

### Фильтрация маршрутов по HTTP-методу запроса

Получение данных от пользователя может приходить не только через GET-запросы, но и через POST, PUT и пр. Использовавшийся нами ранее метод `get()` не среагирует на POST-запрос. Для обработки всех типов запросов в Laravel предусмотрены следущие инструменты.

Отбор запросов конкретного типа делается одноимённым route-методом. Вот их полный список:

```php
    Route::get('/get-hi', function () { return 'hi'; });
    Route::post('/post-hi', function () { return 'hi'; });
    Route::put('/put-hi', function () { return 'hi'; });
    Route::patch('/patch-hi', function () { return 'hi'; });
    Route::delete('/delete-hi', function () { return 'hi'; });
    Route::options('/options-hi', function () { return 'hi'; });
```

Если нужны сразу два и более типа, то полезен route-метод `match()`,       который принимает на вход массив из названий этих типов запроса:

```php
	Route::match(['get', 'post'], '/get-post-hi', function () { return 'hi'; });
```

Принять сразу все типы HTTP-запросов можно route-методом `any()`:

```php
	Route::any('/any-hi', function () { return 'hi'; });
```
