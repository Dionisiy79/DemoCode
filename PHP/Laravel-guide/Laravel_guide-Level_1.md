> ### [Democode-гид по Laravel](./README.md)

# Уровень 1. Добавление логики реагирования на веб-запросы

>**Что нужно предварительно знать:**
>1. [Создание простых страниц в Laravel (уровень 0 этого гида)](./Laravel_guide-Level_0.md)
>2. Основы использования регулярных выражений.
>3. Основы создания HTML-форм.

## Лирическое введение

Когда на сайте есть только несколько десятков фиксированных ссылок, ведущих на те или иные страницы, то здесь нет особого места каким-либо алгоритмам. Собственно говоря, даже использование фреймворка тут может быть излишним - ведь можно просто создать нужные HTML-документы и расположить их в соответсвующих папках на сервере.

Но как только появляется необходимость получить от пользователя сайта какую-то информацию, то возникают вопросы: во первых, как это сделать, а во вторых, каким образом и в какой части серверного кода эту информацию лучше обрабатывать. Освещению этих тем и посвящён уровень 1 нашего гида.

## Создание маршрутов получения информации от пользователя

### Параметры в строке HTTP-запроса

#### Получение GET-параметров

В PHP cамый стандартный и старый способ передачи каких-то значений через веб-запросы - это использование GET-параметров в адресной строке. Для этого в строке HTTP-запроса сразу после URL ставится знак `?` и перечисляются имена параметров с их значениями в формате `имя=значение`, разделяя эти пары символом `&`. Например для страницы поиска можно в адресную строку добавить параметры c именами `s_string` (строка поиска) и `lang` (язык). Выглядеть это будет так: http://127.0.0.1:8000/search/?s_string=тест&lang=ru

Чтобы получить параметры из этого запроса в замыкании маршрута или в контроллере нужно предварительно объявить использование класса Request:

>⇩⇩⇩ `routes\web.php` ⇩⇩⇩

```php
	use Illuminate\Http\Request;
```

Теперь можно создать маршрут, а в качестве параметра в замыкании указать объект класса Request. В этом случае сработает система автоматического внедрения зависимостей Laravel. В частности произойдёт следующее:

1. Фреймфорк увидит, что в функцию или метод должен быть передан какой-то объект.
2. Определит имя класса для этого объекта.
3. Создаст экземпляр этого класса (т.е. создаст объект).
4. В случае, если это Request-объект - автоматически заполнит все его свойства данными из веб-запроса.

Получив внутри функции автоматически оформленный Request-объект, мы можем воспользоваться его методом `query()` для получения значений нужных GET-параметров. Для этого в первый аргумент метода нужно написать имя GET-параметра - и метод возвратит его значение. На случай, если вдруг окажется что такого GET-парметра нет в веб-запросе, можно вторым аргументом передать в метод значение по умолчанию, которое метод и возвратит в случае неудачи:
```php
    Route::get('/search', function (Request $request) {
        return 'Ищем текст "' . $request->query('s_string') .
               '" на языке ' . $request->query('lang','ru');
    })->name('level1_search');
```

В качестве альтернативы можно обойтись без внедрения зависимости и подключения класса, а использовать глобальную функцию-хелпер `request()`. Вызванная без аргумента, она возвращает Request-объект - экземпляр рекущего запроса. С одной стороны это проще, с другой - снижает читаемость кода и затрудняет внедрение тестов:
```php
    Route::get('/search2', function () {
        return 'Ищем текст "' . request()->query('s_string') .
               '" на языке ' . request()->query('lang','ru');
    });
```

Вызов `query()` без аргументов возвратит массив всех GET-параметров:

```php
    Route::get('/search3', function () {
        $s = 'Все GET-параметры запроса: ';
        foreach ( request()->query() as $key=>$value ) 
            $s .= "$key => $value | ";
        return $s;
    })->name('level1_allGetParams');
```
#### Получение параметров маршрута

Более удобный и красивый способ - передавать параметры внутри URL, объявляя их при создании маршрута. Для этого имена параметров обрамлюятся фигурными скобками и отделяются наклонной чертой (другие символы допустимы, но не практичны). В колбэк-функцию эти параметры передаются в виде аргументов. При этом имена аргументов не имеют значения (т.е. не обязаны совпадать с именами параметров маршрута) - важен только их порядок, т.к. именно в порядке расположения внутри URL эти параметры будут переданы в функцию:

```php
    Route::get('/cat/{cat_name}/page/{page_number}', function ($n, $m) {
        return 'Запрошена страница ' . $m . ' для категории ' . $n;
    });
```

Знак вопроса после имени параметра означает, что он необязателен. В этом случае у колбэк-функции соответствующие аргументы тоже должны быть необязательными (т.е. с заданными значениями по-умолчанию). В этом примере параметры передаются в методы контроллера, а они в свою очередь выдают ответ в виде списка полученных параметров:

```php
	use App\Http\Controllers\ParamController; // Подключаем класс контоллера
	Route::get('showpar/{par1}/{par2?}/{par3?}', 
	           [ParamController::class, 'showParams'])
		   ->name('level1_showParams');

	Route::get('showallpar/{par1}/{par2?}/{par3?}', 
	           [ParamController::class, 'showAllParams'])
		   ->name('level1_showAllParams');
```

Разумеется, в самом контроллере нужно прописать вызываемые методы-колбэки.

Колбэк, принимающий в обработку три параметра маршрута из HTTP-запроса. Второй и третий параметры не обязательны - если они не будут переданы в запросе, то подставятся значения по умолчанию:

>⇩⇩⇩ `app\Http\Controllers\ParamController.php` ⇩⇩⇩

```php
    public function showParams($param1, $param2='', $param3='') {
        return ' Параметр 1 = ' . $param1 .
               ' Параметр 2 = ' . $param2 .
               ' Параметр 3 = ' . $param3;
    }
```

Если помимо параметров маршрута нужно обрабатывать GET-параметры и их хочется получить не просто через хелпер `request()`, а через внедрение зависимости в виде Request-объекта, то в аргументах функции эта и другие зависимости должна стоять перед URL-параметрами маршрута:

```php
    public function showAllParams(Request $request,
                                  $param1, $param2='', $param3='') {
        $s = 'Все GET-параметры запроса: ';
        foreach ( $request->query() as $key=>$value )
            $s .= "$key => $value | ";

        return $s . '<br> URL-параметры: ' .
               ' Параметр 1 = ' . $param1 .
               ' Параметр 2 = ' . $param2 .
               ' Параметр 3 = ' . $param3;
    }
```

#### Проверка параметров маршрута на допустимый формат

Чтобы внутри колбэк-функции не проверять допустимость значения полученного параметра, можно воспользоваться методами самого route-объекта. Метод `where()` сверяет значение параметра с регулярным выражением и меняет статус route-объекта на "отвергаемый" в случае несовпадения:

>⇩⇩⇩ `routes\web.php` ⇩⇩⇩

```php
    Route::get('/nametest/{nameLatin}', function ($name) {
        return 'Имя ' . $name . 'корректно, т.к. написано латинницей.';
    })->where('name', '[A-Za-z]+');
```

Для нескольких параметров можно выстраивать цепочки из методов сверки, либо в один метод передавать ассоциативный массив соответствий:

```php
    Route::get('/adress/{streetName}/{homeNumber}', function ($x, $y) {
        return 'Адрес ' . $x . ' ' . $y . ' корректен';
    })->where('streetName', '[A-Za-zА-Яа-я]+')->where('homeNumber', '[0-9]+');

	Route::get('/adress2/{streetName}/{homeNumber}', function ($x, $y) {
        return 'Адрес ' . $x . ' ' . $y . ' корректен';
    })->where(['streetName' => '[A-Za-zА-Яа-я]+', 
               'homeNumber' => '[0-9]+'         ]);
```

Методы `whereNumber()`, `whereAlpha()`, `whereAlphaNumeric()`, `whereUuid()` позволяют проверить сразу несколько параметров на то, содержат ли они соответсвенно только цифры, только латинские буквы, только латинские буквы и цифры, только корректный идентификатор UUID:

```php
    Route::get('/coord/{x}/{y}/{z}', function (string $x, $y, $z) {
        return 'Все три координаты корректны, т.к. записаны цифрами';
    })->whereNumber(['x','y','z']);
```

Можно задать глобальные ограничения - чтобы не дублировать метод `where()` в серии похожих маршрутов. Для этого в таких маршрутах нужно указать параметр с одинаковым именем, а описание ограничений на его значения вынести в файл фреймворка `app\Providers\RouteServiceProvider.php` внутрь метода `boot()`, например, в таком виде: `Route::pattern('homeNumber', '[0-9]+');` Теперь если в маршруте встречается параметр `homeNumber`, то маршрут будет срабатывать только если он удовлетворет глобальному ограничению, заданному в методе `pattern()`.

##### Особенности использования косой черты в значениях параметров

Через GET-параметры можно спокойно передавать символы `/` и `\`. А вот в параметрах маршрута символ `/` по умолчанию считается разделителем между сегментами маршрута и не учитывается при считывании значений параметров. Стоит отметить, что при ручном вводе в строке браузера он обратную косую черту `\` внутри URL (но не в GET-параметрах) автоматически меняет на прямую `/`, и получается, что при сверке с адресом маршрута этот символ тоже не учитывается. Избежать этой автоподмены можно, если вместо символа `\` написать его unicode-эквивалент `%5C`. А вот при генерации ссылок програмно проблемы не возникает, т.к. Laravel сразу подставляет в адресную строку комбинацию `%5C`.

Остаётся вопрос с самим символом `/`. При создании объектов-маршрутов по умолчанию ко всем параметрам маршрута негласно применяется метод `->where('param', '[^\/]*')`, предписывающий принимать все допустимые в URL символы кроме косой черты `/`. Но если всё-таки хочется иметь возможность передать через параметр маршрута в т.ч. этот символ `/`, то можно переопределить метод `where()`, задав в нём регулярное выражение, допускающее использование этого символа. Например, напишем маршрут, который умеет прямо в параметре маршрута получать любой текст, включая числовую дробь. Здесь регулярное выражение `.*` даёт указание включить в значение параметра `anytext` все символы (включая разделительные) до конца URL (т.е. до знака `?` при наличии  GET-параметров):

```php
    Route::get('/fraction/{anytext}', function ($n) {
        return 'Получено выражение: ' . $n; 
    })->name('level1_fraction')->where('anytext', '.*');
```

Очевидно, что такое регулярное выражение можно написать только в случае, если параметр маршрута стоит в последнем сегменте маршрута. Ведь если бы мы указали в маршруте два параметра, принимающие символы `/`, то всё содержимое с этими символами попало бы в значение первого парамера, а второй оказался бы пустым. Вот пример такого ошибочного маршрута:

```php
    Route::get('/bad_fractions/{anytext1}/{anytext2?}', function ($n,$m=0) {
        return 'Получены выражения: ' . $n  . " и " . $m;
    })->name('level1_bad_fractions')->where('anytext1', '.*')
                                    ->where('anytext2', '.*');
```

Обойти это ограничение можно, если в качесте разделителя сегмента маршрута указать какой-то другой символ, а сам этот другой символ указать как запрещённый в регулярном выражении. Исправим приведеный выше ошибочный маршрут, используя в качестве разделителя сегментов символ `-` и указав регулярное выражение `[^-]*` (т.е. любые символы кроме `-`):

```php
    Route::get('/fractions-{anytext1}-{anytext2}', function ($n,$m) {
        return 'Получены выражения: ' . $n  . " и " . $m; 
    })->name('level1_fractions')->where('anytext1', '[^-]*')
                                ->where('anytext2', '[^-]*'); 
```

#### Передача параметров при генерации URL-адресов

Для демонстрации созданных маршрутов создадим blade-шаблон в файле `resources\views\getParams.blade.php`, в котором разными способами покажем создание активных параметризированных ссылок на эти маршруты.

>⇩⇩⇩ `resources\views\getParams.blade.php` ⇩⇩⇩

```php
	<div>
    	<p> Приветсвуем Вас на странице getParamsDemo !!! </p>
    	<p> Здесь демонстрируются примеры передачи параметров в генерируемых строках HTTP-запросов. </p>
	</div>

```

##### Передача классических GET-параметров

На уровне 0 мы уже научились делать вот такие ссылки на именованные маршруты:
```php
	<a href="{{ route('level1_search') }}"> Ссылка без параметров  </a>
```

Чтобы с такой ссылкой передать GET-параметр, нужно вторым аргументом в функцию-хелпер `route()` передать массив с именами и значениями нужных параметров:
```php
	<a href="{{ route('level1_search',
                ['s_string' => 'тарарам', 'lang' => 'fr']) }}">
		Ссылка c GET-параметрами  </a>
```

Добавим интерактивности и создадим форму, которая будет отправлять такой же поисковый запрос, но только уже с данными, которые введёт пользователь:
```php
    <form action="{{ route('level1_search') }}" method="GET">
        <label>Строка для поиска: </label>
        <input name="s_string">
        <label>Язык: </label>
        <input name="lang">
        <input type="submit" value="Искать">
    </form>
```
Теперь в этой форме пользователь сможет задать произвольные значения для GET-параметров и после нажатия кнопки `Искать` браузер перейдёт на страницу поиска, добавив к адресной строке GET-параметры в классическом формате.

##### Передача параметров маршрута

Маршрутам, у которых есть собственные параметры внутри URL, при вызове функции `route()` нужно передавать все эти параметры - их значения будут подставлены в генерируемый URL - каждый на своё место согласно адресному шаблону маршрута:

```php
        <a href="{{ route('level1_cat_page',
                ['cat_name' => 'Новости', 'page_number' => 4]) }}">
            Ссылка c параметрами маршрута </a>
```

Если параметры маршрута объявлены как необязательные, то их можно не передавать:

```php
        <a href="{{ route('level1_showParams',
                ['par1' => 7, 'par2' => 8]) }}">
            Ссылка в которой один необязательный параметр не передан </a>
```

*Примечание: Существует возможность с помощью метода `URL::defaults` включить подстановку значений по умолчанию для параметров и получить возможность не обязательности их передачи в массиве. Этот вопрос будет рассмотрен в следующих уровнях, при изучении темы т.н. посредников маршрутов.*

Еcтественно, можно одновременно передавать и параметры маршрута, и дополнительные GET-параметры:

```php
    <a href="{{ route('level1_showAllParams',
            ['par1' => 9, 'par2' => 8,
             'par4' => 7, 'par5' => 6 ]) }}">
        Ссылка c параметрами маршрута и дополнительными GET-параметрами </a>
```

##### Демонстрация особенностей использования косой черты в параметрах маршрута

Любая косая черта вполне хорошо передаётся через GET-параметр:

```php
    <a href="{{ route('level1_search',
             ['s_string' => 'Косые черты / и \ получены']) }}">
        Рабочая ссылка c косыми чертами в GET-параметре  </a>
```

А вот в обычном параметре маршрута такое приведёт к ошибке 404 - URL будет не соответствовать маршруту:

```php
	<a href="{{ route('level1_showParams',
             ['par1' => 'А', 'par2' => 'Б', 'par3' => 'В/Г' ]) }}">
        Не рабочая ссылка c косыми чертами в параметре маршрута </a>
```

Изменение регулярного выражения для маршрута позволило принимать один параметр с символами косой черты:

```php
	<a href="{{ route('level1_fraction', ['anytext' => '3/4']) }}">
        Рабочая ссылка c числовой дробью в единственном параметре маршрута </a>
```

Попытка аналогичным образом использовать два параметра приводит к тому, что второй параметр оказывается с пустым значением, а предназначенная для него строка оказывается доавленной к строке первого параметра:

```php
    <a href="{{ route('level1_bad_fractions', ['anytext1' => '2/3',
                                               'anytext2' => '3/4']) }}">
        Ссылка на ошибочный маршрут с числовыми дробями в двух параметрах маршрута </a>
```

Использование другого символа в качестве разделителя сегментов маршрута позволяет добиться кореектной работы ссылки с косой чертой в обоих параметрах:

```php
    <a href="{{ route('level1_fractions', ['anytext1' => '2/3',
                                           'anytext2' => '3\4']) }}">
        Ссылка на корректный маршрут с чисовыми дробями в обоих параметрах маршрута </a>
```

### POST-запросы

#### Фильтрация маршрутов по HTTP-методу запроса

Получение данных от пользователя может приходить не только через GET-запросы, но и через POST, PUT и пр. Использовавшийся нами ранее метод `get()` не среагирует на POST-запрос. Для работы с разными видами запросов в Laravel предусмотрены следущие инструменты.

Отбор запросов конкретного типа делается одноимённым route-методом. Вот их полный список:

```php
    Route::get('/get-hi', function () { return 'hi'; });
    Route::post('/post-hi', function () { return 'hi'; });
    Route::put('/put-hi', function () { return 'hi'; });
    Route::patch('/patch-hi', function () { return 'hi'; });
    Route::delete('/delete-hi', function () { return 'hi'; });
    Route::options('/options-hi', function () { return 'hi'; });
```

Если нужны сразу два и более типа, то полезен route-метод `match()`,       который принимает на вход массив из названий этих типов запроса:

```php
	Route::match(['get', 'post'], '/get-post-hi', function () { return 'hi'; });
```

Принять сразу все типы HTTP-запросов можно route-методом `any()`:

```php
	Route::any('/any-hi', function () { return 'hi'; });
```
