<?php

/* Этот демонстрационный код нужно добавить в конец файла `.\routes\web.php`
   Для этого либо скопируйте его туда вручную, либо добавьте в него строку кода:
   
   require  base_path() . "/democode/level_0/routes-web_addon.php";
*/

#####################################
#             УРОВЕНЬ 0             #
#   Создание простейших маршрутов   #
#####################################

/* Первый практический шаг после установки Laravel - это создание нужных маршрутов в файле `.\routes\web.php`. Маршрут представляет из себя как бы правило, что нужно дальше делать серверу при получении URI-запроса.  Технически для этого с помощью методов (`get()`,`post()` и пр.) создаются объекты класса `Route` и помещаются в упорядоченную коллекцию. При создании такого объекта-маршрута в первом аргументе указывается адрес (URI) страницы сайта, а во втором - callback-функция (замыкание), возвращающая содержимое веб-страницы. При работе только со статическими страницами браузер посылает обычные GET-запросы, которые на данном этапе будем создавать преимущественно с помощью метода `get()`. 
*/

#------------------------------------------#
#   РАЗНОВИДНОСТИ НАПРАВЛЕНИЙ МАРШТРУТОВ   #
#------------------------------------------#

/* Используются следующие варианты: */

### 1. Вывод простого текста ###

    Route::get('/hello', function () { 
        return 'Hello World!';  
    }); // по адресу http://127.0.0.1:8000/hello появится текст `Hello World!`

### 2. Вывод ответа сервера с заголовком и/или кодом ответа ###

    Route::get('/hello-head', function () { 
        /* Объекты класса `Responce` обладают методом `header`, который 
           добавляет к ответу заголовок `<head>` */
        return response('Привет!') -> header('Content-Type', 'text/plain');  
    });

    // Вторым аргументом можно указать код ответа, отличный от 200:
    Route::get('/empty', function () { 
        return response('Здесь ничего нет.', 403);  
    });

    // Для пустых ответов может также пригодится response-метод `noContent()`:
    Route::get('/empty2', function () { 
        return response()->noContent();
    });
    

### 3. Вывод одного из представлений (view), заданного blade-шаблоном ###

    Route::get('/welcome_to_laravel', function () {
        return view('welcome');  
    }); /* По адресу http://127.0.0.1:8000/welcome_to_laravel отобразится 
           шаблон из файла `.\resources\views\welcome.blade.php` */
    
    // То же самое более компактно - через метод view класса Route
    Route::view('/welcome2_to_laravel', 'welcome'); 

### 4. Вызов одного из контроллеров с последующим ответом от него ###

    /* Колбэк-функцию можно и лучше делать не анонимной, а в виде метода объекта-контроллера. Поскольку мы пока не создали своих новых контроллеров, то новые методы можно прописать в единственном имеющемся контроллере (он находится в файле `.\app\Http\Controllers\Controller.php`). */

    Route::get('/ctrl-hello', ['App\Http\Controllers\Controller', 'showText']);

    /* Если подключить контроллер директивой `use`, то можно не писать 
       полный путь к нему, а через краткое имя обратиться к встроенной 
       константе `class`, хранящей полное имя класса: */
    use App\Http\Controllers\Controller;
    Route::get('/ctrl-hello2', [Controller::class, 'showText']);

### 5. Вызов контроллера с дальнейшим показом blade-шаблона ###

    Route::get('/ctrl-welcome', [Controller::class, 'showWelcome']);

### 6. Переадресация ###
    
    // Простой редирект с кодом возврата 302
    Route::redirect('/hi', '/hello'); 
    
    // Третьим параметром можно указать другой код возврата:
    Route::redirect('/hi2', '/hello', 301); 
    
    // Такой же код 301 возвращает метод `permanentRedirect`
    Route::permanentRedirect('/hi3', '/hello'); 
    
    /* Также переадресацию, скачивание файлов и много других вещей можно делать 
       с помощью специалных response-методов. Но всё это обычно прописыватся 
       внутри контроллеров, а не в самих маршрутах - а значит может считаться 
       различными вариантами ответов от контроллера. */

### 7. Запасной маршрут ###

    /* Если входящий запрос не соответствует ни одному из маршрутов, то 
       его можно обработать методом `fallback`, который направит запрос по 
       маршруту вместо ответа `404 - страница не найдена`. Логично что этот 
       маршрут указывается последним, т.к. он срабатывает безусловно: */
   
    if (0) {  // Отключим его работу, чтобы добавляемые ниже маршруты работали
        Route::fallback([Controller::class, 'showWelcome']);
    }

#--------------------------#
#   ИМЕНОВАННЫЕ МАРШРУТЫ   #
#--------------------------#

    /* Сами по себе маршруты создаются как безымянные объекты, доступные через
    коллекцию, в которой хранятся. Но есть возможность задавать им уникальные 
    имена и через эти имена обращаться напрямую к объектам-маршрутам: */
    
    Route::get('materials/page1', function () {
        return 'Это страница, на которую ведёт маршрут page1';
    })->name('page1'); // Метод `name()` задаёт маршруту имя
    
    /* Теперь, когда у маршрута есть имя, появляется возможность через имя 
    маршрута получить строку URL, на которую этот маршрут отзывается - а значит 
    это можно использовать для создания однозначно рабочей ссылки, связанной
    с этим именнованным маршрутом. 
    Такую ссылку в виде строки возвращает глобальная функция `route()`: */
    
    Route::get('where_is_page1', function () {
        $url = route('page1'); // В строке $url - URI маршрута 'page1'
        return 'Страница page1 находится по адресу: ' . $url;
    });
    
    /* Обратите внимание, что если мы в объявлении самого маршрута page1 произвольно изменим URI-адрес (в первом параметре метода `get()`), то по адресу http://127.0.0.1:8000/where_is_page1 отоброзится этот новый URL. Т.е. повсеместное применение функции `route()` при создании ссылок на страницы сайта позволяет в дальнейшем спокойно менять адреса страниц в файле маршрутов `routes\web.php` и не переживать, что где-то в другом месте приложения ссылки на эти страницы станут не рабочими. */

#----------------------------------------#
#   ПОЛУЧЕНИЕ ПОЛНОГО СПИСКА МАРШРУТОВ   #
#----------------------------------------#
    /* В процессе разработки приложения список маршрутов можно просматривать локально, выполнив в консоли команду `php artisan route:list`. Но также можно работать со списком и в самом приложении. Для этого есть метод `getRoutes()`, который возвращает коллекцию, в которой хранятся маршруты. Выведем список URI и соответвующие им контроллеры на странице http://127.0.0.1:8000/routes_list */
    
    Route::get('routes_list', function () {
        $routeCollection = Route::getRoutes(); // Получаем коллекцию маршрутов
        $str = '<br><br>'; // В цикле будем добавлять всю информацию в эту строку
        foreach ($routeCollection as $value) {
                $str = $str . $value->uri() . ' | ' . // Значение URI
                $value->getActionName() . '<br>'; // Имя контроллера и метод
        }
        return 'Список URI, контроллеров и методов для всех маршрутов: ' . $str;
    });
    
    