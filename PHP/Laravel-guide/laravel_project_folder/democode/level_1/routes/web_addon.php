<?php

/* 
    Этот демонстрационный код нужно добавить в конец файла `.\routes\web.php`
   Для этого либо скопируйте его туда вручную, либо добавьте в него строку кода:
   
   require  base_path() . "/democode/level_0/routes-web_addon.php";
*/

###############################################################
#                         УРОВЕНЬ 1                           #
#   Создание маршрутов получения информации от пользователя   #
###############################################################

/* Когда на сайте есть только несколько десятков фиксированных ссылок, ведущих на те или иные страницы, то здесь нет особого места каким-либо алгоритмам. Собственно говоря, даже использование фреймворка тут может быть излишним - ведь можно просто создать нужные HTML-документы и расположить их в соответствующих папках на сервере.

Но как только появляется необходимость получить от пользователя сайта какую-то информацию, то возникают вопросы: во первых, как это сделать, а во вторых, каким образом и в какой части серверного кода эту информацию лучше обрабатывать. Освещению этих тем и посвящён уровень 1 нашего гида. */

#-------------------------------------#   
#   ПАРАМЕТРЫ В СТРОКЕ HTTP-ЗАПРОСА   #   
#-------------------------------------#   

### ПОЛУЧЕНИЕ GET-ПАРАМЕТРОВ ###

    /* В PHP cамый стандартный и старый способ передачи каких-то значений через веб-запросы - это использование GET-параметров в адресной строке. Для этого в строке HTTP-запроса сразу после URL ставится знак `?` и перечисляются имена параметров с их значениями в формате `имя=значение`, разделяя эти пары символом `&`. Например для страницы поиска можно в адресную строку добавить параметры c именами `s_string` (строка поиска) и `lang` (язык). Выглядеть это будет так: http://127.0.0.1:8000/search/?s_string=тест&lang=ru
    
    Чтобы получить параметры из этого запроса в замыкании маршрута или в контроллере нужно предварительно объявить использование класса Request: */
    
    use Illuminate\Http\Request;
   
    /* Теперь можно создать маршрут, а в качестве параметра в замыкании указать объект класса Request. В этом случае сработает система автоматического внедрения (инъекции) зависимостей Laravel. В частности произойдёт следующее:

        1. Фреймфорк увидит, что в функцию или метод должен быть передан какой-то объект.
        2. Определит имя класса для этого объекта.
        3. Создаст экземпляр этого класса (т.е. создаст объект).
        4. В случае, если это Request-объект - автоматически заполнит все его свойства данными из веб-запроса.

    Получив внутри функции автоматически оформленный Request-объект, мы можем воспользоваться его методом `query()` для получения значений нужных GET-параметров. Для этого в первый аргумент метода нужно написать имя GET-параметра - и метод возвратит его значение. На случай, если вдруг окажется что такого GET-параметра нет в веб-запросе, можно вторым аргументом передать в метод значение по умолчанию, которое метод и возвратит в случае неудачи: */
    
    Route::get('/search', function (Request $request) {
        return 'Ищем текст "' . $request->query('s_string') . 
               '" на языке ' . $request->query('lang','ru'); 
    })->name('level1_search');

    /* В качестве альтернативы можно обойтись без внедрения зависимости и подключения класса, а использовать глобальную функцию-хелпер `request()`. Вызванная без аргумента, она возвращает Request-объект - экземпляр рекущего запроса. С одной стороны это проще, с другой - снижает читаемость кода и затрудняет внедрение тестов: */
      
    Route::get('/search2', function () {
        return 'Ищем текст "' . request()->query('s_string') .
               '" на языке ' . request()->query('lang','ru');
    });
    
    // Вызов `query()` без аргументов возвратит массив всех GET-параметров:
    
    Route::get('/search3', function () {
        $s = 'Все GET-параметры запроса: ';
        foreach ( request()->query() as $key=>$value ) 
            $s .= "$key => $value | ";
        return $s;
    })->name('level1_allGetParams');

    
### ПОЛУЧЕНИЕ ПАРАМЕТРОВ МАРШРУТА ###    

    /* Более удобный и красивый способ - передавать параметры внутри URL, объявляя их при создании маршрута. Для этого имена параметров обрамлюятся фигурными скобками и отделяются наклонной чертой (другие символы допустимы, но не практичны). В колбэк-функцию эти параметры передаются в виде аргументов. При этом имена аргументов не имеют значения (т.е. не обязаны совпадать с именами параметров маршрута) - важен только их порядок, т.к. именно в порядке расположения внутри URL эти параметры будут переданы в функцию: */

    Route::get('/cat/{cat_name}/page/{page_number}', function ($n, $m) {
        return 'Запрошена страница ' . $m . ' для категории ' . $n;
    })->name('level1_cat_page');

    /* Знак вопроса после имени параметра означает, что он необязателен. В этом случае у колбэк-функции соответствующие аргументы тоже должны быть необязательными (т.е. с заданными значениями по-умолчанию). В этом примере параметры передаются в методы контроллера, а они в свою очередь выдают ответ в виде списка полученных параметров: */

    use App\Http\Controllers\ParamController; // Подключаем класс контоллера
   
    Route::get('/showpar/{par1}/{par2?}/{par3?}', 
               [ParamController::class, 'showParams'])
           ->name('level1_showParams');
               
    Route::get('/showallpar/{par1}/{par2?}/{par3?}', 
               [ParamController::class, 'showAllParams'])
           ->name('level1_showAllParams');
    
### ПРОВЕРКА ПАРАМЕТРОВ МАРШРУТА НА ДОПУСТИМЫЙ ФОРМАТ ###

    /* Чтобы внутри колбэк-функции не проверять допустимость значения полученного параметра, можно воспользоваться методами самого route-объекта. Метод `where()` сверяет значение параметра с регулярным выражением и меняет статус route-объекта на "отвергаемый" в случае несовпадения: */

    Route::get('/nametest/{nameLatin}', function ($name) {
        return 'Имя ' . $name . 'корректно, т.к. написано латинницей.';
    })->where('name', '[A-Za-z]+');

    /* Для нескольких параметров можно выстраивать цепочки из методов сверки, либо в один метод передавать ассоциативный массив соответствий: */
   
    Route::get('/adress/{streetName}/{homeNumber}', function ($x, $y) {
        return 'Адрес ' . $x . ' ' . $y . ' корректен';
    })->where('streetName', '[A-Za-zА-Яа-я]+')->where('homeNumber', '[0-9]+');
    
    Route::get('/adress2/{streetName}/{homeNumber}', function ($x, $y) {
        return 'Адрес ' . $x . ' ' . $y . ' корректен';
    })->where(['streetName' => '[A-Za-zА-Яа-я]+', 
               'homeNumber' => '[0-9]+'         ]);

    /* Методы `whereNumber()`, `whereAlpha()`, `whereAlphaNumeric()`, `whereUuid()` позволяют проверить сразу несколько параметров на то, содержат ли они соответсвенно только цифры, только латинские буквы, только латинские буквы и цифры, только корректный идентификатор UUID: */
   
    Route::get('/coord/{x}/{y}/{z}', function (string $x, $y, $z) {
        return 'Все три координаты корректны, т.к. записаны цифрами';
    })->whereNumber(['x','y','z']);
    
    /* Можно задать глобальные ограничения - чтобы не дублировать метод `where()` в серии похожих маршрутов. Для этого в таких маршрутах нужно указать параметр с одинаковым именем, а описание ограничений на его значения вынести в файл фреймворка `app\Providers\RouteServiceProvider.php` внутрь метода `boot()`, например, в таком виде: `Route::pattern('homeNumber', '[0-9]+');` Теперь если в маршруте встречается параметр `homeNumber`, то маршрут будет срабатывать только если он удовлетворет глобальному ограничению, заданному в методе `pattern()`. */
    
### ОСОБЕННОСТИ ИСПОЛЬЗОВАНИЯ КОСОЙ ЧЕРТЫ В ЗНАЧЕНИЯХ ПАРАМЕТРОВ ### 
    
    /* Через GET-параметры можно спокойно передавать символы `/` и `\`. А вот в параметрах маршрута символ `/` по умолчанию считается разделителем между сегментами маршрута и не учитывается при считывании значений параметров. Стоит отметить, что при ручном вводе в строке браузера он обратную косую черту `\` внутри URL (но не в GET-параметрах) автоматически меняет на прямую `/`, и получается, что при сверке с адресом маршрута этот символ тоже не учитывается. Избежать этой автоподмены можно, если вместо символа `\` написать его unicode-эквивалент `%5C`. А вот при генерации ссылок програмно проблемы не возникает, т.к. Laravel сразу подставляет в адресную строку комбинацию `%5C`.
    
    Остаётся вопрос с самим символом `/`. При создании объектов-маршрутов по умолчанию ко всем параметрам маршрута негласно применяется метод `->where('param', '[^\/]*')`, предписывающий принимать все допустимые в URL символы кроме косой черты `/`. Но если всё-таки хочется иметь возможность передать через параметр маршрута в т.ч. этот символ `/`, то можно переопределить метод `where()`, задав в нём регулярное выражение, допускающее использование этого символа. Например, напишем маршрут, который умеет прямо в параметре маршрута получать любой текст, включая числовую дробь. Здесь регулярное выражение `.*` даёт указание включить в значение параметра `anytext` все символы (включая разделительные) до конца URL (т.е. до знака `?` при наличии  GET-параметров): */ 
    
    Route::get('/fraction/{anytext}', function ($n) {
        return 'Получено выражение: ' . $n; 
    })->name('level1_fraction')->where('anytext', '.*');
    
    /* Очевидно, что такое регулярное выражение можно написать только в случае, если параметр маршрута стоит в последнем сегменте маршрута. Ведь если бы мы указали в маршруте два параметра, принимающие символы `/`, то всё содержимое с этими символами попало бы в значение первого парамера, а второй оказался бы пустым. Вот пример такого ошибочного маршрута: */
    
    Route::get('/bad_fractions/{anytext1}/{anytext2?}', function ($n,$m=0) {
        return 'Получены выражения: ' . $n  . " и " . $m; 
    })->name('level1_bad_fractions')->where('anytext1', '.*')
                                    ->where('anytext2', '.*');
                               
    /* Обойти это ограничение можно, если в качесте разделителя сегмента маршрута указать какой-то другой символ, а сам этот другой символ указать как запрещённый в регулярном выражении. Исправим приведеный выше ошибочный маршрут, используя в качестве разделителя сегментов символ `-` и указав регулярное выражение `[^-]*` (т.е. любые символы кроме `-`): */
    
    Route::get('/fractions-{anytext1}-{anytext2}', function ($n,$m) {
        return 'Получены выражения: ' . $n  . " и " . $m; 
    })->name('level1_fractions')->where('anytext1', '[^-]*')
                                ->where('anytext2', '[^-]*');    
    
### ПЕРЕДАЧА ПАРАМЕТРОВ ПРИ ГЕНЕРАЦИИ URL-АДРЕСОВ ###
    
    /* Для демонстрации созданных маршрутов создадим blade-шаблон в файле `resources\views\getParams.blade.php`, в котором разными способами покажем создание активных параметризированных ссылок на эти маршруты. Вы можете перейти к этому файлу, и изучить его содержимое с целью освоения материала этого раздела. */

    Route::view('/getParamsDemo', 'getParams');

#--------------------#   
#   POST-ПАРАМЕТРЫ   #   
#--------------------#   

### ФИЛЬТРАЦИЯ МАРШРУТОВ ПО HTTP-МЕТОДУ ЗАПРОСА ### 

    /* Получение данных от пользователя может приходить не только через GET-запросы, но и через POST, PUT и пр. Использовавшийся нами ранее метод `get()` не среагирует на POST-запрос. Для работы с разными видами запросов в Laravel предусмотрены следущие инструменты. */

    /* Отбор запросов конкретного типа делается одноимённым route-методом.
       Вот их полный список: */
    Route::get('/get-hi', function () { return 'hi'; });
    Route::post('/post-hi', function () { return 'hi'; });
    Route::put('/put-hi', function () { return 'hi'; });
    Route::patch('/patch-hi', function () { return 'hi'; });
    Route::delete('/delete-hi', function () { return 'hi'; });
    Route::options('/options-hi', function () { return 'hi'; });
   
    /* Если нужны сразу два и более типа, то полезен route-метод `match()`, 
       который принимает на вход массив из названий этих HTTP-методов: */
    Route::match(['get', 'post'], '/get-post-hi', function () { return 'hi'; });
    
    // Принять сразу все типы HTTP-методов можно route-методом `any()`:
    Route::any('/any-hi', function () { return 'hi'; });
    