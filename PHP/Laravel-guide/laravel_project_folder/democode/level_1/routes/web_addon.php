<?php

/* 
    Этот демонстрационный код нужно добавить в конец файла `.\routes\web.php`
   Для этого либо скопируйте его туда вручную, либо добавьте в него строку кода:
   
   require  base_path() . "/democode/level_0/routes-web_addon.php";
*/

###############################################################
#                         УРОВЕНЬ 1                           #
#   Создание маршрутов получения информации от пользователя   #
###############################################################

/* Когда на сайте есть только несколько десятков фиксированных ссылок, ведущих на те или иные страницы, то здесь нет особого места каким-либо алгоритмам. Собственно говоря, даже использование фреймворка тут может быть излишним - ведь можно просто создать нужные HTML-документы и расположить их в соответствующих папках на сервере.

Но как только появляется необходимость получить от пользователя сайта какую-то информацию, то возникают вопросы: во первых, как это сделать, а во вторых, каким образом и в какой части серверного кода эту информацию лучше обрабатывать. Освещению этих тем и посвящён уровень 1 нашего гида. */

#----------------------------------#   
#   ОБРАБОТКА ПАРАМЕТРОВ ЗАПРОСА   #   
#----------------------------------#   

### ПОЛУЧЕНИЕ GET-ПАРАМЕТРОВ ###

    /* В PHP cамый стандартный и старый способ передачи каких-то значений через веб-запросы - это использование GET-параметров в адресной строке. Для этого сразу после URL ставится знак `?` и перечисляются имена параметров с их значениями после знака `=`. Несколько параметров разделяются знаком `&`. Например для страницы поиска можно в адресную строку добавить параметры c именами `s_string` (строка поиска) и `lang` (язык). Выглядеть это будет так: http://127.0.0.1:8000/search/?s_string=тест&lang=ru
    
    Чтобы получить параметры из этого запроса в замыкании маршрута или в контроллере нужно предварительно объявить использование класса Request: */
    
    use Illuminate\Http\Request;
   
    /* Теперь можно создать маршрут, а в качестве параметра в замыкании указать объект класса Request. В этом случае сработает система автоматического внедрения (инъекции) зависимостей Laravel. В частности произойдёт следующее:

        1. Фреймфорк увидит, что в функцию или метод должен быть передан какой-то объект.
        2. Определит имя класса для этого объекта.
        3. Создаст экземпляр этого класса (т.е. создаст объект).
        4. В случае, если это Request-объект - автоматически заполнит все его свойства данными из веб-запроса.

    Получив внутри функции автоматически оформленный Request-объект, мы можем воспользоваться его методом `query()` для получения значений нужных GET-параметров. Для этого в первый аргумент метода нужно написать имя GET-параметра - и метод возвратит его значение. На случай, если вдруг окажется что такого GET-параметра нет в веб-запросе, можно вторым аргументом передать в метод значение по умолчанию, которое метод и возвратит в случае неудачи: */
    
    Route::get('/search', function (Request $request) {
        return 'Ищем текст ' . $request->query('s_string') . 
               ' на языке ' . $request->query('lang','ru'); 
    });

    /* В качестве альтернативы можно обойтись без внедрения зависимости и подключения класса, а использовать глобальную функцию-хелпер `request()`. Вызванная без аргумента, она возвращает Request-объект - экземпляр рекущего запроса. С одной стороны это проще, с другой - снижает читаемость кода и затрудняет внедрение тестов: */
      
    Route::get('/search2', function () {
        return 'Ищем текст ' . request()->query('s_string') .
               ' на языке ' . request()->query('lang','ru');
    });
    
    // Вызов `query()` без аргументов возвратит массив всех GET-параметров:
    
    Route::get('/search3', function () {
        $s = 'Все GET-параметры запроса: ';
        foreach ( request()->query() as $key=>$value ) 
            $s .= "$key => $value | ";
        return $s;
    });

    
### ПОЛУЧЕНИЕ URL-ПАРАМЕТРОВ ###    

    /* Более удобный и красивый способ - передавать параметры внутри URL. Обычно их принято разделять наклонной чертой (другие символы допустимы, но не практичны). Для того чтобы иметь возможность выудить параметры из URL, нужно в строке-образце для URI указывать имена этих параметров в фигурных скобках.  При этом имена переменных функции не имеют значения, важен только их порядок, т.к. именно в порядке расположения в URL параметры будут переданы в функцию: */

    Route::get('/cat/{cat_name}/page/{page_number}', function (string $n, $m) {
        return 'Запрошена страница ' . $m . ' для категории ' . $n;
    });

    /* Знак вопроса после имени параметра означает, что он необязателен. В этом случае у колбэк-функции соответствующие аргументы тоже должны быть  необязательными (т.е. с заданными значениями по-умолчанию). В этом примере параметры передаются в методы контроллера, а они в свою очередь выдают ответ в виде списка полученных параметров: */

    use App\Http\Controllers\ParamController; // Подключаем класс контоллера
   
    Route::get('/showpar/{par1}/{par2?}/{par3?}', 
               [ParamController::class, 'showParams']);
               
    Route::get('/showallpar/{par1}/{par2?}/{par3?}', 
               [ParamController::class, 'showAllParams']);
    
### ПРОВЕРКА URL-ПАРАМЕТРОВ НА ДОПУСТИМЫЙ ФОРМАТ ###

    /* Чтобы внутри колбэк-функции не проверять допустимость значения полученного параметра можно воспользоваться для этого методами самого route-объекта. Метод `where()` сверяет значение параметра с регулярным выражением и меняет статус route-объекта на "отвергаемый" в случае несовпадения: */

    Route::get('/nametest/{nameLatin}', function ($name) {
        return 'Имя ' . $name . 'корректно, т.к. написано латинницей.';
    })->where('name', '[A-Za-z]+');

    /* Для нескольких параметров можно выстраивать цепочки из методов сверки, либо в один метод передавать ассоциативный массив соответствий: */
   
    Route::get('/adress/{streetName}/{homeNumber}', function ($x, $y) {
        return 'Адрес ' . $x . ' ' . $y . ' корректен';
    })->where('streetName', '[A-Za-zА-Яа-я]+')->where('homeNumber', '[0-9]+');
    
    Route::get('/adress2/{streetName}/{homeNumber}', function ($x, $y) {
        return 'Адрес ' . $x . ' ' . $y . ' корректен';
    })->where(['streetName' => '[A-Za-zА-Яа-я]+', 
               'homeNumber' => '[0-9]+'         ]);

    /* Методы `whereNumber()`, `whereAlpha()`, `whereAlphaNumeric()`, `whereUuid()` позволяют проверить сразу несколько параметров на то, содержат ли они соответсвенно только цифры, только латинские буквы, только латинские буквы и цифры, только корректный идентификатор UUID: */
   
    Route::get('/coord/{x}/{y}/{z}', function (string $x, $y, $z) {
        return 'Все три координаты корректны, т.к. записаны цифрами';
    })->whereNumber(['x','y','z']);

### ФИЛЬТРАЦИЯ МАРШРУТОВ ПО HTTP-МЕТОДУ ЗАПРОСА ### 

    /* Получение данных от пользователя может приходить не только через GET-запросы, но и через POST, PUT и пр. Использовавшийся нами ранее метод `get()` не среагирует на POST-запрос. Для обработки всех типов запросов в Laravel предусмотрены следущие инструменты. */

    /* Отбор запросов конкретного типа делается одноимённым route-методом.
       Вот их полный список: */
    Route::get('/get-hi', function () { return 'hi'; });
    Route::post('/post-hi', function () { return 'hi'; });
    Route::put('/put-hi', function () { return 'hi'; });
    Route::patch('/patch-hi', function () { return 'hi'; });
    Route::delete('/delete-hi', function () { return 'hi'; });
    Route::options('/options-hi', function () { return 'hi'; });
   
    /* Если нужны сразу два и более типа, то полезен route-метод `match()`, 
       который принимает на вход массив из названий этих HTTP-методов: */
    Route::match(['get', 'post'], '/get-post-hi', function () { return 'hi'; });
    
    // Принять сразу все типы HTTP-методов можно route-методом `any()`:
    Route::any('/any-hi', function () { return 'hi'; });
    