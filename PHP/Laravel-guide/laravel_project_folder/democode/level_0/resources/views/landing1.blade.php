<!-- Это файл blade-шаблона с демонстрационным кодом.
  Если в файле `config\view.php` прописан путь к папке с этим файлом, то шаблон
  будет доступен под именем `landing1` (см. пояснение в конце этого листинга). 
  Иначе его нужно скопировать в папку шаблонов, чтобы путь к нему был такой: 
     `resources\views\landing1.blade.php`.
  
  Также Вы можете создать новый пустой файл шаблона консольной командой
     `php artisan make:view landing1` 
   и скопировать в него этот код ↓ ↓ ↓
-->

<div>
    <p> Приветсвуем Вас на странице Landing 1 !!! </p>
    
    <h2> Использование PHP-кода и переменных в шаблонах </h2>
    <h3> Отображение значений строк в HTML-коде </h3>
        <p> В blade-шаблонах можно отображать значения строковых переменных либо результаты работы функций, возвращающих строку. Для этого переменную или PHP-код нужно оформить в т.н. выражение ввода - разместить внутри двойных фигурных скобок. Вот пример такого выражения: 
            <br> Текущая дата - {{ date("m.d.Y"); }} 
    </p>
    
    <h3> Передача переменных в шаблон </h3>
        <p> Таким же способом выводить переменные, переданные в шаблон вместе со view-объектом из колбэков `view()`. Для случая, если какие-то из переменных не были переданы, то можно избежать появления ошибки `Undefined variable` можно путём использования условного оператора `??` :
            <br> при вызове шаблона получена информация:
            <br> {{ $var1 ?? "пусто" }} и {{ $var2 ?? "пусто" }}
        
        </p>    
    
    <h3> Авто удаление HTML-символов для защиты от XSS-атак </h3>
        <p> Важно отметить, что при таком включении кода автоматически применяется php-функция `htmlspecialchars` для предотвращения XSS-атак. Если требуется вывести строку без этой обработки, внутренние фигурные скобки нужно заменить на двойные восклицательные знаки. Сравните:  
        
            <br> Защита включена:  {{  "<a href='spam'>Жми сюда</a>"  }}
            <br> Защита выключена: {!! "<a href='spam'>Жми сюда</a>" !!}
        </p>

    <h3> Комментирование кода и экранирование выражений </h3>
        <p> Если же двойные кавычки изнутри обрамить двойными минусами, то получится blade-комментарий, который не будет виден в итоговом HTML-коде. Сравните:
        
            <!-- Видимый комментарий -->
            {{-- Невидимый комментарий --}}
        </p>
        
        <p> При этом помещённые внутрь HTML-комментария blade-директивы и переменные продолжают "срабатывать". Это может быть полезно для отладки:
        
            <!-- Значение переменной: {{ $var1 ?? "пусто" }} -->
        </p>
        <p> Если же нужно наоборот, показать сам код директивы без её срабатывания, нужно перед директивой поставить дополнительный символ `@`. Например:
            <br> @{{ этот код не сработает }}
            <br> @@include(этот шаблон не подключится)
        </p>
        <p> Отключить php-интерпретацию для целого блока кода можно директивой `@@verbatim` :
        
            @verbatim
                <br> {{ этот код не сработает }}
                <br> @include(этот шаблон не подключится)
            @endverbatim
        </p>
        
    <h3> Произвольный PHP-код </h3>
        <p>
        Назначение шаблонов - отображение HTML-страницы. Различные же вычисления нужно производить в предназначенных для этого контроллерах. Тем не менее (для крайних случаев), в Laravel есть возможность вставлять в шаблоны произвольный PHP-код, обрамляя его директивами `@php` и `@endphp`. Внутри этих директив вывод информации на веб-страницу делается стандартными механизмами вывода (`echo` и т.п.):
            
            @php
                $i=sqrt(2);
                echo "<br>Корень из двух равен " . $i;
            @endphp  
            <br> Значение переменной `i` сохранилось: {{ $i }} 
        </p>
        
        <p> Если php-код нужен только для подключения класса, то удобнее использовать директиву `use`, в которой вторым необязательным аргументом можно указать псевдоним для этого класса:
        
            @use('App\Http\Controllers\SimpleController','Simp')
            <br>Вызов статического метода класса: {{ Simp::showText2(); }}
        </p>
        <p> Разумеется перед вызовом метода класса в самом классе нужно этот метод описать, так чтобы он был статическим и возвращал строку:
        </p>
        
    <h3> Подключение дочерних шаблонов </h3>
        <p> При создании однотипных страниц неизбежно возникает ситуация, что многие страницы имеют одинаковые блоки. В обычных HTML-документах такие блоки пришлось бы дублировать на всех страницах, а в случае последующих правок - редактировать такой блок в каждой из страниц. Использование PHP позволяет вставлять содержимое одного файла в другой выражениями типа `require`, благодаря чему можно переиспользуемый код вынести в отдельные файлы, и при необходимости подключать в нужные места. 
        </p>
        
        <p> Шаблонизатор Blade имеет целых три инструмента для вставки внутрь шаблона переиспользуемого кода:
            <ol> <li>Дочерние шаблоны </li>
                 <li>Наследуемые шаблоны </li>
                 <li>Компоненты </li>
            </ol>
        
        <p> Для статических страниц подойдёт самый простой вариант - дочерние шаблоны. Допустим, мы решили на всех страницах сайта отображать главное меню. Для этих целей создадим файл `menu1.blade.php` с простейшей навигацией по трём страницам сайта.
        
        После того как этот файл создан, его содержимое можно отображать внутри других шаблонов с помощью директивы `@@include('имя шаблона')`: 
        </p>
        
        @include('menu1')

        <p> Дополнительно при подключении можно передать переменные в виде ассциативного массива во втором аргументе директивы: `@@include('имя шаблона',['имя'=>'значение', .. ])`: 
        </p>    
        
        @include('menu1', ['newvar1' => 'ещё одно значение'])
</div>

<!-- ПОЯСНЕНИЕ К ВОПРОСУ ПУТЕЙ К ФАЙЛУ ШАБЛОНА

Весь демонстрационный код маршрутов, контроллеров и т.п. у нас содержится в папке `democode` - так легче просматривать и изучать созданные нами файлы и блоки кода, поскольку они не перемешаны со стандартными файлами фреймворка. Для обычного PHP-кода это не составляет проблемы, т.к. его можно подключить из любого места выражением `require <полный путь к php-файлу>`. Но в случае HTML-шаблонов такой фокус не срабатывает - стандартные настройки Laravel дают возможность искать и подключать шаблоны только в пределах папки `resources\views\`.

Однако можно расширить список папок для поиска шаблонов. Для этого нужно в файле `config\view.php` дополнить массив `paths` строками с новыми путями.
Скопируем созданный нами файл шаблона в папку `democode\level_0\resources\views` и добавим этот путь в упомянутый выше массив `paths`. Выглядеть этот фрагмент кода будет вот так:

'paths' => [
        resource_path('views'), // Стандартный путь Laravel
        // Дополнительные пути к пользовательским шаблонам:
        base_path() . "/democode/level_0/resources/views",
    ],

После этого потребуется обновить кэш конфигурации Laravel консольной командой:

	php artisan config:cache

-->