<?php

/* Этот демонстрационный код нужно добавить в конец файла `.\routes\web.php`
   Для этого либо скопируйте его туда целиком, либо добавьте в него строку кода:
   
   require  base_path() . "/democode/level_0/routes/web_addon.php";
*/

#####################################
#             УРОВЕНЬ 0             #
#   Создание простейших маршрутов   #
#####################################

/* Первый практический шаг после установки Laravel - это создание нужных маршрутов в файле `.\routes\web.php`. Маршрут представляет из себя как бы правило, что нужно дальше делать серверу при получении URI-запроса.  Технически для этого с помощью методов (`get()`,`post()` и пр.) создаются объекты класса `Route` и помещаются в упорядоченную коллекцию. При создании такого объекта-маршрута в первом аргументе указывается адрес (URI) страницы сайта, а во втором - callback-функция (замыкание), возвращающая содержимое веб-страницы в случае, если входящий запрос соответсвует URI из первого аргумента. При работе только со статическими страницами браузер посылает обычные GET-запросы, поэтому на первом уровне нашего гида мы будем создавать маршруты преимущественно с помощью метода `get()`. 
*/

#------------------------------------------#
#   РАЗНОВИДНОСТИ НАПРАВЛЕНИЙ МАРШТРУТОВ   #
#------------------------------------------#

/* Используются следующие варианты: */

### 1. Вывод простого текста ###

    Route::get('/hello', function () { 
        return 'Hello World!';  
    }); // по адресу http://127.0.0.1:8000/hello появится текст `Hello World!`

### 2. Вывод ответа сервера с заголовком и/или кодом ответа ###

    Route::get('/hello-head', function () { 
        /* Объекты класса `Responce` обладают методом `header`, который 
           добавляет к ответу заголовок `<head>` */
        return response('Привет!') -> header('Content-Type', 'text/plain');  
    });

    // Вторым аргументом можно указать код ответа, отличный от 200:
    Route::get('/empty', function () { 
        return response('Здесь ничего нет.', 403);  
    });

    // Для пустых ответов может также пригодится response-метод `noContent()`:
    Route::get('/empty2', function () { 
        return response()->noContent();
    });
    

### 3. Вывод одного из представлений (view), заданного blade-шаблоном ###

    Route::get('/welcome_to_laravel', function () {
        return view('welcome');  
    }); /* По адресу http://127.0.0.1:8000/welcome_to_laravel отобразится 
           шаблон из файла `.\resources\views\welcome.blade.php` */
    
    // То же самое более компактно - через метод view класса Route
    Route::view('/welcome2_to_laravel', 'welcome'); 

### 4. Вызов одного из контроллеров с последующим ответом от него ###

    /* Правильный подход - описывать колбэк не в виде анонимной-функции прямо в теле объявления маршрута, а выносить в один из конроллеров в виде его метода. */

    #### Создание контроллера ####
    
    /* Для этого создатим новый пустой контроллер с именем `SimpleController`. Код этого котроллера можно посмотреть в файле `app\Http\Controllers\SimpleController.php`. После того как контроллер подготовлен, можно в маршрутах вызывать методы этого контроллера. Вызов callback-методов, находящихся внутри класса, делается указанием массива из двух строк (полного пути к классу и имени метода): */

    Route::get('/ctrl-hello', 
               ['App\Http\Controllers\SimpleController', 'showText']);

    /* Если подключить контроллер директивой `use`, то можно не писать 
       полный путь к нему, а через краткое имя обратиться к встроенной 
       константе `class`, хранящей полное имя класса: */
    use App\Http\Controllers\SimpleController;
    Route::get('/ctrl-hello2', [SimpleController::class, 'showText']);

### 5. Вызов контроллера с дальнейшим показом blade-шаблона ###

    Route::get('/ctrl-welcome', [SimpleController::class, 'showWelcome']);

### 6. Переадресация ###
    
    // Простой редирект с кодом возврата 302
    Route::redirect('/hi', '/hello'); 
    
    // Третьим параметром можно указать другой код возврата:
    Route::redirect('/hi2', '/hello', 301); 
    
    // Такой же код 301 возвращает метод `permanentRedirect`
    Route::permanentRedirect('/hi3', '/hello'); 
    
    /* Также переадресацию, скачивание файлов и много других вещей можно делать 
       с помощью специалных response-методов. Но всё это обычно прописыватся 
       внутри контроллеров, а не в самих маршрутах - а значит может считаться 
       различными вариантами ответов от контроллера. */

### 7. Запасной маршрут ###

    /* Если входящий запрос не соответствует ни одному из маршрутов, то 
       его можно обработать методом `fallback`, который направит запрос по 
       маршруту вместо ответа `404 - страница не найдена`. Логично что этот 
       маршрут указывается последним, т.к. он срабатывает безусловно: */
   
    if (0) {  // Отключим его работу, чтобы добавляемые ниже маршруты работали
        Route::fallback([SimpleController::class, 'showWelcome']);
    }

#--------------------------#
#   ИМЕНОВАННЫЕ МАРШРУТЫ   #
#--------------------------#

    /* Сами по себе маршруты создаются как безымянные объекты, доступные через
    коллекцию, в которой хранятся. Но есть возможность задавать им уникальные 
    имена и через эти имена обращаться напрямую к объектам-маршрутам: */
    
    Route::get('materials/page1', function () {
        return 'Это страница, на которую ведёт маршрут page1';
    })->name('page1'); // Метод `name()` задаёт маршруту имя
    
    /* Теперь, когда у маршрута есть имя, появляется возможность через имя 
    маршрута получить строку URL, на которую этот маршрут отзывается - а значит 
    это можно использовать для создания однозначно рабочей ссылки, связанной
    с этим именнованным маршрутом. 
    Такую ссылку в виде строки возвращает глобальная функция `route()`: */
    
    Route::get('where_is_page1', function () {
        $url = route('page1'); // В строке $url - URI маршрута 'page1'
        return 'Страница page1 находится по адресу: ' . $url;
    });
    
    /* Обратите внимание, что если мы в объявлении самого маршрута page1 произвольно изменим URI-адрес (в первом параметре метода `get()`), то по адресу http://127.0.0.1:8000/where_is_page1 отоброзится этот новый URL. Т.е. повсеместное применение функции `route()` при создании ссылок на страницы сайта позволяет в дальнейшем спокойно менять адреса страниц в файле маршрутов `routes\web.php` и не переживать, что где-то в другом месте приложения ссылки на эти страницы станут не рабочими. */

#----------------------------------------#
#   ПОЛУЧЕНИЕ ПОЛНОГО СПИСКА МАРШРУТОВ   #
#----------------------------------------#
    /* В процессе разработки приложения список маршрутов можно просматривать локально, выполнив в консоли команду `php artisan route:list`. Но также можно работать со списком и в самом приложении. Для этого есть метод `getRoutes()`, который возвращает коллекцию, в которой хранятся маршруты. Выведем список URI и соответвующие им контроллеры на странице http://127.0.0.1:8000/routes_list */
    
    Route::get('routes_list', function () {
        $routeCollection = Route::getRoutes(); // Получаем коллекцию маршрутов
        $str = '<br><br>'; // В цикле будем добавлять всю информацию в эту строку
        foreach ($routeCollection as $value) {
                $str = $str . $value->uri() . ' | ' . // Значение URI
                $value->getActionName() . '<br>'; // Имя контроллера и метод
        }
        return 'Список URI, контроллеров и методов для всех маршрутов: ' . $str;
    });
    

##############################
#   СОЗДАНИЕ HTML-ШАБЛОНОВ   #
##############################

    /* Для генерации статических HTML-страниц Laravel использует встроенный шаблонизатор Blade. HTML-шаблоны располагаются в папке `resources\views\ `  Если в методе `Route::view()` или глобальной функции view() указать имя шаблона, например `name`, то фреймворк возвратит содержимое файла `name.blade.php` из этой папки.
    
    Создадим новый шаблон с названием `landing1`. Для этого достаточно просто создать пустой файл `resources\views\landing1.blade.php`, и далее напонять его HTML-кодом.
    Но чтобы не ошибиться в формате имени файла и в пути, где его следует расположить, можно в корне проекта выполнить консольную команду: `php artisan make:view landing1`. */

#------------------------------------#
#   СВЯЗЫВАНИЕ ШАБЛОНА С МАРШРУТОМ   #
#------------------------------------#

    /* Как уже ранее отмечалось, существующий файл шаблона можно загружать колбэками `view()`. Для этого создадим в файле маршрутов ещё пару маршрутов к новому шаблону - напрямую и через контроллер: */
    
    Route::view('/landing_page1', 'landing1'); 

    Route::get('/ctrl-landing1', [SimpleController::class, 'showLanding1']);
    
#----------------------------#
#   КАТАЛОГИЗАЦИЯ ШАБЛОНОВ   #
#----------------------------#

    /* Когда на сайте предусмотрено много различных страниц, то для удобства работы их шаблоны можно разложить в различные подпапки. Предположим, что на нашем сайте помимо лендинга предусмотрено несколько разделов. В этом случае можно в папке с шаблонами создать подпапку `section` и в ней размещать шаблоны страниц для этих разделов.

    Создадим эту подпапку и в ней пару шаблонов:
    `sections\topic1.blade.php` и `sections\topic2.blade.php`
    
    Доступ к таким шаблонам в подпапках возможен через строку `<имя подпапки>.<имя шаблона>`: */
    
	Route::view('/topic1', 'sections.topic1');
	Route::view('/topic2', 'sections.topic2');    