# Компактный гид по Laravel. Уровень 0 - создание простых веб-страниц.

В этом пособии мы поэтапно, от уровня к уровню и в достаточно полной мере рассмотрим ключевые возможности фреймворка Laravel. Приводимые примеры кода работают в версиях Laravel 9 и 10.

## Установка

- [ ] 1. Установить [XAMPP](https://www.apachefriends.org/ru/index.html) и добавить путь к файлу xampp\php\php.exe в в переменную %PATH% (чтобы php можно было вызывать в любой папке без указания пути к нему).
- [ ] Установить [Composer](https://getcomposer.org/).
- [ ] Перейти в папку с проектами и выполнить в терминале команду с указанием желаемой версии Laravel:
```bash
    composer create-project laravel/laravel my_new_project "9.1.*"
```
Если не указывать версию, то будет установлена самая последняя.

## Запуск сервера

Для запуска сайта локально нужно перейти в папку проекта (`cd my_new_project`)и выполнить в терминале команду:
```bash
    php artisan serve
```
Сайт станет доступен по адресу: http://127.0.0.1:8000

## Создание простейших маршрутов

### Лирическое введение
Статический интернет-сайт самого примитивного типа представляет из себя размещённые на сервере ресурсы: HTML-документы, картинки, файлы и т.п. Каждому ресурсу соответствует уникальный URI-адрес, по которому можно однозначно получить этот ресурс. Вся же мощь PHP заключается в том, что отдаваемые сервером HTML-документы могут генерироваться динамически алгоритмами, закодированными на этом языке программирования.

В самом примитивном случае вместо некоторых HTML-документов на сервер помещаются PHP-скрипты с аналогичными именами и внутри этих скриптов происходит работа алгоритмов. Логично, что такая архитектура сайта удобна только если сайт состоит из нескольких простых страниц. А когда страниц становится всё больше и больше, то становится физически невозможно вносить правки в десятки похожих файлов, поддерживая единообразие всех страниц сайта.

Поэтому следующий уровень развития сайтов - это сделать единую точку входа на сайт в виде скрипта `index.php`, а уже в этом скрипте производить всю работу по разбору полученного URI-запроса и алгоритмически принимать решение, какую информацию или какой документ выдать в ответ на этот запрос.

> В частности, Laravel, получая входящий запрос через браузер или через консоль, создаёт экземпляр приложения `app()`, которое направляет запрос либо в HTTP-ядро либо в консольное ядро. Там происходит процесс создания, регистрации и загрузки сервис-провайдеров (объектов определённых классов). После чего объект запроса направляется в сервис-провайдер `App\Providers\RouteServiceProvider`, который загружает списки маршрутов, определяющих куда дальше направить полученный запрос. Подробнее про эту внутреннюю кухню Laravel можно прочитать [здесь](https://mydev.fun/laravel/lifecycle).

Первый практический шаг после установки Laravel - это создание нужных маршрутов в файле `.\routes\web.php`. Маршрут представляет из себя как бы правило, что нужно дальше делать серверу при получении URI-запроса.  Технически для этого с помощью методов (`get()`,`post()` и пр.) создаются объекты класса `Route` и помещаются в упорядоченную коллекцию массив. При создании такого объекта-маршрута в первом аргументе указывается адрес (URI) страницы сайта, а во втором - callback-функция (замыкание), возвращающая содержимое веб-страницы. При работе только со статическими страницами браузер посылает обычные GET-запросы, которые мы сейчас будем создавать преимущественно с помощью метода `get()`.


### Разновидности направлений марштрутов

При обработке браузерного запроса происходит перебор массива с объектами-маршрутами, и в случае совпадения URI запроса с шаблоном URI, хранящемся в объекте-маршруте, перебор прекращается и объект приступает к обработке запроса.

Для создания новых собственных маршрутов дополним файл `.\routes\web.php` таким фрагментами кода, вызывающего нужные методы:

#### 1. Вывод простого текста
>⇩⇩⇩ `.\routes\web.php` ⇩⇩⇩

```php
	Route::get('/hello', function () {
  	  return 'Hello World!';
	});
```
по адресу http://127.0.0.1:8000/hello появится текст `Hello World!`

#### 2. Вывод ответа сервера с заголовком и/или кодом ответа

Объекты класса `Responce` обладают методом `header`, который добавляет к ответу заголовок `<head>`.
```php
    Route::get('/hello-head', function () {
        return response('Привет!') -> header('Content-Type', 'text/plain');
    });
```

Вторым аргументом можно указать код ответа, отличный от 200:
```php
    Route::get('/empty', function () { // Можно указать код ответа, отличный от 200
        return response('Здесь ничего нет.', 403);
    });
```
Для пустых ответов может также пригодится response-метод `noContent()`:
```php
    Route::get('/empty2', function () {
        return response()->noContent();
    });
```


#### 3. Вывод одного из представлений (view), заданного blade-шаблоном:
```php
	Route::get('/welcome_to_laravel', function () {
   		return view('welcome');
	});
```
По адресу http://127.0.0.1:8000/hello отобразится шаблон из файла `.\resources\views\welcome.blade.php`

То же самое более компактно - через метод view класса Route:
```php
	Route::view('/welcome2_to_laravel', 'welcome');  
```

#### 4. Вызов одного из контроллеров с последующим ответом от него

Колбэк-функцию можно и лучше делать не анонимной, а в виде метода объекта-контроллера. Поскольку мы пока не создали своих новых контроллеров, то новые методы можно прописать в единственном имеющемся контроллере (он находится в файле `.\app\Http\Controllers\Controller.php`). 

Добавляем этот код с новыми методами в класс контроллера (т.е. **внутрь(!!!)** блока кода `class Controller ...` ):
>⇩⇩⇩ `.\app\Http\Controllers\Controller.php` : `class Controller` ⇩⇩⇩

```php
    public function showText() {
        return 'Привет от контроллера!';
    }

	public function showWelcome() {
        return view('welcome');
    }
```

После того как контроллер подготовлен, можно продолжить добавлять в файл `.\routes\web.php` новые маршруты к этим методам контроллера. Вызов callback-методов, находящихся внутри класса, делается указанием массива из двух строк (полного пути к классу и имени метода):
>⇩⇩⇩ `.\routes\web.php` ⇩⇩⇩
```php
	Route::get('/ctrl-hello', ['App\Http\Controllers\Controller', 'showText']);
```

Теперь по адресу http://127.0.0.1:8000/ctrl-hello можно увидеть ответ от контроллера.

Если подключить контроллер директивой `use`, то можно не писать полный путь к нему, а через краткое имя обратиться к встроенной константе `class`, хранящей полное имя класса:
```php
	use App\Http\Controllers\Controller;
	Route::get('/ctrl-hello2', [Controller::class, 'showText']);
```

#### 5. Вызов контроллера с дальнейшим показом blade-шаблона
Выше мы уже создали в контроллере новый метод showWelcome(), который возвпащает коллбэк-функцию view(). Использование контроллера для загрузки  blade-шаблон - классический MVC-способ генерации страниц со стороны сервера:

    Route::get('/ctrl-welcome', [Controller::class, 'showWelcome']);

Теперь по адресу http://127.0.0.1:8000/ctrl-welcome отображается шаблон `resources\views\welcome.blade.php`, поскольку его отображение прописано в контроллере.

#### 6. Переадресация
Простой редирект с кодом возврата 302:
```php
    Route::redirect('/hi', '/hello'); 
```
Третьим параметром можно указать другой код возврата:
```php
    Route::redirect('/hi2', '/hello', 301); 
```
Такой же код 301 возвращает метод `permanentRedirect`
```php
    Route::permanentRedirect('/hi3', '/hello'); 
```
Также переадресацию, скачивание файлов и много других вещей можно делать с помощью специалных response-методов. Но всё это обычно прописыватся внутри контроллеров, а не в самих маршрутах - а значит может считаться различными вариантами ответов от контроллера.

#### 7. Запасной маршрут
Если входящий запрос не соответствует ни одному из предыдущих маршрутов, то его можно обработать методом `fallback`, который направит запрос по маршруту вместо ответа `404 - страница не найдена`:
```php
	Route::fallback([Controller::class, 'showText']);
```

#### Иллюстрация маршрутизации
Наглядная схема, показывающая как эти 7 вариантов маршрутов работают (в квадратных скобках указаны номера, соответвующие одному из вышеперчисленных вариантов):
![схема](.\images\Level_0-Routes.png)
---

### Именованные маршруты

Сами по себе маршруты создаются как безымянные объекты, доступные через коллекцию, в которой хранятся. Но есть возможность задавать им уникальные  имена и через эти имена обращаться напрямую к объектам-маршрутам:
```php
	Route::get('materials/page1', function () {
        return 'Это страница, на которую ведёт маршрут page1';
    })->name('page1');  // Метод `name()` задаёт маршруту имя
```

Теперь, когда у маршрута есть имя, появляется возможность через имя маршрута получить строку URL, на которую этот маршрут отзывается - а значит это можно использовать для создания однозначно рабочей ссылки, связанной с этим именнованным маршрутом. Такую ссылку в виде строки возвращает глобальная функция `route()`:
```php
    Route::get('where_is_page1', function () {
        $url = route('page1'); // В строке $url - URI маршрута 'page1'
        return 'Страница page1 находится по адресу: ' . $url;
    });
```

Обратите внимание, что если мы в объявлении самого маршрута page1 произвольно изменим URI-адрес (в первом параметре метода `get()`), то по адресу http://127.0.0.1:8000/where_is_page1 отоброзится этот новый URL. Т.е. повсеместное применение функции `route()` при создании ссылок на страницы сайта позволяет в дальнейшем спокойно менять адреса страниц в файле маршрутов `routes\web.php` и не переживать, что где-то в другом месте приложения ссылки на эти страницы станут не рабочими.

### Получение полного списка маршрутов

В процессе разработки приложения список маршрутов можно просматривать локально, выполнив в консоли команду `php artisan route:list`. Но также можно работать со списком и в самом приложении. Для этого есть метод `getRoutes()`, который возвращает коллекцию, в которой хранятся маршруты. Выведем список URI и соответвующие им контроллеры на странице http://127.0.0.1:8000/routes_list

```php
    Route::get('routes_list', function () {
        $routeCollection = Route::getRoutes(); // Получаем коллекцию маршрутов
        $str = '<br>'; // В цикле будем добавлять всю информацию в эту строку
        foreach ($routeCollection as $value) {
                $str = $str . $value->uri() . ' | ' . // Значение URI
                $value->getActionName() . '<br>'; // Имя контроллера и метод
        }
        return 'Список URI, контроллеров и методов для всех маршрутов: ' . $str;
    });
```
