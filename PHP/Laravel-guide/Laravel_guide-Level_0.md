# Компактный гид по Laravel. Уровень 0 - создание простых веб-страниц.

На первом уровне нашего пососбия будут рассмотрены самые базовые возможности фреймворка, которые тем не менее позволяют запустить полноценный информационный сайт, наполняемый информацией путём прямой правки шаблонов страниц.

## Установка

- [ ] 1. Установить [XAMPP](https://www.apachefriends.org/ru/index.html) и добавить путь к файлу xampp\php\php.exe в переменную %PATH% (чтобы php можно было вызывать в любой папке без указания пути к нему).
- [ ] Установить [Composer](https://getcomposer.org/).
- [ ] Перейти в папку с проектами и выполнить в консоли команду с указанием желаемой версии Laravel:

>⇩⇩⇩ Команда консоли в корневой папке laravel-проекта ⇩⇩⇩

```bash
    composer create-project laravel/laravel my_new_project "9.1.*"
```
Если не указывать версию, то будет установлена самая последняя.

## Запуск сервера

Для запуска сайта локально нужно перейти в папку проекта (`cd my_new_project`)и выполнить в консоли команду:
```bash
    php artisan serve
```
Сайт станет доступен по адресу: http://127.0.0.1:8000

## Создание простейших маршрутов

### Лирическое введение
Статический интернет-сайт самого примитивного типа представляет из себя размещённые на сервере ресурсы: HTML-документы, картинки, файлы и т.п. Каждому ресурсу соответствует уникальный URI-адрес, по которому можно однозначно получить этот ресурс. Вся же мощь PHP заключается в том, что отдаваемые сервером HTML-документы могут генерироваться динамически алгоритмами, закодированными на этом языке программирования.

В самом примитивном случае вместо некоторых HTML-документов на сервер помещаются PHP-скрипты с аналогичными именами и внутри этих скриптов происходит работа алгоритмов. Логично, что такая архитектура сайта удобна только если сайт состоит из нескольких простых страниц. А когда страниц становится всё больше и больше, то становится физически невозможно вносить правки в десятки похожих файлов, поддерживая единообразие всех страниц сайта.

Поэтому следующий уровень развития сайтов - это сделать единую точку входа на сайт в виде скрипта `index.php`, а уже в этом скрипте производить всю работу по разбору полученного URI-запроса и алгоритмически принимать решение, какую информацию или какой документ выдать в ответ на этот запрос.

<details>
  <summary>Технические подробности >>> </summary> 
  В частности, Laravel, получая входящий запрос через браузер или через консоль, создаёт экземпляр приложения `app()`, которое направляет запрос либо в HTTP-ядро либо в консольное ядро. Там происходит процесс создания, регистрации и загрузки сервис-провайдеров (объектов определённых классов). После чего объект запроса направляется в сервис-провайдер `App\Providers\RouteServiceProvider`, который загружает списки маршрутов, определяющих куда дальше направить полученный запрос. Подробнее про эту внутреннюю кухню Laravel можно прочитать <a href="https://mydev.fun/laravel/lifecycle">здесь]</a>.

</details>

Первый практический шаг после установки Laravel - это создание нужных маршрутов в файле `.\routes\web.php`. Маршрут представляет из себя как бы правило, что нужно дальше делать серверу при получении URI-запроса.  Технически для этого с помощью методов (`get()`,`post()` и пр.) создаются объекты класса `Route` и помещаются в упорядоченную коллекцию массив. При создании такого объекта-маршрута в первом аргументе указывается адрес (URI) страницы сайта, а во втором - callback-функция (замыкание), возвращающая содержимое веб-страницы в случае, если входящий запрос соответсвует URI из первого аргумента. При работе только со статическими страницами браузер посылает обычные GET-запросы, поэтому на первом уровне нашего гида мы будем создавать маршруты преимущественно с помощью метода `get()`. 


### Разновидности направлений марштрутов

При обработке браузерного запроса происходит перебор массива с объектами-маршрутами, и в случае совпадения URI запроса с шаблоном URI, хранящемся в объекте-маршруте, перебор прекращается и объект приступает к обработке запроса.

Для создания новых собственных маршрутов дополним файл `.\routes\web.php` таким фрагментами кода, вызывающего нужные методы:

#### 1. Вывод простого текста

>⇩⇩⇩ `.\routes\web.php` ⇩⇩⇩

```php
	Route::get('/hello', function () {
  	  return 'Hello World!';
	});
```
по адресу http://127.0.0.1:8000/hello появится текст `Hello World!`

#### 2. Вывод ответа сервера с заголовком и/или кодом ответа

Объекты класса `Responce` обладают методом `header`, который добавляет к ответу заголовок `<head>`.
```php
    Route::get('/hello-head', function () {
        return response('Привет!') -> header('Content-Type', 'text/plain');
    });
```

Вторым аргументом можно указать код ответа, отличный от 200:
```php
    Route::get('/empty', function () { // Можно указать код ответа, отличный от 200
        return response('Здесь ничего нет.', 403);
    });
```
Для пустых ответов может также пригодится response-метод `noContent()`:
```php
    Route::get('/empty2', function () {
        return response()->noContent();
    });
```


#### 3. Вывод одного из представлений (view), заданного blade-шаблоном:
```php
	Route::get('/welcome_to_laravel', function () {
   		return view('welcome');
	});
```
По адресу http://127.0.0.1:8000/hello отобразится шаблон из файла `.\resources\views\welcome.blade.php`

То же самое более компактно - через метод view класса Route:
```php
	Route::view('/welcome2_to_laravel', 'welcome');
```

#### 4. Вызов одного из контроллеров с последующим ответом от него

Правильный подход - описывать колбэк не в виде анонимной-функции прямо в теле объявления маршрута, а выносить в один из конроллеров в виде его метода.

##### Создание контроллера
Для этого создатим новый пустой контроллер с именем `SimpleController`. Классически это делается консольной командой:

>⇩⇩⇩ Команда консоли в корневой папке laravel-проекта ⇩⇩⇩


```Bash
	php artisan make:controller SimpleController
```
В результате выполнения команды будет создан файл `.\app\Http\Controllers\SimpleController.php` с одноимённым пустым классом. Но также можно создать файл вручную, и сразу добавить код нужных колбэк-методов. В итоге после всех манипуляций в 10-й версии Laravel код будет выглядеть так:

>⇩⇩⇩ `app\Http\Controllers\SimpleController.php` ⇩⇩⇩

```php
<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;

class SimpleController extends Controller
{
    // Колбэк-методы, вызываемые объектами-маршрутами:

    public function showText() {
        return 'Привет от контроллера!'; // Возврат простого текста
    }

    // Возврат шаблона `resources\views\welcome.blade.php`:
    public function showWelcome() {
        return view('welcome');
    }
}
```
##### Использование контролера в маршрутах

После того как контроллер подготовлен, можно продолжить добавлять в файл `.\routes\web.php` новые маршруты к этим методам контроллера. Вызов callback-методов, находящихся внутри класса, делается указанием массива из двух строк (полного пути к классу и имени метода):
>⇩⇩⇩ `routes\web.php` ⇩⇩⇩
```php
	Route::get('/ctrl-hello', ['App\Http\Controllers\SimpleController', 'showText']);
```

Теперь по адресу http://127.0.0.1:8000/ctrl-hello можно увидеть ответ от контроллера.

Если подключить контроллер директивой `use`, то можно не писать полный путь к нему, а через краткое имя обратиться к встроенной константе `class`, хранящей полное имя класса:
```php
	use App\Http\Controllers\SimpleController;
	Route::get('/ctrl-hello2', [SimpleController::class, 'showText']);
```

#### 5. Вызов контроллера с дальнейшим показом blade-шаблона
Выше мы уже создали в контроллере новый метод showWelcome(), который возвпащает коллбэк-функцию view(). Использование контроллера для загрузки  blade-шаблон - классический MVC-способ генерации страниц со стороны сервера:

```php
    Route::get('/ctrl-welcome', [SimpleController::class, 'showWelcome']);
```

Теперь по адресу http://127.0.0.1:8000/ctrl-welcome отображается шаблон `resources\views\welcome.blade.php`, поскольку его отображение прописано в контроллере.

#### 6. Переадресация
Простой редирект с кодом возврата 302:
```php
    Route::redirect('/hi', '/hello'); 
```
Третьим параметром можно указать другой код возврата:
```php
    Route::redirect('/hi2', '/hello', 301); 
```
Такой же код 301 возвращает метод `permanentRedirect`
```php
    Route::permanentRedirect('/hi3', '/hello'); 
```
Также переадресацию, скачивание файлов и много других вещей можно делать с помощью специалных response-методов. Но всё это обычно прописыватся внутри контроллеров, а не в самих маршрутах - а значит может считаться различными вариантами ответов от контроллера.

#### 7. Запасной маршрут
Если входящий запрос не соответствует ни одному из предыдущих маршрутов, то его можно обработать методом `fallback`, который направит запрос по маршруту вместо ответа `404 - страница не найдена`:
```php
	Route::fallback([Controller::class, 'showText']);
```

#### Иллюстрация маршрутизации
Наглядная схема, показывающая как эти 7 вариантов маршрутов работают (в квадратных скобках указаны номера, соответвующие одному из вышеперчисленных вариантов):
![схема](.\images\Level_0-Routes.png)

### Именованные маршруты

Сами по себе маршруты создаются как безымянные объекты, доступные через коллекцию, в которой хранятся. Но есть возможность задавать им уникальные  имена и через эти имена обращаться напрямую к объектам-маршрутам:
```php
	Route::get('materials/page1', function () {
        return 'Это страница, на которую ведёт маршрут page1';
    })->name('page1');  // Метод `name()` задаёт маршруту имя
```

Теперь, когда у маршрута есть имя, появляется возможность через имя маршрута получить строку URL, на которую этот маршрут отзывается - а значит это можно использовать для создания однозначно рабочей ссылки, связанной с этим именнованным маршрутом. Такую ссылку в виде строки возвращает глобальная функция `route()`:
```php
    Route::get('where_is_page1', function () {
        $url = route('page1'); // В строке $url - URI маршрута 'page1'
        return 'Страница page1 находится по адресу: ' . $url;
    });
```

Обратите внимание, что если мы в объявлении самого маршрута page1 произвольно изменим URI-адрес (в первом параметре метода `get()`), то по адресу http://127.0.0.1:8000/where_is_page1 отоброзится этот новый URL. Т.е. повсеместное применение функции `route()` при создании ссылок на страницы сайта позволяет в дальнейшем спокойно менять адреса страниц в файле маршрутов `routes\web.php` и не переживать, что где-то в другом месте приложения ссылки на эти страницы станут не рабочими.

### Получение полного списка маршрутов

В процессе разработки приложения список маршрутов можно просматривать локально, выполнив в консоли команду `php artisan route:list`. Но также можно работать со списком и в самом приложении. Для этого есть метод `getRoutes()`, который возвращает коллекцию, в которой хранятся маршруты. Выведем список URI и соответвующие им контроллеры на странице http://127.0.0.1:8000/routes_list

```php
    Route::get('routes_list', function () {
        $routeCollection = Route::getRoutes(); // Получаем коллекцию маршрутов
        $str = '<br>'; // В цикле будем добавлять всю информацию в эту строку
        foreach ($routeCollection as $value) {
                $str = $str . $value->uri() . ' | ' . // Значение URI
                $value->getActionName() . '<br>'; // Имя контроллера и метод
        }
        return 'Список URI, контроллеров и методов для всех маршрутов: ' . $str;
    });
```

## Создание HTML-шаблонов

Для генерации статических HTML-страниц Laravel использует встроенный шаблонизатор Blade. HTML-шаблоны располагаются в папке `resources\views\ `  Если в методе `Route::view()` или глобальной функции view() указать имя шаблона, например `name`, то фреймворк возвратит содержимое файла `name.blade.php` из этой папки.

### Создание файла `.blade.php`

Создадим новый шаблон с названием `landing1`. Для этого достаточно просто создать пустой файл `resources\views\landing1.blade.php`, и далее напонять его HTML-кодом.
Но чтобы не ошибиться в формате имени файла и в пути, где его следует расположить, можно в корне проекта выполнить консольную команду:

>⇩⇩⇩ Команда консоли в корневой папке laravel-проекта ⇩⇩⇩

```Bash
	php artisan make:view landing1
```

Теперь в созданном файле можно написать HTML-код, например такой:

>⇩⇩⇩ `resources\views\landing1.blade.php` ⇩⇩⇩

```php
	<div>
    	<p> Приветсвуем Вас на странице Landing1 !!! </p>
	</div>
```

### Связывание шаблона с маршрутом

После создания файла шаблона его содержимое можно выдавать в качестве ответа сервера с помощью колбэков `view()`. Для этого создадим в файле маршрутов ещё один маршрут:

>⇩⇩⇩ `routes\web.php` ⇩⇩⇩

```php
	Route::view('/landing_page1', 'landing1');
```

То же самое можно сделать из метода контроллера:

>⇩⇩⇩ `app\Http\Controllers\SimpleController.php` ⇩⇩⇩

```php
	public function showWelcome() {
        return view('landing1');
    }
```

### Размещение шаблона в посторонней папке

Весь демонстрационный код маршрутов, контроллеров и т.п. у нас содержится в папке `democode` - так легче просматривать и изучать созданные нами файлы и блоки кода, поскольку они не перемешаны со стандартными файлами фреймворка. Для обычного PHP-кода это не составляет проблемы, т.к. его можно подключить из любого места выражением `require <полный путь к php-файлу>`. Но в случае HTML-шаблонов такой фокус не срабатывает - стандартные настройки Laravel дают возможность искать и подключать шаблоны только в пределах папки `resources\views\`.

Однако можно расширить список папок для поиска шаблонов. Для этого нужно в файле `config\view.php` дополнить массив `paths` строками с новыми путями.
Скопируем созданный нами файл шаблона в папку `democode\level_0\resources\views` и добавим этот путь в упомянутый выше массив `paths`:

>⇩⇩⇩ `config\view.php` ⇩⇩⇩

```php
    'paths' => [
        resource_path('views'), // Стандартный путь Laravel
        // Дополнительные пути к пользовательским шаблонам:
        base_path() . "/democode/level_0/resources/views",
    ],
```

После этого потребуется обновить кэш конфигурации Laravel консольной командой:

>⇩⇩⇩ Команда консоли в корневой папке laravel-проекта ⇩⇩⇩

```bash
	php artisan config:cache
```

### Использование PHP-кода и переменных в шаблонах

#### Отображение значений строк в HTML-коде

В blade-шаблонах можно отображать значения строковых переменных либо результаты работы функций, возвращающих строку. Для этого переменную или PHP-код нужно оформить в т.н. выражение ввода - разместить внутри двойных фигурных скобок. Вот пример такого выражения:

>⇩⇩⇩ `resources\views\landing1.blade.php` ⇩⇩⇩

```php
	Текущая дата - {{ date("m.d.Y"); }}
```
#### Передача переменных в шаблон

Передать переменные в шаблон можно внутри view-объекта. Поместить переменные в объект представления можно, передав их имена и значения в виде ассоциативного массива во втором аргументе колбэка `view()`:

>⇩⇩⇩ `routes\web.php` ⇩⇩⇩

```php
    Route::get('/landing_page1a', function () {
        return view('landing1', ['var1' => 'Текст в переменной var1',
                                 'var2' => 'Текст в переменной var2']);
    });
```

Тот же самый результат даёт применение к view-объекту цепочки методов `with()`. Этот метод возвращает сам view-объект, добавляя в него указанную в аргументах переменную:

```php
    Route::get('/landingpage_1b', function () {
        return view('landing1') -> with('var1','Текст в переменной var1')
                                -> with('var2','Текст в переменной var2');
```

Теперь в самом шаблоне можно отобразить значения переменных, просто используя их имя внутри двойных фигурных скобок. Для случая, если какие-то из переменных не были переданы (например сработал другой маршрут), можно избежать появления ошибки `Undefined variable` путём использования условного оператора `??` :

>⇩⇩⇩ `resources\views\landing1.blade.php` ⇩⇩⇩

```php
	При вызове шаблона получена информация: <br> 
    {{ $var1 ?? "пусто" }} и {{ $var2 ?? "пусто" }}
```

#### Авто удаление HTML-символов для защиты от XSS-атак

Важно отметить, что при выводе строк с помощью двойных фигурных скобок к строке автоматически применяется php-функция `htmlspecialchars()` для предотвращения XSS-атак. Если требуется вывести строку без этой обработки, внутренние фигурные скобки нужно заменить на двойные восклицательные знаки. Сравните:

```php
	Защита включена:  {{  "<a href='spam'>Жми сюда</a>"  }}
    Защита выключена: {!! "<a href='spam'>Жми сюда</a>" !!}
```

#### Комментарии и отключение PHP-интерпретирования

Если двойные кавычки изнутри дополнить двойными минусами, то получится blade-комментарий, который не будет виден в итоговом HTML-коде. Сравните:

```php
	<!-- Видимый HTML-комментарий -->
    {{-- Невидимый blade-комментарий --}}
```

При этом помещённые внутрь HTML-комментария blade-директивы и переменные продолжают "срабатывать". Это может быть полезно для отладки:

```php
	<!-- Значение переменной: {{ $var1 ?? "пусто" }} -->
```

Если же нужно наоборот, показать сам код директивы без её срабатывания, нужно перед директивой поставить дополнительный символ `@`. Например:

```php
	@{{ этот код не сработает }}
	@@include(этот шаблон не подключится)
```

Отключить php-интерпретацию для целого блока кода можно директивой `@verbatim`:

```php
	@verbatim
    	{{ этот код не сработает }}
    	@include(этот шаблон не подключится)
    @endverbatim
```

#### Произвольный PHP-код

Назначение шаблонов - отображение HTML-страницы. Различные же вычисления нужно производить в предназначенных для этого контроллерах. Тем не менее (для крайних случаев), в Laravel есть возможность вставлять в шаблоны произвольный PHP-код, обрамляя его директивами `@php` и `@endphp`. Внутри этих директив вывод информации на веб-страницу делается стандартными механизмами вывода (`echo` и т.п.)

```php
	@php
		$i=sqrt(2);
        echo "<br>Корень из двух равен " . $i;
    @endphp
    <br> Значение переменной `i` сохранилось: {{ $i }}
```

Если php-код нужен только для подключения класса, то удобнее использовать директиву `use`, в которой вторым необязательным аргументом можно указать псевдоним для этого класса:

```php
	@use('App\Http\Controllers\SimpleController','Simp')
    <br>Вызов статического метода класса: {{ Simp::showText2(); }}
```

Разумеется перед вызовом метода класса в самом классе нужно этот метод описать, так чтобы он был статическим и возвращал строку:

>⇩⇩⇩ `app\Http\Controllers\SimpleController.php` ⇩⇩⇩

```php
    public static function showText2() {
        return 'Привет от статического метода контроллера!';
    }
```

### Каталогизация шаблонов

Когда на сайте предусмотрено много различных страниц, то для удобства работы их шаблоны можно разложить в различные подпапки. Предположим, что на нашем сайте помимо лендинга предусмотрено несколько разделов. В этом случае можно в папке с шаблонами создать подпапку `section` и в ней размещать шаблоны страниц для этих разделов.

Создадим эту подпапку и в ней пару шаблонов:
>⇩⇩⇩ `resources\views\sections\topic1.blade.php` ⇩⇩⇩

```php
	<div>
    	<p> Приветсвуем Вас на странице Секции 1 !!! </p>
	</div>
```

>⇩⇩⇩ `resources\views\sections\topic2.blade.php` ⇩⇩⇩

```php
	<div>
    	<p> Приветсвуем Вас на странице Секции 2 !!! </p>
	</div>
```

Доступ к таким шаблонам в подпапках возможен через строку `<имя подпапки>.<имя шаблона>`:

>⇩⇩⇩ `routes\web.php` ⇩⇩⇩

```php
	Route::view('/topic1', 'sections.topic1');
	Route::view('/topic2', 'sections.topic2');
```

### Подключение дочерних шаблонов

При создании однотипных страниц неизбежно возникает ситуация, что многие страницы имеют одинаковые блоки. В обычных HTML-документах такие блоки пришлось бы дублировать на всех страницах, а в случае последующих правок - редактировать такой блок в каждой из страниц. Использование PHP позволяет вставлять содержимое одного файла в другой выражениями типа `require`, благодаря чему можно переиспользуемый код вынести в отдельные файлы, и при необходимости подключать в нужные места.

Шаблонизатор Blade имеет целых три инструмента для вставки внутрь шаблона переиспользуемого кода:

1. Дочерние шаблоны.
2. Наследуемые шаблоны.
3. Компоненты

Для статических страниц подойдёт самый простой вариант - дочерние шаблоны. Допустим, мы решили на всех страницах сайта отображать главное меню. Для этих целей создадим файл `menu1.blade.php` с простейшей навигацией по трём страницам сайта:

```php
    <nav>
		<a href="{{ route('land1')  }}"> Главная  </a> |
        <a href="{{ route('topic1') }}"> Cекция 1 </a> |
        <a href="{{ route('topic2') }}"> Cекция 2 </a>
    </nav>
```

Теперь, кода дочерний шаблон подготовлен, его можно включить в шаблоны секций и в шаблон лендинга, добавив в нужном месте каждого из этих шаблонов директиву:

```php
	@include('menu1')
```

Дополнительно при подключении можно передать переменные в виде ассциативного массива во втором аргументе директивы в формате `@@include('имя шаблона',['имя'=>'значение', .. ])`: 

Напишем в шаблоне `landing1` директиву в таком виде:
```php
	@include('menu1', ['newvar1' => 'ещё одно значение'])
```

Если шаблон подключен в качестве дочернего, то в нём будут доступны все переменные родительского шаблона, а также переданные из родительского шаблона в виде ассоциативного массива. Убедиться в этом можно, добавив в дочерний шаблон этот коментарий и просмотрев его содержимое на загруженной родительской странице:

```php
	<!-- Значение переменной, переданной из колбэка: {{ $var1 ?? "пусто" }}
         Значение переменной newvar1, переданной из родительского 
		 шаблона: {{ $newvar1 ?? "пусто" }}
	-->
```

