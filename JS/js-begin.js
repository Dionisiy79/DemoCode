// "use strict";//  Однострочный комментарий до конца строки задается двумя косыми чертами в начале комментария
/*  Многострочный комментарий - обрамляется парой символов "/" и "*" 
    В начале комментария символы идут в прямом порядке, а в конце - в обратном.
        https://learn.javascript.ru/structure#kommentarii
*/

/*  ОБЩИЕ СИНТАКСИЧЕСКИЕ ПРАВИЛА
    Команды в JS разделяются символом точки с запятой ";"
    Если символ ";" пропущен, но есть перевод строки, то интерпретатор может его 
        автоматически вставить, но надеяться на это не стоит.
        https://learn.javascript.ru/structure#komandy
    Блок операторов выделяется фигурными скобками {}
    Отключить выполнение кода можно поместив его внутрь блока if(0){  }
*/
"use strict"; /* Эта директива, если стоит первой, переводит интерпретатор в режим современного 
                 стандарта ES5. При этом теряется совместимость с IE9- и скриптами, 
                 написанными в старом стандарте.  https://learn.javascript.ru/strict-mode */

if(0){ "Невыполнящийся код" } // В коде не должно быть ошибок. Для включения нужно 0 заменить на 1.



{/*  КОМАНДЫ ВЗАИМОДЕЙСТВИЯ С ПОЛЬЗОВАТЕЛЕМ 
         https://learn.javascript.ru/uibasic
*/  
    // Вывод текстовых строк
        console.log('Hello World!');  // В консоль с переносом строки
        console.group("Некая группа строк 1");  // Объявление начала группы строк в консоли
            // Объявление свернутой группы строк, к тому же внутри первой группы:
            console.groupCollapsed("Свернутая группа строк 2"); 
            console.groupEnd("Свернутая группа строк 2"); // Объявление конца группы строк
        console.groupEnd("Некая группа строк 1"); 

    if(0){  // Демонстрация всплывающих окон (отключена)
        alert('Hello world!');        // В модальное веб-окно с ожиданием реакции пользователя
        document.write('Hello world!');  /* В текущее место веб-страницы 
            (после закрывающего тега </script>). Если скрипт выполнится не в процессе, а после 
             загрузки HTML-страницы то страница будет стерта и начата новая. */

    // Запрос пользователю ввести строку, которая будет сохранена в переменной inputStr
        var inputStr = prompt('Введите строку:', 'Текст по умолчанию'); 
    // Запрос пользователю ответить Да/Нет. Ответ будет сохранен в логическую переменную inputBool.    
        var inputBool = confirm("Вы подтверждаете запрос?"); 
    }
    /* Пауза на 3 секунды. Будет отложено выполнение только блока операторов функции func(). 
       Загрузка страницы и остальные скрипты на странице продолжат своё выполнение. */
        function func() { 
            console.log('Прошло 3 секунды.'); 
        }
        setTimeout(func, 3000);
}

{/* РАБОТА С ПЕРЕМЕННЫМИ   
        https://learn.javascript.ru/variables
    Имя переменной не должно начинаться с цифры и может состоять из букв, цифр, символов $ и _ 
    Регистр имеет значение.
*/
console.groupCollapsed("Переменные"); // Объявление начала свёрнутой группы строк

    // Объявление и инициализация переменных
        var str1; /* Новая переменная объявляется с помощью ключевого слова var. 
                     Это можно делать в любом месте кода. Если var не указать, то 
                     создаётся не переменная, а свойство глобального объекта window.
                        https://learn.javascript.ru/variables#vazhnost-direktivy-var */
        var numb1 = 546; // При объявлении переменной можно сразу инициализировать её значение.
        var str2, b, i, j, numb2, numb3 = 123; // Можно объявить несколько переменных через запятую.
        numb3 = "Строка"; /* Тип переменной не фиксирован и в любую переменную могут быть 
                            записаны данные любого типа */
        var NUMBER_PI = 3.14;  /* В JS нет констант, поэтому принято вместо констант использовать 
              переменные названные прописными буквами и просто не менять их значения в дальнейшем.*/
    
        //  Простые типы данных в JS      https://learn.javascript.ru/types-intro
        numb2 = 456;      // Для чисел используется стандарт IEEE-754 64-битный с плавающей точкой
        numb2 = 789;      // Проинициализированную переменную можно заменить новым значением.
        numb1 = 123.789;  // Для задания вещественного числа используется разделитель - точка
        numb1 = 3.2e5;    /* = 320000   Запись в научном формате. После символа "e" задаётся 
                             сдвиг запятой вправо для десятичного числа */
        numb1 = 3.2e-5;   /* = 0.000032 Отрицательное число сдвигает запятую влево, 
                             задавая десятичную дробь */
        numb2 = Infinity; /* Спец.значение "бесконечность" используется в случае деления на ноль 
                             или превышения максимального значения для числа */
        numb3 = NaN;  // Спец.зачение "Not a Number" используется для обозначения ошибки вычислений
        
        // Задание целых 32-битных чисел в других системах счисления 
        numb2 = 0xF0; // Шестнадцатиричное число начинается с 0x
        numb2 = 0o70;  // Восьмиричное число начинается с 0o
        
            // Можно использовать функцию parseInt() задав строку с числом и основание (от 2 до 36)
            // http://javascript.ru/ParseInt
        numb2 = parseInt("F57", 16);      // Шестнадцатиричное число
        numb2 = parseInt("4651", 8);      // Восьмиричное число
        numb2 = parseInt("10011110", 2);  // Двоичное число
        numb2 = parseInt("-10011110", 2); // Знаком минус можно задать отрицательное значение
        numb2 = parseInt("14fdnv5z", 36); // Закодированный буквами номер телефона 88001234567  
        
        var bool1 = true;   // Логический тип "истина"
            bool1 = false;  // и "ложь"
    
        str1 = "Тестовая строка";       // Строки задаются двойными или одинарыми кавычками
        // Для использования в строке двойных кавычек можно обрамлять её в одинарные кавычки:
        str1 = 'Тестовые "кавычки"';    
        str1 = "Тестовые \"кавычки\"";  // либо использовать экранирующий символ  "\"
        str1 = " \\ ";  // Для сохранения экранирующего символа его нужно написать дважды 
        str1 = "Первая строка\nВторая строка"; // Перенос строки: \n
        str1 = "\t \r \b \f"; // Символы  Tab | Return | Backspace | Form feed (новая страница)
        str1 = "\u005A";      // Символ в кодировке Unicode
        
        str2 = null;        // Специальный тип означающий "неизвестное значение"
        str1 = undefined;   // Специальный тип означающий "переменная неинициализирована". 
        
        /* Для проверки типа переменной можно применить оператор typeof, который возвращает 
           такие значения: "number", "string", "boolean", "undefined", "object" */
        str1 = typeof str2; // Для переменных типа null оператор возвращает значение "object"

    // Использование переменных
        /* Проверка, является ли переменная инициализированной. 
           Работает независимо от того, объявлена ли переменная. */
        if (typeof newVar == "undefined") { 
            console.log('Переменная newVar не инициализирована') 
        };
        console.log(str1); // Вывод значения переменной в консоль
        
        numb2 = numb1; // Запись значения переменной в другую переменную.
        numb2 = numb2 / numb1; /* В выражениях для присвоения нового значения можно использовать 
                                  эту же переменную, пока в ней хранится старое значение. */
console.groupEnd("Переменные");
} 

{/* ОПЕРАЦИИ
    https://learn.javascript.ru/operators
    https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence */
console.groupCollapsed("Операции");       

    numb1 = numb2 = 5;          /* Оператор присваивания тоже возвращает значение, которое можно 
                                  использовать в предыдущем операторе присваивания */
    console.log(numb1 = 7 + 5); /* или в выводе на экран. Сам оператор правоассоциативный - т.е. 
                                   вычисления последовательности операторов идут справа налево. */
    
    /* Арифметические операции */
        numb1 = ( 7 + 2 - 3 ) * 4 / 5; // Сложение вычитание умножение и деление для чисел.
        numb1 = 31 % 8;    // Остаток от деления
        numb1 = 2 ** 3.5;  // Возведение в степень
        numb1 = 2 ** -2;   // == 0.25 Отрицательная степень (сколько раз разделить единицу на число)      
        Math.pow(2,-3.5);  // Аналогичное действие у функции Math.pow() 
        // Для вычисления корня можно использовать возведение в дробную степень
        numb1 = Math.sqrt(9);  // == 3   Корень квадратный их числа
        
        // Справедливы следующие соответствия (результат нижеприведенных сравнений == true)
            // https://learn.javascript.ru/number#delenie-na-nol-infinity
        b = 1 + Infinity  === Infinity     &&  
            1 - Infinity  === -Infinity    &&
            1 / Infinity  === 0            &&
           -1 / Infinity  === -0           && // минус ноль (бесконечно малое отрицательное число)
            1 / 0         === Infinity     &&
        ""+ 0 / 0         === "NaN"        && // Не допустимы: деление 0 на 0,
        ""+ 0 * Infinity  === "NaN"        && // умножение нуля на бесконечность,
        ""+(5 + NaN)      === "NaN"        && // арифметические операции с NaN,
        ""+ Infinity / Infinity  === "NaN" && // деление двух бесконечностей,
        ""+(Infinity - Infinity) === "NaN" && // вычитание двух бесконечностей.
            isNaN(0/0)  && // Функция isNaN(n) возвращает true если её аргумент NaN
            isFinite(5);   // isFinite(n) возращает true если её аргумент - конечное число    
        console.log("Результат проверки всех особых операций с числами: " + b);
    
    /* Унарные операции */
        i = +numb1;   // Унарный оператор подтверждения знака (приводит другие типы к числу)
        i = -numb1;   // Унарный оператор смены знака.
        j = ~i;       /* Побитовая инверсия - вычитание из -1 (смена знака и декремент). 
                         Инверсия полезна в связке с операцией смены знака: */
        j = -~i;      // Инкремент числа. Унарный аналог j = i+1 
        j = ~-i;      // Декремент числа. Унарный аналог j = i-1
        i = -~ 2 * 6; /* Результат равен 18, а не 13, поскольку у унарных операторов 
                         приоритет выше чем у операций умножения и деления."  */
    
        i++; /* Постфиксный инкремент переменной. Возвращает значение переменной ДО операции 
                инкремента и увеличивает значение переменной на 1. */
        i++; /* Постфиксный декремент переменной. Возвращает значение переменной ДО операции 
                декремента и уменьшает значение переменной на 1. */
        ++i; /* Префиксный инкремент переменной. Возвращает значение переменной ПОСЛЕ операции 
                инкремента. Унарный аналог i = i+1. */
        ++i; /* Префиксный декремент переменной. Возвращает значение переменной ПОСЛЕ операции 
                декремента. Унарный аналог i = i-1. */
    
    /* Побитовые операции над 32-битной целой частью числа. Дробая часть теряется. 
       Имеют низкий приоритет поэтому часто требуют обрамления скобками.
            https://learn.javascript.ru/bitwise-operators  */
        i = i << 5;  /* Побитовый сдвиг влево на указанное число бит с сохранением знака 
                        (умножение на степень двойки ). */
        i = i >> 2;  /* Побитовый сдвиг вправо на указанное число бит с сохранением знака 
                        (деление на степень двойки). */
        i = i >>> 1; /* Побитовый сдвиг вправо на указанное число бит 
                        c заполнением освободившихся бит нулями. */
        i = i & 5;   // Побитовое И (AND). Используется для установки в нужные биты значения 0.
        i = i | 5;   // Побитовое ИЛИ (OR). Используется для установки в нужные биты значения 1.
        i = i ^ 5;   /* Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR). 
                        Используется для смены значений нужных битов на противоположные. */
    
    /* Комбинированные операторы присваивания */
        i += 5; i -= 5;   // Увеличить или уменьшить переменную на указанное число.
        i *= 3; i /= 3;   // Умножить или поделить переменную на указанное число.   
        i %= 10;          // Записать в переменную остаток от деления её на указанное число; 
        i <<= 2; i >>= 2; // Сдвинуть биты переменной влево или вправо на указанное число позиций.
        i >>>= 2;         // Сдвиг битов переменной с заполнением нулями.
        i &= 5; i |= 5; i ^= 5;   // Поменять значение нужных бит на 0, 1 или противоположное.
        
    /* В качестве оператора последовательных операций в одной строке используется символ запятой. 
       Имеет самый низкий приоритет (нужно обрамлять его в скобки) и возвращает 
       только последнее вычисленное значение в последовательности: */
        numb1 = (i = 3, j = 2, i + j); // Используется для сокращения кода и мимоходных присвоений. 
    
    /* Операторы сравнения и логические операторы: 
            https://learn.javascript.ru/comparison  */
        // Во всех нижепреведенных сравнениях результат равен True  
        b = 2 == '2'   && // Нестрогое равенство (c приведением типов)
            2 != '3'   && //     и нестрогое неравенство
            2 === 2    && // Строгое равенство (без приведения типов)
            2 !== '2'  && //     и строгое неравенство
            bool1 != !bool1      && // Отрицание
            (1 >= 1) && (2 > 1)  && // Логическое "И" (конъюнкция)
           ((1 <= 1) || (2 < 1)) && // Логическое "ИЛИ" (дизъюнкция) - имеет более низкий приоритет
            NaN != NaN           && // NaN не равен ничему - даже самому себе
            null == undefined    && // null и undefined нестрого равны, но не равны ничему другому
            null >= 0            && // При сравнении null приводится к нулю, 
            null != 0            && //     но при этом null != 0.
            "Строка 2" > "Строка 1"; // Строки сравниваются побуквенно по кодам символов Unicode
        console.log("Результат всех сравнений и логических операций: " + b);
    
    /* Конкатенация строк: через бинарный оператор +  */
        str1 = str1 + "строка2"; 
    
    /* Особенности арифметического переполнения и искажений хранения */
        /* 32-битная операция умножения целого числа на 2 путем сдвига влево вызовет 
           переполнение на меньших числах, чем обычное умножение 64-битного вещественного */
        console.log("Переполнение: вместо 20000000000 получаем " + (10000000000 << 1)); 
        numb1 = Number.MAX_SAFE_INTEGER; /* 9007199254740991 - это максимальное целое число 
                                            которое сохранится без искажений */
        bool1 = (numb1+1) == (numb1+2) // Результат True - обе суммы дают результат 9007199254740992 
console.groupEnd("Операции");
}

{/* ПРИВЕДЕНИЕ ТИПОВ ПРИ ОПЕРАЦИЯХ 
       https://learn.javascript.ru/types-conversion  
*/  
console.groupCollapsed("Приведение типов при операциях");

    // Автоматическое строковое преобразование
        str1 = 1 + '2'; /* == 12. Если один из двух операндов при сложении является строкой, 
                           то производится конкатенация строк, а не арифметическое сложение. */
        
        str1 = 1 + 2 + 3 + '4' + 5 + 6; /* == 6456. Несколько операций сложения подряд выполняются 
             слева направо. Пока операнды чиловые происходит арифметическое сложение. Но как только 
             поступает строковый операнд, все остальные операции будут соединять строки. */
        
        console.log(numb1); // Там где ожидается строка простые типы приводятся к строке.

    // Явное строковое преобразование
        str1 = String( bool1 );  /* Функция string преобразует любой тип в строку.   
                                    http://javascript.ru/String   */
        str1 = "" + true + 25 + null; // Явно приводит к строке конкатенация с пустой строкой.

        // Справедливы следующие равенства:
        b = "" + undefined  === "undefined" &&  
            "" + null       === "null"      &&
            "" + NaN        === "NaN"       &&
            "" + Infinity   === "Infinity"  &&
            "" + true       === "true"      &&
            "" + false      === "false";     
        console.log("Результат проверки всех преобразований в строку: " + b); // true
        
        /* Приведение числа к строке в разных системах счисления
                https://learn.javascript.ru/number#tostring-sistema-schisleniya
            toString(n) - метод численных значений, возвращающий 
                          строку в системе счисления по основанию n */
        numb1 = 175; numb2 = 3.14;
        // Справедливы следующие равенства:
        b = numb1.toString()   === "175"      && // По умолчанию используется десятичная система
            numb1.toString(16) === "af"       && // Представление числа как шестнадцатиричное,
            numb1.toString(2)  === "10101111" && // двоичное.
            numb1.toString(36) === "4v"       && /* Максимальное основание 36 - использует цифры 
                                                    и все латинские малые буквы */
            numb2.toString()   === "3.14"     && // Вещественные числа тоже допустимы
            numb2.toString(36) === "3.51fu8n1fu9";  // в любых системах счисления
        console.log("Результат проверки всех вызовов toString: " + b); // true
        
        // Приведение числа к строке в национальном формате
                // https://learn.javascript.ru/intl
        numb1 = 1234567.12345;
        str1 = numb1.toLocaleString(); // "1 234 567,123"  

    /* Автоматическое численное преобразование. 
       Происходит при арифметических операциях и сравнениях с числами. */
        // Если при сложении среди операндов нет строки, то все операнды приводятся к числу:
            i = 1 + null + true; // 2
        // С другими арифметическими операциями все строки всегда приводятся к числу:
            i = '1' / '2' - '3' * '4' % '5';  // -1.5
        // Результат равен NaN в случае если хотя бы одна строка дала ошибку преобразования:
            i = '1' - '2б';  // NaN
        /* Операции сравнения == < <= > >= приводят свои операнды к числу 
           (за исключением если они оба - строки)  */
        
    // Явное численное преобразование
        i = + '789';       // Унарный плюс приводит любой операнд к числу
        i = Number('789'); // Тот же эффект у функции Number()
        i = + '  \n 789 '; /* При преобразовании строки в число пробельные символы 
                              по краям обрезаются (включая переносы строк) */

        // Приведение целого числа к вещественному не нужно, т.к. все числа хранятся вещественными
        /* Приведение вещественного числа к целому:
                 https://learn.javascript.ru/number#okruglenie  */
            numb1 = Math.floor(3.2);  // == 3  Округление числа вниз
            numb1 = Math.ceil(3.2);   // == 4  Округление числа вверх
            numb1 = Math.round(3.2);  // == 3  Округление до ближайшего целого
            numb1 = 3.14159;
            numb2 = numb1.toFixed(2); // == 3.14  Метод toFixed(n) округляет до n знаков после точки
            numb2 = numb1 ^ 0; /* Если для хранения целой части хватает 32 бит, 
                                  то её удобно получать применением побитовой операции XOR */
        
        /* Функции парсинга строки считывают число из начала строки даже если после цифр идут буквы. 
                https://learn.javascript.ru/number#myagkoe-preobrazovanie-parseint-i-parsefloat */
        // Справедливы следующие равенства:
        b = parseInt('45px')    ===  45 &&  // parseInt() - функция парсинга целого числа   
            parseInt('87.95 р') ===  87 &&  // Парсинг целого числа заканчивается на точке 
            parseInt('3.2e5')   ===   3 &&  // Научный формат как целое число НЕ распознается
            parseInt('0x10')    ===  16 &&  // Шестнадцатиричное число обрабатывается корректно
            parseInt('010')     ===  10 &&  // Восьмиричное число обрабатывается как десятичное. 
            // Для произвольных систем счисления можно вторым аргументом указать основание:
            parseInt('100',2)   ===   4 &&  // Двоичное число
            parseInt(' \n 5px') ===   5 &&  // Допустимы пробелы и переносы строки вначале
            isNaN(parseInt(""))         &&  // Если в строке нет цифр, то результат NaN     
            isNaN(parseInt("$25"))      &&  // Если первый значимый символ не цифра или пробел - NaN
            isNaN(parseInt('Infinity')) &&  // Бесконечность не является целым числом - NaN     
            parseFloat('45.8px')   === 45.8  && // parseFloat - функция парсинга вещественного числа   
            parseFloat('87.95.38') === 87.95 && // На второй точке парсинг останавливается
            parseFloat('3.2e-2')   === 0.032 && // Научный формат парсится корректно для вещ.чисел
            parseFloat('0x10')     === 0     && // Шестнадцатиричное число не парсится как Float
            parseFloat('Infinity!') === Infinity;  // Бесконечность распознается как вещественное 
        console.log("Результат проверки всех парсингов чисел: " + b); // true
                 
        // Также справедливы следующие равенства
        bool1 = isNaN(+ undefined) &&  
                isNaN(+ "123 456") && // Пробел внутри строки недопустим
                + ""    === 0      && // Пустая строка даёт 0
                + null  === 0      && 
                + true  === 1      &&
                + false === 0;         
        console.log("Результат проверки всех преобразований в число: " + bool1); // true
        
        // Проверка, является ли переменная числом:
            if (!isNaN(parseFloat(numb1))) // Такая проверка отсекает значения "", null, true, false
                console.log("В переменной Numb1 хранится число.");
            if (!isNaN(parseFloat(numb1)) && isFinite(numb1)) // + отсечение бесконечных значений
                console.log("В переменной Numb1 хранится конечное число.");
    
    // Автоматическое логическое преобразование - там где ожидается логическое значение.
        if (numb1) j=5; // Если число numb1 отлично от 0 или NaN, то выполнится операция j=5
        if (str1) j=5;  // Если строка str1 не пустая, то выполнится операция j=5.
        
        /* Операции && и || используют логический эквивалент операндов, 
           но возращают непреобразованное значение. */
            bool1 = numb1 && str1;  // В bool1 запишется число или строка, но не true или false 
        
        /* В последовательности логических И/ИЛИ возвращается первое слева значение, 
           которое приводится к false/true. Если таковых нет, то возвратится последнее 
           значение в последовательности. 
                https://learn.javascript.ru/logical-ops#korotkiy-tsikl-vychisleniy  */
            i = 1 && 2 && 3 && 0 && 4 && 5; // i==0 
            str1 = "" || 0 || "abc" || "";  // str1=="abc" 
            // При этом над оставшимися операндами вычисление не производятся:
            (numb1 = 0) || (numb2 = 5) || (numb3 = 10); /* В numb3 ничего не будет записано, так как 
                                                   на операнде (numb2 = 5) вычисления прекратятся */
    
    // Явное логическое преобразование        
        bool1 = !!789; // Два логических НЕ подряд приводят любой операнд к логическому    
        bool1 = Boolean(789); // Тот же эффект у функции Boolean() 

        // Справедливы следующие равенства
        bool1 = ( !! " "  === true  ) &&  // Пробел не является пустой строкой
                ( !! ""   === false ) && 
                ( !! 0    === false ) && 
                ( !! NaN  === false ) &&  // Все остальные числа дают true
                ( !! null === false ) && 
           ( !! undefined === false );    // Все остальные значения и объекты преобразуются в true
        console.log("Результат проверки преобразований в логическое значение: " + bool1); // true
console.groupEnd("Приведение типов при операциях");        
}

{/* МАТЕМАТИЧЕСКИЕ ФУНКЦИИ */  
console.groupCollapsed("Математические функции и работа со строками");
    // https://learn.javascript.ru/number#drugie-matematicheskie-metody  

    numb1 = Math.PI;  // Число Пи == 3.141592653589793
    numb1 = Math.E;   // Число e  == 2.718281828459045
    numb1 = Math.random();    // Генерация псевдослучайного числа:  0 <= Math.random() < 1. 

    numb1 = Math.abs(-3.14);  // == 3.14  Абсолютное значение числа
    numb1 = Math.log(10);     /* Натуральный логарифм числа. 
                                 log(x) - степень в которую нужно возвести e чтобы получить x. */
    numb1 = Math.exp(1);      // Натуральная экпонента. exp(x) == e в степени x.
        console.log("Число e: " + numb1);
    numb1 = Math.max(2,-1,7); // Максимальное число из перечисленных аргументов
    numb1 = Math.min(2,-1,7); // Минимальное число из перечисленных аргументов
    
    // Тригонометрические функции
    numb1 = Math.sin(3.14/2); // Синус числа (для числа Пи/2 равен 1)
    numb1 = Math.cos(3.14);   // Косинус числа (для числа Пи равен -1)
    numb1 = Math.tan(3.14/4); // Тангенс числа (для числа Пи/4 равен 1)
    
    numb1 = Math.asin(1);     /* Арксинус числа (для числа 1 равен Пи / 2). 
                                     Аргумент должен быть <= 1 по модулю. Иначе - NaN */
    numb1 = Math.acos(-1);    /* Аркосинус числа (для числа 0 равен Пи). 
                                    Аргумент должен быть <= 1 по модулю. Иначе - NaN */
    numb1 = Math.atan(1);     // Арктангенс числа (для числа 1 равен Пи/4)
    // Арктангенс по координатам точки (y,x) на плоскости:
    numb1 = Math.atan(-5,5);  // для угла 315 градусов равен Пи/4
        // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2
}        

{/* РАБОТА СО СТРОКАМИ */
        // https://learn.javascript.ru/string   
    str1 = "Тестовая строка";
    numb1 = str1.length;  // Длина строки возвращается свойством .length 
    
    // Посимвольное чтение строки (перезапись символа в существующей строке недоступна). 
    str2 = str1.charAt(0);  // Метод charAt(N) возращает N-й символ строки (нумерация с 0)
    str2 = str1[0]; // Альтернативный способ получения N-го символа
    bool1 = str1.charAt(30) === "";  // Если символа нет charAt() возращает пустую строку,
    bool1 = str1[30] === undefined;  // а доступ с помощью квадратных скобок - undefined.
    
    // Смена регистра символов
    str2 = str1.toUpperCase(); // Метод .toUpperCase() возвращает строку в верхнем регистре 
    str2 = str1.toLowerCase(); // Метод .toLowerCase() возвращает строку в нижнем регистре 
    
    // Поиск позиции подстроки в строке
    str2 = str1.indexOf("ока");  // == 12   Метод .indexOf() возвращает позицию подстроки в строке
    str2 = str1.indexOf("ст",6); // == 9    Вторым аргументом можно указать позицию начала поиска
    str2 = str1.indexOf("Ст");   /* == -1   Поиск чувствителен к регистру. 
                                    Если ничего не найдено метод возвращает значение -1  */
    // Аналогичный поиск с конца строки, начиная с указанной позиции
    str2 = str1.lastIndexOf("ст",6); // == 2  
    
    // Поиск всех вхождений подстроки в строку
    i = -1;
    while ((i = str1.indexOf("т", i+1)) != -1) { 
        console.log("Подстрока найдена в позиции " + i);
    }

    // Проверка входит ли подстрока в строку удобно делается синтаксическим сахаром:
    if (~str1.indexOf("ока")) {  // Побитовый оператор ~ для -1 даст 0, иначе - отрицательное число
        console.log("Подстрока найдена.");  
    };
    
    // Получение подстроки. Доступно три метода:
    
    // .substring()  - по позициям границ подстроки
    str1 = "1234567890";
    str2 = str1.substring(5);    // == "67890" (считать строку начиная с указанной позиции 9)
    str2 = str1.substring(5,8);  // == "678"  (2-й параметр - перед каким символом остановиться)
    str2 = str1.substring(8,5);  // == "678"  (если второй параметр меньше, то они меняются местами)
    str2 = str1.substring(-2,4); // == "1234" (отрицательные числа меняются на 0)
    
    // .substr()  - по отступу с начала или конца строки и длине результата:
    str2 = str1.substr(5,3);     // == "678"   (2-й параметр - сколько символов прочитать)
    str2 = str1.substr(5);       // == "67890" (2-й параметр можно не указывать)
    str2 = str1.substr(-6,4);    // == "5678" (отрицательное число - номер позиции с конца строки)
    str2 = str1.substr(6,-4);    // == ""     (отрицательное число во 2-м параметре - то же что 0)

    // .slice()  - по двум отступам с начала или конца строки:
    str2 = str1.slice(-6);       // == "567890" (без 2-го параметра метод работает как substr())
    str2 = str1.slice(5,8);      // == "678"  ( 2-й параметр похож на substring() но:
    str2 = str1.slice(5,-1);     // == "6789"   отрицательное значение - это позиция с конца строки 
    str2 = str1.slice(12,9);     // == ""       и параметры местами не меняются )                   
    
    // Получение кода символа - через строковый метод charCodeAt(n) где n - позиция символа в строке
        numb1 = "12345".charCodeAt(5);     // Код символа "4" == 52 
    // Получение символа по его коду:
        str2 = String.fromCharCode(numb1); // Коду 52 соответсвует символ "4"
    
    // Сравнение строк по кодам символов:
        // Справедливы следующие равенства:
        b = "ежик"== "ежик" &&  // Строки равны, если все их символы совпадают
            "ежик" > "еж"   &&  // При совпадении символов более длинная строка - больше 
            "ежик" < "лис"  &&  // Если код первого неравного символа больше, то вся строка больше
            "ежик" > "Лис"  &&  // Коды строчных букв больше прописных
            "ёжик" > "лис"  &&  // Буква ё идёт после основного алфавита
            "Ёжик" < "Лис";     // Буква Ё идёт перед основным алфавитом
        console.log("Результат сравнения строк по кодам символов: " + b); // true

    // Сравнение строк по алфавиту производится строковым методом .localeCompare()
        numb1 = "лис".localeCompare("лис");   // == 0  для равных строк
        numb1 = "ежик".localeCompare("лис");  // == -1 если первая строка меньше
        numb1 = "ежик".localeCompare("аист"); // == 1 если первая строка больше
        // Справедливы следующие равенства:
        b = "ежик".localeCompare("Ежик") == -1 && // Строчная буква меньше такой же прописной
            "Ежик".localeCompare("лис")  == -1 && // Алфавит идёт в порядке аАбБвВгГ и т.д.
            "ёжик".localeCompare("лис")  == -1;   // Буквы ёЁ обрабатываются корректно
        console.log("Результат сравнения строк по алфавиту: " + b); // true
        
console.groupEnd("Математические функции и работа со строками");        
}

{/* РАБОТА С ФУНКЦИЯМИ И ПРОЦЕДУРАМИ (ПОДПРОГРАММАМИ)  
        https://learn.javascript.ru/function-basics
    Функция   - это блок программы, который принимает на вход аргументы 
                и возвращает некое значение (или значения).
    Процедура - блок программы, которому могут передаваться или не передаваться на вход аргументы, 
                но который (в отличие от функции) не возвращает значения, а просто совершает некие 
                побочные действия (ввод/вывод, изменение значений глобальных переменных и т.д.).
    В JavaScript в качестве процедуры можно использовать функцию, которая не возвращает значения
    (такие функции возвращают undefined).
*/
console.groupCollapsed("Работа с функциями и процедурами");

    /* Объявление функции в режиме Function Declaration (допустимо в любом месте кода).
       После имени функции и круглых скобок задается блок операторов, являющийся телом функции: */
        function proc1() {  
            'use strict';   /* В начале функции можно задавать режим strict для интерпретатора. 
                               Он будет действовать в пределах функции */
            // Эта функция просто совершает побочное действие - выводит строку в консоль:                               
            console.log('Выполняется процедура proc1');  
        }
    
    // Использование функций
        proc1(); // Вызов функции без аргументов
        /* В круглых скобках через запятую можно передать в функцию произвольное количество 
           аргументов, даже если они не были объявлены при объявлении функции: */
        proc1("Строка1", "Строка2", 15, true );  
        proc2("Тестовый аргумент", 23); /* Если функция объявлена в режиме Function Declaration 
                                           вызов функции можно делать до объявления функции */
        
        /* Доступ к необъявленным аргументам в теле функции - через коллекцию arguments[]        
            https://learn.javascript.ru/arguments-pseudoarray  */
        function proc2() { // Вывод первых двух аргументов в консоль 
          console.log("Функцией proc2 получены аргументы: " + arguments[0] + " и " + arguments[1]);  
        }
        proc2("Только один аргумент"); /* Если передать аргументов меньше задуманного, то для 
                                   непереданных аргументов будет возвращаться значение undefined */
        
        function proc3(width, height) { /* Можно указать имена аргументов. 
                                           Они станут локальными переменными внутри функции   */
            str1 = "Ширина: " + width + ", Высота: " + height; /* Из тела функции можно изменять 
                            глобальные переменные. Если глобальная переменная не существует 
                            то в режиме Strict это вызовет ошибку.  */
            var str2 = "Локальное значение";  /* Директивой var можно объявить локальную переменную, 
                                                 даже если её имя совпадает с глобальной. 
                                При этом в теле функции обрабатывается локальное значение: */      
            console.log("Внутри функции в str2 - " + str2); 
            
            var wight = 65, height = 75; /* Значение аргументов можно по неосторожности заменить 
                на другое. Интерпретатор ошибки не покажет. Но эту особенность можно использовать 
                для проставления значений по умолчанию (если аргумент не передан в функцию): */
            if (width === undefined) width = 0; // Очевидный способ
            width = width || 0; // Компактный но менее наглядный способ ( особенность оператора || )
        }

        str2 = "Глобальное значение";
        proc3(35,45);
        console.log("Функцией proc3 получены аргументы. " + str1);
        // Вне тела функции обрабатывается глобальное значение:
        console.log("Вне тела функции в Str2 - " + str2); 
    
    // Возвращение значений из функции   
        function summ_sqr(a, b) { 
            return a**2 + b**2;  /* Возврат значения осуществляется ключевым словом return и 
                                    возвращаемым выражением после него. После return компилятор 
                                    прекращает выполнение тела функции.  */
            console.log("Это сообщение не отобразится"); 
            return; /* Если указать return без возвращаемого выражения, то это аналогично директиве 
                break в цикле - будет прервано выполнение тела функции без возврата конкретного 
                значения (т.е. ведёт себя как процедура). */
        }
        // Функция-процедура возвращает undefined:
        function emptyFunc() {} 
        console.log("Пустая функция возвращает " + emptyFunc() ); 
    
    // Имя функции как переменная. Функциональные выражения
           // https://learn.javascript.ru/function-declaration-expression
        str1 = "" + proc1; /* Имя фукнции без скобок является переменной, хранящей код функции. 
                              Его содержимое можно сохранить в строковую переменную. */
        var proc1b = proc1; // Функцию можно продублировать в новую переменную
        var proc1c = function(){   // Объявление функции в режиме Function Expression
            console.log('Выполняется процедура proc1с');
        }
        proc1c(); /* Если функция объявлена в режиме Function Expression вызов функции можно 
                     делать только после объявления функции */
        proc1c = null; // Переменную содержащую функциональное выражение можно обнулить
        
    // Область видимости функциональных выражений
        /* Для разграничения области видимости используются именованные функциональные выражения 
           (NFE - Named Function Expression)
             https://learn.javascript.ru/named-function-expression  */
        var f1 = function myFunc(){  /* f1 - глобальная переменная , а myFunc - локальная, 
                                        которую нельзя изменить снаружи (что важно для рекурсии) */
            return (f1 == myFunc) ? true : false;  /* Кажется что f1 и myFunc равны, и ожидается что 
                                                      функция всегда будет возвращать true */
        }
        if (f1()) console.log('Функция для обоих своих имён работает корректно.');  // f1 == myFunc  
        
        var f2 = f1; f1 = null; /* Если перезаписать глобальную переменную, то коррекное обращение 
                                   к функции по глобальному имени перестанет работать:  */
        if (!f2()) // Внутри функции продолжает работать сравнение, где теперь f1 != myFunc
            console.log('Функция перестала работать, т.к. её глобальное имя f1 перезаписано.'); 
        
        f1 = f2; var myFunc = null; /* Восстанавливаем переменную какой она была и пробуем теперь 
                                   изменить именованное функциональное выражение.  */
        if (f1()) // Внутри функции f1 == myFunc
            console.log('Функция снова работает корректно - снаружи невозможно изменить то, ' + 
                        'что хранится в её локальном имени.'); 
        
 
    // Передача функции в качестве аргумента другой функции   
        i = applyFunc3(sum, 2, 3, 4); // К числам применяется функция сложения.
        console.log('Результат применения функции sum к числам: ' + i); // i == 9
        
        function applyFunc3(f,a,b,c){ // Объявление функции принимающей на вход другую функцию
            var x = f(a,b); // В этом примере к аргументам a,b,c попарно применяется функция f
            return f(x,c);
        }
        function sum(a,b) { // Функция сложения, используемая для передачи в качестве аргумента
            return a + b;
        }
    
    /* Анонимные функции - это функции которые объявляются прямо там где используются, 
       без сохранения в именованную переменную */
        // К числам применяется функция умножения, созданная на лету:
        i = applyFunc3( function(a,b){return a*b;}, 2, 3, 4 ); 
        console.log('Результат применения анонимной функции умножения к числам: ' + i); // i == 24
    
console.groupEnd("Работа с функциями и процедурами");
}
       
/* ОРГАНИЗАЦИЯ ЛОГИКИ ПРОГРАММЫ */

  {/* ВЕТВЛЕНИЯ В ЛОГИКЕ ПРОГРАММЫ
       https://learn.javascript.ru/ifelse   */

console.groupCollapsed("Организация ветвлений в логике программы");
        
    // Условие с одной ветвью
        if (bool1) str1 = 'Yes';
        // Запись в несколько строк:
        if (!bool1) {
            str1 = 'No';
        }
    // Условие с двумя ветвями
        if (bool1) str1 = 'Yes'; 
            else str1 = 'No';
        // Запись в несколько строк:
        if (bool1) {
            str1 = 'Yes'; 
        } else {
            str1 = 'No';
        }
    // Множественный выбор между несколькими условиями:
        if        (numb2 == 0)  { j = 0; 
        } else if (numb2 < 10)  { j = 2;
        } else if (numb2 < 100) { j = 5;
        } else                  { j = 10;
        }
        
    // Сравнение по образцу
            https://learn.javascript.ru/switch
        i = 2;
        switch(i) {     // В скобках задается выражение, для точного сравнения ===
            case  1:    // Директива case действует аналогично оператору if (i === 1)
                j='а';  /* От двоеточия до следующего case перечисляются инструкции, 
                           которые выполнятся в случае истинности сравнения */
                break;  // Если директива break выполнится, то она прервёт работу блока switch.
            case  2: j='б'; break; /* Поскольку i===2 эта инструкция будет выполнена и работа всего 
                                      блока switch закончится (присутсвует break) */
            case  3: j='в'; break; // Эту и последующие строки интерпретатор пропустит
            case  4: j='д'; break;
            default: j='_';        /* Если бы ни один образец не совпал, то сработают инструкции 
                                      заданные после директивы default */
        }  
        console.log("Числу " + i + " соответствует буква " + j); // j == "б"

        /* Если break не указать, то будут выполнены все остальные инструкции блока БЕЗ СРАВНЕНИЙ 
           с образцами. Т.е. в этом случае конструкция switch действует как переход по метке  */
        j="";
        switch(i) {     
           case  1: j+='а'; // i!==1 и значит инструкция не выполнится
           case  2: j+='б'; // i===2, инструкция выполнится и отключится режим сравнения с образцами
           case  3: j+='в'; // Все интсрукции выполнятся, т.к. сравнение больше не производится
           case  4: j+='д'; // Директиву default можно опускать
        }                    
        console.log("Начиная с числа " + i + " идет набор букв " + j); // j == "бвд_"
    
    /* Тернарная условная операция. Это операция, возвращающая свой второй или третий операнд 
       в зависимости от значения логического выражения, заданного первым операндом. */
        bool1 = (numb1 > 10) ? true : false; // Формат записи:    условие ? значение1 : значение2
        bool1 = numb1 > 10 ? true : false;   // То же без скобок (у оператора ? низкий приоритет)
        // Цепочка тернарных условных операций:
        j = (numb2 = 0)   ? 0 :
            (numb2 < 10)  ? 2 :
            (numb2 < 100) ? 5 :
                            10 ;
  console.groupEnd("Организация ветвлений в логике программы");
  }
  
  {/* БЕЗУСЛОВНЫЕ УПРАВЛЯЮЩИЕ КОММАНДЫ 
            https://puzzleweb.ru/javascript/11_loops3.php   */
        block1: { // Блок операторов можно пометить именованной меткой, завершающейся двоеточием
            i = 2;
            break block1; // Директива break прерывает выполнение блока с указанным именем
            i = 3; // Этот оператор не будет выполнен
        }
        console.log('Выполнение блока операторов прервано. i = ' + i);
  }
  
  {/* ДИНАМИЧЕСКОЕ СОЗДАНИЕ КОДА И ДАННЫХ */
    console.groupCollapsed("Динамическое создание кода и данных");
        
        // Создание переменной в зависимости от условия
            if (true) { var condiVar = "Новый текст"; }
            console.log("Условие выполнилось и создана переменная с содержимым: " + condiVar); 
    
        // Создание функции в зависимости от условия
        // https://learn.javascript.ru/function-declaration-expression#bad-conditional-declaration
            if (true) { // В режиме Function Expression функцию можно объявлять внутри блока if
                var condiFunc = function(){ console.log(
                                            'Условие выполнилось и создана функция condiFunc.'); }   
            } 
            // Проверка того что функция создана перед ее вызовом (иначе скрипт может зависнуть):
            if (condiFunc) condiFunc(); 

        // Генерация кода из текстовой строки. Можно создать код и поместить его в переменную:
            str1 = "{ console.log('Выполняется сгенерированный код'); }";  
            /* Объявление функции через ключевые слова new Function (c большой буквы F) позволяет 
               двумя строками задать параметры и тело функции:  */
            var genProc1 = new Function('', str1); 
            genProc1(); 
            var genFunc1 = new Function('a,b', ' return "Получены параметры " + a + " и " + b ');
            console.log( genFunc1(45,false) );
    console.groupEnd("Динамическое создание кода и данных");        
  }

  {/* ЦИКЛЫ
        https://learn.javascript.ru/while-for   */    
  console.groupCollapsed("Циклы");
        
    // Цикл со счётчиком
        str1 = "";
        // В этом примере на каждой итерации счётчик увеличивается на 1 в порядке возрастания:
        for (i=1; i<10; i++) // (начало; условие; шаг) 
            str1 += i + " "; 
        
        for (; i>0; ) // Операторы в условии цикла можно оставлять пустыми  
            str1 += i-- + " "; 
        console.log("Счет от 1 до 10 и обратно: " + str1);
            
        var factorial1 = 1;
        // Если в теле цикла несколько операторов, то они заключаются в логический блок {} :
        for (i=2; i<=5; i++) { 
            factorial1 = factorial1 * i; 
            console.log(i + '! = ' + factorial1 + '; ');
        }
        
    // Вложенный цикл со счётчиком
        console.log('Таблица сложения:'); 
        for (i=1; i<=5; i++) {
            str1 = "";
            for (j=1; j<=5; j++) {
                str1 += Number(i+j) + ' '; 
            }
            console.log(str1);
        }
        console.log('После выполнения циклов значения счётчиков сохраняются: ' + 
                    'i = ' + i + ' и j = ' + j);
        
    // Цикл с предусловием
        i=12;
        while (i<90) { // Удваиваем число если оно меньше 90
            i *= 2;
        }
        console.log('Цикл с предусловием окончен. i = ' + i);
        
    // Цикл с постусловием
        do 
            i /= 3;   // Можно использовать несколько операторов без заключения их в блок {}
        while (i>10); // Уменьшаем число в 3 раза пока не преодолеем порог меньше 10
        console.log('Цикл с постусловием окончен. i = ' + i);

    // Перерывание работы цикла
        for (;;i++) { // При таком условии цикл будет повторяться вечно, если его не прервать
            if (i % 2 == 0) continue; // Переход на следующую итерацию текущего цикла
            if (i > 30) break; // Выход из текущего цикла
        } 
        console.log('Вечный цикл окончен. i = ' + i);
        
        // С помощью break сделаем таблицу сложения треугольной
        console.log('Нечетные строки треугольной таблицы сложения:'); 
        loop1: for (i=1; i<=5; i++) { // Цикл как и обычный блок можно пометить именованной меткой
            str1 = "";
            loop2: for (j=1; j<=5; j++) {
                if (j>i) break loop2; //Переход на следующую итерацию цикла помеченного меткой loop2
                if (i%2 == 0) continue loop1; // Выход из цикла помеченного меткой loop1
                str1 += Number(i+j) + ' ';
            }    
            console.log(str1);
        } 
  console.groupEnd("Циклы");    
  }

  {/* РЕКУРСИЯ 
        https://learn.javascript.ru/recursion  */ 
  console.groupCollapsed("Рекурсия");
    
    // Рекурсия с ветвлением по условию:
        var factorial = function f(n){  // Вычисление факториала от n
            if (n==0) return 1; /* else можно не писать, поскольку в случае n==0 на этой строке 
                                   функция завершит работу  */
            return n * f(n-1); 
        }
        console.log("10! = " + factorial(10)); //  == 3628800
        
        
        var summNatural = function f(n){  // Сумма натуральных чисел от 1 до n
            return n ? n + f(n-1) : n;  // Тернарный условный оператор ? делает код компактнее
        }
        console.log("1 + .. + 10 = " + summNatural(10)); //  == 55
    
    // Рекурсия через множественный выбор
        var factorial2 = function f(n){    /* Эта версия функции корректно обрабатывает всё что 
                                              не является положительным числом, возвращая NaN   */
            return n > 200 ? Infinity   :  // Для запредельных значений сразу возвращаем Infinity
                   n > 0   ? n * f(n-1) :  // Цепочка операторов ? проверяет несколько условий.
                   n === 0 ? 1          :
                             NaN; 
        }
    
    // Рекурсия со вспомогательной функцией для хранения промежуточного значения
        function prime(n)  { // Функция определения числа на простоту (возвращает true или false)
            // Локальная вспомогательная функция:
            function prime_(n,m) {  // Аргумент m хранит число, до которого произведена проверка
                return m * m > n  ? true  : // Все кандидаты на делители проверены - возвращаем true 
                       n % m == 0 ? false : // Делитель найден - возвращаем false
                       prime_(n,m+1); // Рекурсивный вызов проверки следующего кандидата на делителя
            }
            return n > 0 ? prime_(n,2) : NaN; /* Для положительного числа запускаем вспомогательную 
                                              функцию проверки кандидатов на делители начиная с 2 */
        }  
        str1='';
        for (i=2; i<128; i++)   // Формируем список простых чисел
            if (prime(i)) str1 += " " + i + " ";   
        console.log("Простые числа: " + str1);
  console.groupEnd("Рекурсия");       
  }

/* СОСТАВНЫЕ СТРУКТУРЫ ДАННЫХ */ 

  {/* ДИНАМИЧЕСКИЕ МАССИВЫ
        Массив - это набор элементов с доступом по числовому индексу.
        В JavaScript массивы эмулируются объектами, снабжёнными возможностями индексирования.
            https://learn.javascript.ru/array  */    
  console.groupCollapsed("Динамические массивы");

    // Создание и инициализация массива
        var arr1 = [];  // Пустой массив
        var arr1a = new Array(); // Альтернативная запись
        // Если в такой записи указать один числово аргумент, то он задаст длину массива
        var arr1b = new Array(10); // Создание массива длиной 10 элементов (их значения - undefined)
        var arr1b = new Array(10,3); // Создание массива из двух элементов 10 и 3
        var arr2 = ["А", "Б", 456, undefined, true]; // Создание массива с разнотипными элементами
    
    // Чтение и запись элементов массива
        k = arr2[0]; // Считать первый элемент массива (нумерация элементов - с нуля)
        b = arr2[9] == undefined; // Несуществующие и неинициализированные ячейки дают undefined
        
        arr2[2] = "Новое значение"; // Записать данные в элемент с индексом 2
        arr1[5] = "А"; // Если записать данные в ячейку с индексом выходящим за границы 
                       // массива, то размер массива автоматически увеличится
        delete arr1[5]; // Операция delete не удаляет элемент, а присваивает значение undefined
    
    // Длина массива  - в свойстве .length
        numb1 = arr1.length; // == 6   (текущая длина массива)
        arr1.length = 20;    // Длину массива можно изменить, записав новое значение в это свойство.
        arr1.length = 0;     // Задав нулевую длину массив можно обнулить. Равносильно arr1 = [];
        
    // Многомерные динамические массивы
        // Создание многомерного массива
        var tableSum = [  // Двухмерный массив таблица сложения
            [0,1,2],    
            [1,2,3],
            [2,3,4] ];  // Первые три элемента созданы массивами

        b = tableSum[2][2] == 4;  // Обращение к элементу многомерного массива  
                 
        // 4-мерный массив хранения пикселей движущейся голограммы размером 10x10x10
        var holo3d = [];
        for (i=0; i < 10; i++) {
            holo3d[i] = [];  // Создание двумерного массива путём добавления ячеек-массивов
            for (j=0; j < 10; j++) {
                holo3d[i][j] = []; // Создание трехмерного массива
                for (k=0; k < 10; k++) {
                    holo3d[i][j][k] = []; // Создание 4x-мерного массива
        }   }   }
        holo3d[3][1][7][2] = 80; // Запись значения в созданный 4x-мерный массив;
    
    // Методы вставки и выемки элементов динамических массивов с перестройкой индекса:
        // Реализация стека
        i = arr1.push(15); // Вставить значение 15 в конец массива. i == новая длина массива.
        k = arr1.pop();    // Вынуть последний элемент массива, возвратив его значение.
        
        // Реализация очереди. Дополнительно используются медленные операции с началом массива:
        i = arr1.unshift(15); // Вставить значение 15 в начало массива. i == новая длина массива. 
        k = arr1.shift(); // Вынуть первый элемент массива, возвратив его значение. 
        
        // Универсальный метод splice может вынимать вставлять элементы в любом месте массива
            arr1 = [0,1,2,3,4,5,6,7,8,9];
        k = arr1.splice(7); // Вынуть все элементы начиная с указанного индекса, записав их в массив
            console.log("Содержимое вынутого подмассива: " + k); // 7,8,9
        k = arr1.splice(-1); // Отрицательный индекс указывает отступ с конца массива
            console.log("Вынут последний элемент: " + k);  
            
            // Вторым аргументом можно указать количество вынимаемых элементов:
            k = arr1.splice(0,2); 
            console.log("Вынуты первые два элемента: " + k); // 0,1
            k = arr1.splice(1,0); 
            console.log("При нулевом втором аргументе возвращается пустой массив: " + k);
            
            // В третьем и последующих аргументах идут значения для вставки в исходный массив:
            arr1.splice(0,0,-2,-1,0); // Вставить без удаления начиная с позиции 0 значения -2,-1,0
            arr1.splice(1,3,7,8); // На позиции 1 удалить 3 элемента и вставить значения 7,8
            console.log("Массив arr1 после всех операций splice: " + arr1); // -2,7,8,3,4,5 
    
    /* Методы обработки групп элементов: 
            https://learn.javascript.ru/array-methods  */
    
    // Копирование участков массива в новый массив без изменения исходного массива
        arr1a = arr1.slice();  // Метод slice без аргументов копирует массив целиком
        /* Двумя аргументами  можно задать отступы, задающие границы копируемого подмассива
           Формат идентичен методу slice для строк */
        arr1a = arr1.slice(1,4); // Скопирует элементы с 1-го по 3-й включительно
        
    // Склейка массивов
        arr1b = arr1.concat(1,2,3); // В arr1b запишется массив arr1 с добавленными элементами 1,2,3
        arr1b = arr1.concat(arr2,"|",arr1a); // Аргументами могут быть присоединяемые массивы
        console.log("Склеенный массив: " + arr1b);  

    // Приведение массива к строке
        str1 = arr2.join(); // Метод join даёт строку из элементов массива, разделённых запятыми
        str1 = arr2.join(" | "); // Можно указать свою строку-разделитель
        console.log("Содержимое массива arr2: " + str1);  // undefined приводится к строке ""
        
        // При автоматическом приведении элементы массива выведутся через запятую :
        console.log("Содержимое массива arr2: " + arr2);  
        arr2[1] = ",\n";  // Запятая и прочие символы выведутся как есть:
        console.log("Букву Б заменили на запятую с переносом строки: " + arr2);  
        console.log("Таблица сложения " + tableSum); // Многомерные массивы выводятся в одну строку
    
    // Приведение строки к массиву (парсинг)
        str1 = "12345.67890";
        arr1 = str1.split(".");  // Разбивает сроку на элементы по указанной строке-разделителю
        console.log('Результат split("."): ' + arr1);  // Два элемента 12345 и 67890
        arr1 = str1.split("");  // Если раздлитель пустая строка, то разбиение будет посимвольное:
        console.log('Результат split(""): "' + arr1); // 1,2,3,4,5,.,6,7,8,9,0
        arr1 = str1.split("",4); // Вторым аргументом можно указать сколько элементов нужно спарсить
        console.log('Результат split("",4): ' + arr1); // 1,2,3,4,5,.,6,7,8,9,0
       
    // Сортировка элементов массива на месте (без создания нового массива)
        arr1 = [2,3,5,7,11,13,17,19,23];
        arr1.sort(); // Метод sort без аргументов cортирует элементы как строки.
        console.log("Простые числа отсортированы как строки: " + arr1); // == 11,13,17,19,2,23,3,5,7
        
        /* Для сортировки по другому критерию нужно указать функцию сравнения, которая возвращает 
           положительное или отрицательное число:  */
        function compareNumbs(a, b) {  
            return a - b;  // Вернет положительное число если a > b и отрицательное, если a < b 
        }
        arr1.sort(compareNumbs);  // Через аргумент передаётся ссылка на функцию (без скобок)
        console.log("Простые числа отсортированы как числа: " + arr1);  // == 2,3,5,7,11,13,17,19,23
    
    // Инверсия массива на месте (изменение порядка элементов на обратный)
        arr1.reverse();
        console.log("Элементы в обратном порядке: " + arr1);  // == 23,19,17,13,11,7,5,3,2
        
    /* Поиск по массиву. Метод indexOf работает аналогично методу indexOf для строк
           Можно указать вторым аргументом индекс, с которого осущетсвлять поиск. 
           Если значение не найдено, то возвращается -1 */ 
        i = arr1.indexOf(17);  // Возратит индекс n для которого arr1[n] === 17
        console.log("Значение 17 хранится в элементе с номером " + i);  // == 2
    
    /* Применение функций к элементам массива 
            https://learn.javascript.ru/array-iteration  */     
    
        // Перебор элементов массива с вызовом функции для каждого (альтернатива циклу for)
        arr1a.forEach( function(item,index,arr1a){ // 2й и 3й аргументы необязательны
            console.log("В ячейке " + index + " хранится значение " + item);
        });
        
        // Фильтрация элементов массива
        arr1a = arr1b.filter( function(item) { // Фильтрующая функция возвращает true или false
            return item > 0; // Эта функция отфильтровывает значения > 0
        });
        console.log("Положительные значения в массиве arr1b: " + arr1a); // 7,8,3,4,5,true,7,8,3
        
        /* Трансформация массива - создание нового массива, в котором к каждому 
           элементу применена указанная функция */
        arr1a = arr1.map( function(item,index,arr1) { // 2й и 3й аргументы необязательны
            return item + index;  
        });
        console.log("Сумма индекса и значения: " + arr1a); // 23,20,19,16,15,12,11,10,10
        
        // Кванторы всеобщности и существования
        function isOdd(n) { // Демонстрационная Функция поверки чисел на чётность
            return (n % 2) === 0;
        }
        if (! arr1.every(isOdd)) console.log("Не все числа массива arr1 чётные."); 
        if (  arr1.some(isOdd)) console.log("В массиве arr1 есть чётные числа."); 
        
        // Свёртка массива (рекурсивное применение функции к элементам с накопительным параметром).
        k = arr1.reduce( function(sum,item,index,arr1){
            return "" + sum + "|" + item; // Суммируем числа как строки.
        }, "!"); // Второй аргумент необязательный, указывает начальное значение накопителя
        console.log("Склеенные слева направо элементы массива arr1: " + k); 

        k = arr1.reduceRight( function(sum,item,index,arr1){ // То же, но справа налево
            return "" + sum + "|" + item;  
        }); // Если начальное значение не указано, то в качестве него используется начальный элемент
        console.log("Склеенные справа налево элементы массива arr1: " + k); 
        
  console.groupEnd("Динамические массивы");    
}



/* ОБЪЕКТЫ */ 

{/* СОЗДАНИЕ ОБЪЕКТОВ И ХРАНЕНИЕ В НИХ ДАННЫХ 
        https://learn.javascript.ru/object  */ 
console.groupCollapsed("Создание объектов и хранение в них данных");

    // Создание пустого объекта
        var obj1 = new Object();
        var obj2 = {};
        
    // Копирование ссылки на объект - объекты являются ссылочным типом
        var obj3 = obj1;  // Теперь obj1 и obj3 указывают на один и тот же объект в памяти.
        
    // Сравнение ссылок на объекты    
        if (obj1 == obj3) // Проверка равенства переменных, хранящих ссылку на объект.
            console.log("Переменные obj1 и obj3 ссылаются на один и тот же объект.");
        if (!(obj1 == obj2)) // Хоть объекты одинаковы по содержанию, но ссылки на них не равны.
            console.log("Переменные obj1 и obj2 ссылаются на разные объекты.");
            
    // Проверка существования объекта
        if (typeof obj1 == "object") console.log("Объект obj1 существует");
        if (typeof obj4 == "undefined") console.log("Объект obj4 не существует"); 
    
    // Именованные свойства объектов - указываются через точку
        obj1.numb1 = 5;     // Свойство создаётся в момент присвоения
        numb2 = obj1.numb1; // Чтение свойста - аналогично чтению из переменной
        
        // Проверка существования свойств объектов
        b = obj1.numb3 === undefined;  // Обращение к несуществующему свойству даёт undefined
        obj1.numb1 = undefined; // Значение undefined может быть и у существующего свойства.
        // Поэтому надёжно проверить, существует ли свойство можно операцией in
        if ("numb1" in obj1) console.log("У объекта obj1 есть свойство numb1.");
        
        /* Удаление свойств объектов производится ключевым словом delete:
             https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/delete  */
        delete obj1.numb1; // Операция возвращает true после выполнения. В не strict режиме если 
                           // свойство не удаляется то возвращается false
        if (!("numb1" in obj1)) console.log("Свойство obj1.numb1 успешно удалено.");
    
    // Отличия переменных и свойств объектов
        i = window.numb2; // Глобальные переменные - это свойства глобального объекта (window и др.)
        window.v1 = 1;    // Cвойство объекта window можно создать напрямую 
        v1 = 2;           // и обращаться с ним как с переменной
        console.log("В свойстве v1 хранится " + v1);
        
        var v2 = 2; // Ключевое слово var задаёт флаг non-configurable. 
                    // В режиме Strict слово var нельзя опускать при создании переменных 
                    // и такие переменные нельзя удалять через delete:
            if (delete window.v1) console.log("Простое свойство объекта window можно удалить.");
            //  delete window.v2   - в режиме Strict такая операция вызовет ошибку
            
        window.obj4 = {};      // То же касается и объектов
            if (delete window.obj4) console.log("Удалён объект, созданный как свойство window.");
            //  delete window.obj1 - в режиме Strict такая операция вызовет ошибку
        window.obj4 = new Object(); // Свойство-объект можно создать и с использованием new
    
    // Работа со свойствами как с ассоциативным массивом
        obj1["numb1"] = 7; // К свойству объекта можно обращаться в виде строки, заключенной в []
        obj1["Номер факса"] = 856; // Это позволяет задавать имена свойств с пробелами
        str1 = "Дополнительный номер факса";
        obj1[str1] = 857; // или передавать их имена через переменные.
    
    // Создание объекта с групповым перечислением свойств:
        var vcard1 = { name:"Иван", age: 28, homePhone: 789, officePhone: 456 };
        var vcard2 = {  // Запись в несколько строк более наглядна
            name: "Иван",    // Эквивалент vcard1.name = "Иван"; 
            age: 28,
            phones: {        // Свойство тоже может быть объектом
                home: 789,   // Эквивалент vcard1.phones.home = 789; 
                office: 456
            }
        };
    
    // Перебор свойств объекта
        console.log("Все свойства объекта vcard1: ");
        for (var k in vcard1) {
            console.log("\t Свойство " + k + " == " + vcard1[k]);
        } // Свойства с буквенными ключами возвращаются в порядке их создания
        
        console.log("Если свойство age удалить и создать, то оно выведется последним: ");
        delete vcard1.age;  // Если свойство удалить,     
        vcard1.age   = 29;  //     а затем создать, то оно выведется последним.
        vcard1["3"]  = "А"; // Свойства с именами в виде цифр без знаков и точек, сортируются в  
        vcard1["21"] = "Б"; // порядке возрастания и идут впереди независимо от порядка их создания.
        vcard1["+1"] = "Г"; // Строка с плюсом или другими "не цифрами" не участвует в сортировке.
        vcard1[0]    = "В"; // Имя свойства можно задать числом - оно приведётся к строке.
        for (var k in vcard1) console.log("\t Свойство " + k + " == " + vcard1[k]); 
        
        // Получить имена свойств объекта в виде массива:
        arr1a = Object.keys(vcard1); 
        console.log("Все свойства объекта vcard1 в виде массива: ");
        console.log(arr1a);
        
    // Определение количества свойств можно сделать путём их перебора
        i = 0;
        for (k in vcard1) i++;
        console.log("В объекте vcard1 свойств: " + i);
        
        i = Object.keys(vcard1).length;  // либо использовать массив, возвращаемый методом keys()
        console.log("В объекте vcard1 свойств: " + i);
        
    // Создание полной независимой копии объекта (глубокое клонирование)
        var cloneObj = function f(o1){
            var o2 = {};  // Создаём новый объект o2 и копируем в него все свойства из объекта o1 
            for (var k in o1) { // Если свойство является объектом, то вызываем функцию рекурсивно
                o2[k] = (typeof o1[k] == "object") ? f(o1[k]) : o1[k];
            }
            return o2; 
        }
        
        var vcard2link = vcard2;            // Копирование ссылки на объект
        var vcard2copy = cloneObj(vcard2);  // Клонирование объекта
        
        vcard2.phones.home = 123;
        console.log("Изменение vcard2.phones.home=123 затрагивает копию ссылки, но не клон: ");
        console.log("vcard2.phones.home : " + vcard2.phones.home);          // == 123
        console.log("vcard2link.phones.home : " + vcard2link.phones.home);  // == 123
        console.log("vcard2copy.phones.home : " + vcard2copy.phones.home);  // == 789
    
    // Вывод содержимого объекта в консоль
        console.log("Содержимое объекта vcard2 : ");
        console.log(vcard2);   
        console.log("Содержимое объекта vcard2copy : " );
        console.log(vcard2copy);
    
console.groupEnd("Создание объектов и хранение в них данных");       
}





























