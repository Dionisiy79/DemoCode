//  Однострочный комментарий до конца строки задается двумя косыми чертами в начале комментария
/*  Многострочный комментарий - обрамляется парой символов "/" и "*" 
    В начале комментария символы / и * идут в прямом порядке, а в конце - в обратном.
        https://learn.javascript.ru/structure#kommentarii

    Откройте этот скрипт в Notepad++ чтобы свернуть блоки в удобное меню простой комбинацией клавиш:
	(Alt + 2) - свернуть и (Alt + Shift + 0)  - развернуть.
	То же самое можно сделать в Visual Studio Code:
	(Ctrl + K) + (Ctrl + 2) - свернуть, (Ctrl + K) + (Ctrl + J) - развернуть
	
	В консоли браузера можно увидеть результаты работы скрипта.
*/

"use strict"; /* Эта директива, если стоит первой, переводит интерпретатор в режим современного 
                 стандарта ES5. При этом теряется совместимость с IE9- и скриптами, 
                 написанными в старом стандарте.  https://learn.javascript.ru/strict-mode */
                 
{
  {/*  ОБЩИЕ СИНТАКСИЧЕСКИЕ ПРАВИЛА
    Команды в JS разделяются символом точки с запятой ";"
    Если символ ";" пропущен, но есть перевод строки, то интерпретатор может его 
        автоматически вставить, но надеяться на это не стоит.
            https://learn.javascript.ru/structure#komandy
    Блок операторов выделяется фигурными скобками {}
    Отключить выполнение кода можно поместив его внутрь блока if(0){  }  */

if(0){ "Невыполнящийся код" } // В коде не должно быть ошибок. Для включения нужно 0 заменить на 1.
}
}

{/* КОМАНДЫ ВЗАИМОДЕЙСТВИЯ С ПОЛЬЗОВАТЕЛЕМ */
  { /* Вывод текстовых строк  */
        console.log('Hello World!');  // В консоль с переносом строки
        console.group("Демо-группа строк 1");  // Объявление начала группы строк в консоли
            // Объявление свернутой группы строк, к тому же внутри первой группы:
            console.groupCollapsed("Свернутая группа строк 2"); 
            console.groupEnd("Свернутая группа строк 2"); // Объявление конца группы строк
        console.groupEnd("Демо-группа строк 1"); 

        document.write('Hello world! ');  /* В текущее место веб-страницы 
            (после закрывающего тега </script>). Если скрипт выполнится не в процессе, а после 
             загрузки HTML-страницы то страница будет стерта и начата новая. */
        
        // В произвольное место DOM веб-страницы
        // https://learn.javascript.ru/modifying-document#ustarevshie-metody-vstavki-udaleniya
        var div1 = document.createElement('div');    // Создаем новый элемент <div> для DOM
        div1.innerHTML = "<strong>Hello</strong> World!"; // Наполняем его HTML-содержимым
        document.body.appendChild(div1);  // Добавляем в DOM как дочерний элемент для <body>
  }
       
  { /* Модальные окна с сообщениями и запросами 
	     https://learn.javascript.ru/alert-prompt-confirm */
	if(0){  // Демонстрация всплывающих окон (отключена - для включения нужно заменить 0 на 1)
        alert('Hello world!');        // В модальное веб-окно с ожиданием реакции пользователя

    // Запрос пользователю ввести строку, которая будет сохранена в переменной inputStr
        var inputStr = prompt('Введите строку:', 'Текст по умолчанию'); 
    // Запрос пользователю ответить Да/Нет. Ответ будет сохранен в логическую переменную inputBool.    
        var inputBool = confirm("Вы подтверждаете запрос?"); 
	}
  }

  { /* Пауза на 3 секунды. 
       Будет отложено выполнение только блока операторов функции func(). 
       Загрузка страницы и остальные скрипты на странице продолжат своё выполнение. 
            https://learn.javascript.ru/settimeout-setinterval  */
       var func3sec = function() { 
           console.log('Прошло 3 секунды.'); 
       }
       setTimeout(func3sec, 3000);
  }     
}

{/* ХРАНЕНИЕ И ОБРАБОТКА ДАННЫХ В ОПЕРАТИВНОЙ ПАМЯТИ. ФУНКЦИИ. */
  console.groupCollapsed("Хранение и обработка данных в оперативной памяти");

  {/* РАБОТА С ПЕРЕМЕННЫМИ   
          https://learn.javascript.ru/variables
      Имя переменной не должно начинаться с цифры и может состоять из букв, цифр, символов $ и _ 
      Регистр имеет значение.
  */
  console.groupCollapsed("Переменные"); // Объявление начала свёрнутой группы строк

    // Объявление и инициализация переменных
        var str1; /* Новая переменная объявляется с помощью ключевого слова var. 
                     Это можно делать в любом месте кода. */
        var numb1 = 213; // При объявлении переменной можно сразу инициализировать её значение.
        var numb1 = 546; // Если переменная объявлена ранее, то директива var будет проигнорирована.
        var str2, b, i, j, numb2, numb3 = 123; // Можно объявить несколько переменных через запятую.
        numb3 = "Строка"; /* Тип переменной не фиксирован и в любую переменную могут быть 
                            записаны данные любого типа */
        var NUMBER_PI = 3.14; /* В ES5 нет констант, поэтому принято вместо констант использовать 
            переменные, названные прописными буквами и просто не менять их значения в дальнейшем.*/
    
    // Простые типы данных в JS      https://learn.javascript.ru/types-intro
        numb2 = 456;      // Для чисел используется стандарт IEEE-754 64-битный с плавающей точкой
        numb2 = 789;      // Проинициализированную переменную можно заменить новым значением.
        numb1 = 123.789;  // Для задания вещественного числа используется разделитель - точка
        numb1 = 3.2e5;    /* = 320000   Запись в научном формате. После символа "e" задаётся 
                             сдвиг запятой вправо для десятичного числа */
        numb1 = 3.2e-5;   /* = 0.000032 Отрицательное число сдвигает запятую влево, 
                             задавая десятичную дробь */
        numb2 = Infinity; /* Спец.значение "бесконечность" используется в случае деления на ноль 
                             или превышения максимального значения для числа */
        numb3 = NaN;  // Спец.зачение "Not a Number" используется для обозначения ошибки вычислений
        
        // Задание целых 32-битных чисел в других системах счисления 
        numb2 = 0xF0; // Шестнадцатиричное число начинается с 0x
        // numb2 = 0o70;  // Восьмиричное число начинается с 0o
        
            // Можно использовать функцию parseInt() задав строку с числом и основание (от 2 до 36)
            // http://javascript.ru/ParseInt
        numb2 = parseInt("F57", 16);      // Шестнадцатиричное число
        numb2 = parseInt("4651", 8);      // Восьмиричное число
        numb2 = parseInt("10011110", 2);  // Двоичное число
        numb2 = parseInt("-10011110", 2); // Знаком минус можно задать отрицательное значение
        numb2 = parseInt("14fdnv5z", 36); // Закодированный буквами номер телефона 88001234567  
        
        var bool1 = true;   // Логический тип "истина"
            bool1 = false;  // и "ложь"
    
        str1 = "Тестовая строка";       // Строки задаются двойными или одинарыми кавычками
        // Для использования в строке двойных кавычек можно обрамлять её в одинарные кавычки:
        str1 = 'Тестовые "кавычки"';    
        str1 = "Тестовые \"кавычки\"";  // либо использовать экранирующий символ  "\"
        str1 = " \\ ";  // Для сохранения экранирующего символа его нужно написать дважды 
        str1 = "Первая строка\nВторая строка"; // Перенос строки: \n
        str1 = "\t \r \b \f"; // Символы  Tab | Return | Backspace | Form feed (новая страница)
        str1 = "\u005A";      // Символ в кодировке Unicode
        
        str2 = null;        // Специальный тип означающий "неизвестное значение"
        str1 = undefined;   // Специальный тип означающий "переменная неинициализирована". 
        
        /* Для проверки типа переменной можно применить оператор typeof, который возвращает 
           такие значения: "number", "string", "boolean", "undefined", "object" */
        str1 = typeof str2; // Для переменных типа null оператор возвращает значение "object"

    // Использование переменных
        /* Проверка, является ли переменная инициализированной. 
           Работает независимо от того, объявлена ли переменная. */
        if (typeof newVar == "undefined") { 
            console.log('Переменная newVar не инициализирована') 
        };
        console.log(str1); // Вывод значения переменной в консоль
        
        numb2 = numb1; // Запись значения переменной в другую переменную.
        numb2 = numb2 / numb1; /* В выражениях для присвоения нового значения можно использовать 
                                  эту же переменную, пока в ней хранится старое значение. */
  console.groupEnd("Переменные");
  } 

  {/* ОПЕРАЦИИ
    https://learn.javascript.ru/operators
    https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence */
  console.groupCollapsed("Операции");       

    numb1 = numb2 = 5;          /* Оператор присваивания тоже возвращает значение, которое можно 
                                  использовать в предыдущем операторе присваивания */
    console.log(numb1 = 7 + 5); /* или в выводе на экран. Сам оператор правоассоциативный - т.е. 
                                   вычисления последовательности операторов идут справа налево. */
    bool1 = numb2 == 5;   // Оператор == сравнивает два значения и возвращает true или false
    bool1 = numb2 === 5;  // Оператор === сравнивает два значения b и проверяет равенство их типов 
	
    /* Арифметические операции */
        numb1 = ( 7 + 2 - 3 ) * 4 / 5; // Сложение вычитание умножение и деление для чисел.
        numb1 = 4 % 1.9;  // == 0.2 Остаток от вещественного деления (дробная часть учитывается)
    //  numb1 = 2 ** 3.5; // Возведение в степень (может не работать в старых версиях браузеров!)
    //  numb1 = 2 ** -2;  // == 0.25 Отрицательная степень (сколько раз разделить единицу на число)      
        Math.pow(2,-3.5); // Аналогичное действие у функции Math.pow() 
        // Для вычисления корня можно использовать возведение в дробную степень либо функцию sqrt:
        numb1 = Math.sqrt(9);  // == 3   Корень квадратный из числа 9
        
    /* Унарные операции */
        i = +numb1;   // Унарный оператор подтверждения знака (приводит другие типы к числу)
        i = -numb1;   // Унарный оператор смены знака.
    
        i++; /* Постфиксный инкремент переменной. Возвращает значение переменной ДО операции 
                инкремента и увеличивает значение переменной на 1. */
        i--; /* Постфиксный декремент переменной. Возвращает значение переменной ДО операции 
                декремента и уменьшает значение переменной на 1. */
        ++i; /* Префиксный инкремент переменной. Возвращает значение переменной ПОСЛЕ операции 
                инкремента. Унарный аналог i = i+1. */
        --i; /* Префиксный декремент переменной. Возвращает значение переменной ПОСЛЕ операции 
                декремента. Унарный аналог i = i-1. */
    
    /* Побитовые операции над 32-битной целой частью числа. Дробая часть теряется. 
       Имеют низкий приоритет поэтому часто требуют обрамления скобками.
            https://learn.javascript.ru/bitwise-operators  */
        j = ~i;       /* Побитовая инверсия - вычитание из -1 (смена знака и декремент). 
                         Инверсия полезна в связке с операцией смены знака: */
        j = -~i;      // Инкремент числа. Унарный аналог j = i+1 
        j = ~-i;      // Декремент числа. Унарный аналог j = i-1
        i = -~ 2 * 6; /* Результат равен 18, а не 13, поскольку у унарных операторов 
                         приоритет выше чем у операций умножения и деления."  */

        i = i << 5;  /* Побитовый сдвиг влево на указанное число бит с сохранением знака 
                        (умножение на степень двойки ). */
        i = i >> 2;  /* Побитовый сдвиг вправо на указанное число бит с сохранением знака 
                        (деление на степень двойки). */
        i = i >>> 1; /* Побитовый сдвиг вправо на указанное число бит 
                        c заполнением освободившихся бит нулями. */
        i = i & 5;   // Побитовое И (AND). Используется для установки в нужные биты значения 0.
        i = i | 5;   // Побитовое ИЛИ (OR). Используется для установки в нужные биты значения 1.
        i = i ^ 5;   /* Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR). 
                        Используется для смены значений нужных битов на противоположные. */

    /* Конкатенация строк: через бинарный оператор +  */
        str1 = "строка1 " + "строка2"; 
    
    /* Комбинированные операторы присваивания */
        i += 5; i -= 5;   // Увеличить или уменьшить переменную на указанное число.
        i *= 3; i /= 3;   // Умножить или поделить переменную на указанное число.   
        i %= 10;          // Записать в переменную остаток от деления её на указанное число; 
        i <<= 2; i >>= 2; // Сдвинуть биты переменной влево или вправо на указанное число позиций.
        i >>>= 2;         // Сдвиг битов переменной с заполнением нулями.
        i &= 5; i |= 5; i ^= 5;   // Поменять значение нужных бит на 0, 1 или противоположное.
		str1 += " строка3"; // Добавить строку к переменной;
        
    /* В качестве оператора последовательных операций в одной строке используется символ запятой. 
       Имеет самый низкий приоритет (нужно обрамлять его в скобки) и возвращает 
       только последнее вычисленное значение в последовательности: */
        numb1 = (i = 3, j = 2, i + j); // Используется для сокращения кода и мимоходных присвоений. 
    
    /* Операторы сравнения и логические операторы: 
            https://learn.javascript.ru/comparison  */
        // Во всех нижепреведенных сравнениях результат равен True  
        b = 2 == '2'   && // Нестрогое равенство (c приведением типов)
            2 != '3'   && //     и нестрогое неравенство
            2 === 2    && // Строгое равенство (без приведения типов)
            2 !== '2'  && //     и строгое неравенство
            bool1 != !bool1      && // Отрицание
            (1 >= 1) && (2 > 1)  && // Логическое "И" (конъюнкция)
           ((1 <= 1) || (2 < 1)) && // Логическое "ИЛИ" (дизъюнкция) - имеет более низкий приоритет
            null == undefined    && // null и undefined нестрого равны, но не равны ничему другому
            null >= 0            && // При сравнении null приводится к нулю, 
            null != 0            && //     но при этом null != 0  (в отличие от PHP где null == 0)
            "Строка 2" > "Строка 1"; // Строки сравниваются побуквенно по кодам символов Unicode
        console.log("Результат всех сравнений и логических операций: " + b);

    /* Операции с особыми float-числами Infinity и NaN */
        // Справедливы следующие соответствия (результат нижеприведенных сравнений == true)
            // https://learn.javascript.ru/number#delenie-na-nol-infinity
        b = 1 + Infinity  === Infinity     &&  
            1 - Infinity  === -Infinity    &&
            1 / Infinity  === 0            &&
           -1 / Infinity  === -0           && // минус ноль (бесконечно малое отрицательное число)
		               -0 === 0            &&
            1 / 0         === Infinity     && // Деление на 0 даёт бесконечность, а не ошибку 
        ""+ 0 / 0         === "NaN"        && // Не допустимы: деление 0 на 0,
        ""+ 0 * Infinity  === "NaN"        && // умножение нуля на бесконечность,
        ""+(5 + NaN)      === "NaN"        && // арифметические операции с NaN,
                NaN       !=   NaN         && // NaN не равен ничему - даже самому себе
        ""+ Infinity / Infinity  === "NaN" && // деление двух бесконечностей,
        ""+(Infinity - Infinity) === "NaN" && // вычитание двух бесконечностей.
            isNaN(0/0)  && // Функция isNaN(n) возвращает true если её аргумент NaN
            isFinite(5);   // isFinite(n) возращает true если её аргумент - конечное число    
        console.log("Результат проверки всех особых операций с числами: " + b);
    
    /* Особенности арифметического переполнения и искажений хранения */
        /* 32-битная операция умножения целого числа на 2 путем сдвига влево вызовет 
           переполнение на меньших числах, чем обычное умножение 64-битного вещественного */
        console.log("Переполнение: вместо 20000000000 получаем " + (10000000000 << 1)); 
        numb1 = Number.MAX_SAFE_INTEGER; /* 9007199254740991 - это максимальное целое число 
                                            которое сохранится без искажений */
        bool1 = (numb1+1) == (numb1+2); //Результат true (обе суммы дают результат 9007199254740992) 
  console.groupEnd("Операции");
  }

  {/* ПРИВЕДЕНИЕ ПРОСТЫХ ТИПОВ ПРИ ОПЕРАЦИЯХ 
       https://learn.javascript.ru/types-conversion  */  
  console.groupCollapsed("Приведение простых типов при операциях");

    // Автоматическое строковое преобразование
        str1 = 1 + '2'; /* == 12. Если один из двух операндов при сложении является строкой, 
                           то производится конкатенация строк, а не арифметическое сложение. */
        
        str1 = 1 + 2 + 3 + '4' + 5 + 6; /* == 6456. Несколько операций сложения подряд выполняются 
             слева направо. Пока операнды чиловые происходит арифметическое сложение. Но как только 
             поступает строковый операнд, все остальные операции будут соединять строки. */
        
        console.log(numb1); // Там где ожидается строка простые типы приводятся к строке.

    // Явное строковое преобразование
        str1 = String( bool1 );  /* Функция string преобразует любой тип в строку.   
                                    http://javascript.ru/String   */
        str1 = "" + true + 25 + null; // Явно приводит к строке конкатенация с пустой строкой.

        // Справедливы следующие равенства:
        b = "" + undefined  === "undefined" &&  
            "" + null       === "null"      &&
            "" + NaN        === "NaN"       &&
            "" + Infinity   === "Infinity"  &&
            "" + true       === "true"      &&
            "" + false      === "false";     
        console.log("Результат проверки всех преобразований в строку: " + b); // true
        
        // Приведение типа значения к строке. Справедливы следующие равенства:
        b = typeof ""   === "string"  &&
            typeof 1    === "number"  &&
            typeof NaN  === "number"  &&  // "не число" тем не менее имеет тип number
            typeof true === "boolean" &&
            typeof null === "object"  &&  // Устоявшаяся ошибка языка JS для значений null
            typeof undefined === "undefined";     
        console.log("Результат проверки всех приведений типов к строке: " + b); // true

        /* Приведение числа к строке в разных системах счисления
                https://learn.javascript.ru/number#tostring-sistema-schisleniya
            toString(n) - метод численных значений, возвращающий 
                          строку в системе счисления по основанию n */
        numb1 = 175; numb2 = 3.14;
        // Справедливы следующие равенства:
        b = numb1.toString()   === "175"      && // По умолчанию используется десятичная система
            numb1.toString(16) === "af"       && // Представление числа как шестнадцатиричное,
            numb1.toString(2)  === "10101111" && // двоичное.
            numb1.toString(36) === "4v"       && /* Максимальное основание 36 - использует цифры 
                                                    и все латинские малые буквы */
            numb2.toString()   === "3.14"     && // Вещественные числа тоже допустимы
            numb2.toString(36) === "3.51fu8n1fu9";  // в любых системах счисления
        console.log("Результат проверки всех вызовов toString: " + b); // true
        
        // Приведение числа к строке в национальном формате
                // https://learn.javascript.ru/intl
        numb1 = 1234567.12345;
        str1 = numb1.toLocaleString(); // "1 234 567,123"  

    /* Автоматическое численное преобразование. 
       Происходит при арифметических операциях и сравнениях с числами. */
        // Если при сложении среди операндов нет строки, то все операнды приводятся к числу:
            i = 1 + null + true; // 2
        // С другими арифметическими операциями все строки всегда приводятся к числу:
            i = '1' / '2' - '3' * '4' % '5';  // -1.5
        // Результат равен NaN в случае если хотя бы одна строка дала ошибку преобразования:
            i = '1' - '2б';  // NaN
			i = '1' - '  \n 789 '; /* При преобразовании строки в число пробельные символы 
                                      по краям обрезаются (включая переносы строк) */

        /* Операции сравнения == < <= > >= приводят свои операнды к числу 
           (за исключением если они оба - строки)  */
        
    // Явное численное преобразование
        i = + '789';       // Унарный плюс приводит любой операнд к числу
        i = Number('789'); // Тот же эффект у функции Number()

        // Cправедливы следующие равенства
        bool1 = isNaN(+ undefined) &&  
                isNaN(+ "123 456") && // Пробел внутри строки недопустим
                + ""    === 0      && // Пустая строка даёт 0
                + null  === 0      && 
                + true  === 1      &&
                + false === 0;         
        console.log("Результат проверки всех преобразований в число: " + bool1); // true

        // Приведение целого числа к вещественному не нужно, т.к. все числа хранятся вещественными
        /* Приведение вещественного числа к целому и функции округления:
                 https://learn.javascript.ru/number#okruglenie  */
            numb1 = Math.floor(3.2);  // == 3  Округление числа вниз
            numb1 = Math.ceil(3.2);   // == 4  Округление числа вверх
            numb1 = Math.round(3.2);  // == 3  Округление до ближайшего целого
            numb1 = 3.14159;
            numb2 = numb1.toFixed(2); // == 3.14  Метод toFixed(n) округляет до n знаков после точки
            numb2 = numb1 ^ 0; /* Если для хранения целой части хватает 32 бит, 
                                  то её удобно получать применением побитовой операции XOR */
        
        /* Функции парсинга строки считывают число из начала строки даже если после цифр идут буквы. 
                https://learn.javascript.ru/number#myagkoe-preobrazovanie-parseint-i-parsefloat */
        // Справедливы следующие равенства:
        b = parseInt('45px')    ===  45 &&  // parseInt() - функция парсинга целого числа   
            parseInt('87.95 р') ===  87 &&  // Парсинг целого числа заканчивается на точке 
            parseInt('3.2e5')   ===   3 &&  // Научный формат как целое число НЕ распознается
            parseInt('0x10')    ===  16 &&  // Шестнадцатиричное число обрабатывается корректно
            parseInt('010')     ===  10 &&  // Восьмиричное число обрабатывается как десятичное. 
            // Для произвольных систем счисления можно вторым аргументом указать основание:
            parseInt('100',2)   ===   4 &&  // Двоичное число
            parseInt(' \n 5px') ===   5 &&  // Допустимы пробелы и переносы строки вначале
            isNaN(parseInt(""))         &&  // Если в строке нет цифр, то результат NaN     
            isNaN(parseInt("$25"))      &&  // Если первый значимый символ не цифра или пробел - NaN
            isNaN(parseInt('Infinity')) &&  // Бесконечность не является целым числом - NaN     
            parseFloat('45.8px')   === 45.8  && // parseFloat - функция парсинга вещественного числа   
            parseFloat('87.95.38') === 87.95 && // На второй точке парсинг останавливается
            parseFloat('3.2e-2')   === 0.032 && // Научный формат парсится корректно для вещ.чисел
            parseFloat('0x10')     === 0     && // Шестнадцатиричное число не парсится как Float
            parseFloat('Infinity!') === Infinity;  // Бесконечность распознается как вещественное 
        console.log("Результат проверки всех парсингов чисел: " + b); // true
                 
        // Проверка, является ли выражение числом или строкой, приводящеся к числу:
            if (!isNaN(parseFloat(numb1))) // Такая проверка отсекает значения "", null, true, false
                console.log("В переменной Numb1 хранится число.");
            if (!isNaN(parseFloat(numb1)) && isFinite(numb1)) // + отсечение бесконечных значений
                console.log("В переменной Numb1 хранится конечное число.");
    
    // Автоматическое логическое преобразование - там где ожидается логическое значение.
        if (numb1) j=5; // Если число numb1 отлично от 0 или NaN, то выполнится операция j=5
        if (str1) j=5;  // Если строка str1 не пустая, то выполнится операция j=5.
        
        /* Операции && и || используют логический эквивалент операндов, 
           но возращают непреобразованное значение. */
            bool1 = numb1 && str1;  // В bool1 запишется число или строка, но не true или false 
        
        /* В последовательности логических И/ИЛИ возвращается первое слева значение, 
           которое приводится к false/true. Если таковых нет, то возвратится последнее 
           значение в последовательности. 
                https://learn.javascript.ru/logical-ops#korotkiy-tsikl-vychisleniy  */
            i = 1 && 2 && 3 && 0 && 4 && 5; // i==0 
            str1 = "" || 0 || "abc" || "";  // str1=="abc" 
            // При этом над оставшимися операндами вычисление не производятся:
            (numb1 = 0) || (numb2 = 5) || (numb3 = 10); /* В numb3 ничего не будет записано, так как 
                                                   на операнде (numb2 = 5) вычисления прекратятся */
    
    // Явное логическое преобразование        
        bool1 = !!789; // Два логических НЕ подряд приводят любой операнд к логическому    
        bool1 = Boolean(789); // Тот же эффект у функции Boolean() 

        // Справедливы следующие равенства
        bool1 = ( !! " "  === true  ) &&  // Пробел не является пустой строкой
                ( !! ""   === false ) && 
                ( !! 0    === false ) && 
                ( !! NaN  === false ) &&  // Все остальные числа дают true
                ( !! null === false ) && 
           ( !! undefined === false );    // Все остальные значения и объекты преобразуются в true
        console.log("Результат проверки преобразований в логическое значение: " + bool1); // true
console.groupEnd("Приведение простых типов при операциях");        
}

  {/* МАТЕМАТИЧЕСКИЕ ФУНКЦИИ И КОНСТАНТЫ */  
  console.groupCollapsed("Математические функции и работа со строками");
    // https://learn.javascript.ru/number#drugie-matematicheskie-metody  

    numb1 = Math.PI;  // Число Пи == 3.141592653589793
    numb1 = Math.E;   // Число e  == 2.718281828459045
    numb1 = Math.random();    // Генерация псевдослучайного числа:  0 <= Math.random() < 1. 

    numb1 = Math.abs(-3.14);  // == 3.14  Абсолютное значение числа (модуль числа)
    numb1 = Math.log(10);     /* Натуральный логарифм числа. 
                                 log(x) - степень в которую нужно возвести e чтобы получить x. */
    numb1 = Math.exp(1);      // Натуральная экпонента. exp(x) == e в степени x.
        console.log("Число e: " + numb1);
    numb1 = Math.max(2,-1,7); // Максимальное число из перечисленных аргументов
    numb1 = Math.min(2,-1,7); // Минимальное число из перечисленных аргументов
    
    // Тригонометрические функции
    numb1 = Math.sin(3.14/2); // Синус числа (для числа Пи/2 равен 1)
    numb1 = Math.cos(3.14);   // Косинус числа (для числа Пи равен -1)
    numb1 = Math.tan(3.14/4); // Тангенс числа (для числа Пи/4 равен 1)
    
    numb1 = Math.asin(1);     /* Арксинус числа (для числа 1 равен Пи / 2). 
                                     Аргумент должен быть <= 1 по модулю. Иначе - NaN */
    numb1 = Math.acos(-1);    /* Аркосинус числа (для числа 0 равен Пи). 
                                    Аргумент должен быть <= 1 по модулю. Иначе - NaN */
    numb1 = Math.atan(1);     // Арктангенс числа (для числа 1 равен Пи/4)
    // Арктангенс по координатам точки (y,x) на плоскости:
    numb1 = Math.atan2(-5,5);  // для угла 315 градусов равен Пи/4
        // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2
}        

  {/* РАБОТА СО СТРОКАМИ */
        // https://learn.javascript.ru/string   
    str1 = "Тестовая строка";
    numb1 = str1.length;  // Длина строки возвращается свойством .length 
    
    // Посимвольное чтение строки (перезапись символа в существующей строке недоступна). 
    str2 = str1.charAt(0);  // Метод charAt(N) возращает N-й символ строки (нумерация с 0)
    str2 = str1[0]; // Альтернативный способ получения N-го символа
    bool1 = str1.charAt(30) === "";  // Если символа нет charAt() возращает пустую строку,
    bool1 = str1[30] === undefined;  // а доступ с помощью квадратных скобок - undefined.
    
    // Смена регистра символов
    str2 = str1.toUpperCase(); // Метод .toUpperCase() возвращает строку в верхнем регистре 
    str2 = str1.toLowerCase(); // Метод .toLowerCase() возвращает строку в нижнем регистре 
    
    // Поиск позиции подстроки в строке
    str2 = str1.indexOf("ока");  // == 12   Метод .indexOf() возвращает позицию подстроки в строке
    str2 = str1.indexOf("ст",6); // == 9    Вторым аргументом можно указать позицию начала поиска
    str2 = str1.indexOf("Ст");   /* == -1   Поиск чувствителен к регистру. 
                                    Если ничего не найдено метод возвращает значение -1  */
    // Аналогичный поиск с конца строки, начиная с указанной позиции
    str2 = str1.lastIndexOf("ст",6); // == 2  
    
    // Поиск всех вхождений подстроки в строку
    i = -1;
    while ((i = str1.indexOf("т", i+1)) != -1) { 
        console.log("Подстрока найдена в позиции " + i);
    }

    // Проверка входит ли подстрока в строку удобно делается синтаксическим сахаром:
    if (~str1.indexOf("ока")) {  // Побитовый оператор ~ для -1 даст 0, иначе - отрицательное число
        console.log("Подстрока найдена.");  
    };
    
    // Получение подстроки. Доступно три метода:
    
    // .substring()  - по позициям границ подстроки
    str1 = "1234567890";
    str2 = str1.substring(5);    // == "67890" (считать строку начиная с указанной позиции 9)
    str2 = str1.substring(5,8);  // == "678"  (2-й параметр - перед каким символом остановиться)
    str2 = str1.substring(8,5);  // == "678"  (если второй параметр меньше, то они меняются местами)
    str2 = str1.substring(-2,4); // == "1234" (отрицательные числа меняются на 0)
    
    // .substr()  - по отступу с начала или конца строки и длине результата:
    str2 = str1.substr(5,3);     // == "678"   (2-й параметр - сколько символов прочитать)
    str2 = str1.substr(5);       // == "67890" (2-й параметр можно не указывать)
    str2 = str1.substr(-6,4);    // == "5678" (отрицательное число - номер позиции с конца строки)
    str2 = str1.substr(6,-4);    // == ""     (отрицательное число во 2-м параметре - то же что 0)

    // .slice()  - по двум отступам с начала или конца строки:
    str2 = str1.slice(-6);       // == "567890" (без 2-го параметра метод работает как substr())
    str2 = str1.slice(5,8);      // == "678"  ( 2-й параметр похож на substring() но:
    str2 = str1.slice(5,-1);     // == "6789"   отрицательное значение - это позиция с конца строки 
    str2 = str1.slice(12,9);     // == ""       и параметры местами не меняются )                   
    
    // Получение кода символа - через строковый метод charCodeAt(n) где n - позиция символа в строке
        numb1 = "12345".charCodeAt(5);     // Код символа "4" == 52 
    // Получение символа по его коду - через строковый метод fromCharCode() :
        str2 = String.fromCharCode(52); // Коду 52 соответсвует символ "4"
    
    // Сравнение строк по кодам символов:
        // Справедливы следующие равенства:
        b = "ежик"== "ежик" &&  // Строки равны, если все их символы совпадают
            "ежик" > "еж"   &&  // При совпадении символов более длинная строка - больше 
            "ежик" < "лис"  &&  // Если код первого неравного символа больше, то вся строка больше
            "ежик" > "Лис"  &&  // Коды строчных букв больше прописных
            "ёжик" > "лис"  &&  // Буква ё идёт после основного алфавита
            "Ёжик" < "Лис";     // Буква Ё идёт перед основным алфавитом
        console.log("Результат сравнения строк по кодам символов: " + b); // true

    // Сравнение строк по алфавиту производится строковым методом .localeCompare()
        numb1 = "лис".localeCompare("лис");   // == 0  для равных строк
        numb1 = "ежик".localeCompare("лис");  // == -1 если первая строка меньше
        numb1 = "ежик".localeCompare("аист"); // == 1 если первая строка больше
        // Справедливы следующие равенства:
        b = "ежик".localeCompare("Ежик") == -1 && // Строчная буква меньше такой же прописной
            "Ежик".localeCompare("лис")  == -1 && // Алфавит идёт в порядке аАбБвВгГ и т.д.
            "ёжик".localeCompare("лис")  == -1;   // Буквы ёЁ обрабатываются корректно
        console.log("Результат сравнения строк по алфавиту: " + b); // true
        
  console.groupEnd("Математические функции и работа со строками");        
  console.groupEnd("Хранение и обработка данных в оперативной памяти");
  }

  var f01 = function() {/* ПРОЦЕДУРНОЕ ПРОГРАММИРОВАНИЕ  
        https://learn.javascript.ru/function-basics
    Функция   - это блок программы, который принимает на вход аргументы 
                и возвращает некое значение (или значения).
    Процедура - блок программы, которому могут передаваться или не передаваться на вход аргументы, 
                но который (в отличие от функции) не возвращает значения, а просто совершает некие 
                побочные действия (ввод/вывод, изменение значений глобальных переменных и т.д.).
    В JavaScript в качестве процедуры можно использовать функцию, которая не возвращает значения
    (такие функции возвращают undefined). */
    console.groupCollapsed("Процедурное программирование");
  
    /* Объявление функции в режиме Function Declaration (допустимо в любом месте кода).
       В некоторых старых браузерах допустимо только на верхнем уровне или внутри другой функции.
       После имени функции и круглых скобок задается блок операторов, являющийся телом функции: */
        function proc1() {  
            'use strict';   /* В начале функции можно задавать режим strict для интерпретатора. 
                               Он будет действовать в пределах функции */
            // Эта функция просто совершает побочное действие - выводит строку в консоль:                               
            console.log('Выполняется процедура proc1');  
        }
    
    // Вызов функций без аргументов
        proc1(); // Вызов функции без аргументов
        proc3(); // В режиме Function Declaration вызов функции можно делать до объявления функции 

        var proc1b = function(){   // Объявление функции в режиме Function Expression
		    // Такая функция создаётся в момент вычисления выражения, а не на этапе компиляции
            console.log('Выполняется процедура proc1b'); 
        }
        proc1b(); /* Если функция объявлена в режиме Function Expression вызов функции можно делать
                     только после объявления функции - ведь до объявления выражение неизвестно */
        proc1b = null; // Переменную содержащую функциональное выражение можно обнулить
    
	// Область видимости переменных    
        function proc2() { 
            str1 = "Новое значение"; /* Из тела функции можно изменять глобальные переменные. 
			    Если глобальная переменная не существует то в режиме Strict это вызовет ошибку. */
            var str2 = "Локальное значение";  /* Директивой var можно объявить локальную переменную, 
                                                 даже если её имя совпадает с глобальной. 
                                При этом в теле функции обрабатывается локальное значение: */      
            console.log("Внутри функции str2 == " + str2); 
		}
        str1 = str2 = "Глобальное значение";  // Внешние (глобальные) переменные
        proc2(); // Функция изменила глобальную переменную str1 (плохое поведение)
 			console.log("Теперь str1 == " + str1); 
        // Вне тела функции остаётся неизменным глобальное значение переменной str2:
			console.log("Вне тела функции str2 == " + str2); 

        
    
	/*  Использование аргументов, переданных в функцию. 
		Доступ к необъявленным аргументам в теле функции - через коллекцию arguments[]        
            https://learn.javascript.ru/arguments-pseudoarray  */
        function proc3() { // Вывод первых двух аргументов в консоль. Может не работать в Gecko
        // console.log("Функцией proc2 получены аргументы: " + arguments[0] + " и " + arguments[1]);  
        }
        
        function proc4(width, height) { /* Можно указать имена аргументов. 
                                           Они станут локальными переменными внутри функции   */
            var s1 = "Ширина: " + width + ", Высота: " + height; 
            /* var width = 65, height = 75; /* Значение аргументов можно по неосторожности заменить 
                на другое. Интерпретатор ошибки не покажет (кроме старых браузеров). 
                Эту особенность можно использовать для проставления значений по умолчанию 
                (если аргумент не передан в функцию): */
            if (width === undefined) width = 0; // Очевидный способ
            width = width || 0; // Компактный но менее наглядный способ ( особенность оператора || )
			console.log("Функцией proc4 получены аргументы. " + s1);
        }
    
    // Вызов функций с аргументами
    
        /* В круглых скобках через запятую можно передать в функцию произвольное количество 
            аргументов, даже если они не были объявлены при объявлении функции: */
        proc1("Строка1", "Строка2", 15, true );
        proc4(35,45); 
        proc4("Только один аргумент"); /* Если передать аргументов меньше задуманного, то для 
                                   непереданных аргументов будет возвращаться значение undefined */
    
    // Вызов функции по таймеру
        function f1(){};
        setTimeout(f1, 100); // Отложить вызов функции f1 на 100 миллисекунд
        var timer1 = setTimeout(f1, 3000); // Можно сохранить в переменную идентификатор таймера
        clearTimeout(timer1); // Пока функция не выполнена, таймер можно отменить
        setTimeout(f1, 100, 3, 4); // Аргументы 3,4,5,.. будут переданы в вызываемую функцию
        
    // Вызов функции через определённые интервалы
        // Вызов каждые N миллисекунд
            var timer2 = setInterval(f1, 500); // Каждые полсекунды будет вызываться f1
            setTimeout(function() {clearInterval(timer2);}, 5000); // Стоп повторов через 5 секунд
        
        // Задание пауз между вызовами (с помощью рекурсии)
            var timer3 = setTimeout(function f2() {
                console.log("Сработала функция f2()");
                timer3 = setTimeout(f2, 100);  // Пауза между вызовами будет 100 мс.
                }, 4000); // Запустить все вызовы через 4 сек.
            setTimeout(function() {clearTimeout(timer3);}, 5000); // прекращаем через 5 сек.
        
  console.groupEnd("Процедурное программирование");
  }; f01();
  
  var f02 = function() {/* ФУНКЦИОНАЛЬНОЕ ПРОГРАММИРОВАНИЕ 
        ФП предполагает использование функций без взаимодействия с внешними переменными и без 
        произведения побочных действий. Все нужные данные передаются в функцию в виде аргументов и
        функция взаимодействует с внешним миром только путем возврата значений. */
  console.groupCollapsed("Функциональное программирование");
    
    // Возвращение значений из функции   
        function summ_sqr(a, b) { 
            return a*a + b*b;  /* Возврат значения осуществляется ключевым словом return и 
                возвращаемым выражением после него (которое может быть произвольного типа). 
				После return компилятор прекращает выполнение тела функции. */
            console.log("Это сообщение не отобразится"); 
            return; /* Если указать return без возвращаемого выражения, то это аналогично директиве 
                break в цикле - будет прервано выполнение тела функции без возврата конкретного 
                значения (т.е. ведёт себя как процедура). */
        }
        // Функция-процедура возвращает undefined:
        function emptyFunc() {} 
        console.log("Пустая функция возвращает " + emptyFunc() ); 
    
    // Имя функции как переменная. Функциональные выражения
           // https://learn.javascript.ru/function-declaration-expression
        str1 = "" + summ_sqr; /* Имя фукнции без скобок является переменной, хранящей код функции. 
                              Его содержимое можно сохранить в строковую переменную. */
        var func1b = summ_sqr; // Функцию можно продублировать в новую переменную
        
    // Область видимости функций и функциональных выражений
     // { function localFunc() {}} // Функция объявленная внутри блока {} не видна за его границами 

        /* Для разграничения области видимости используются именованные функциональные выражения 
           (NFE - Named Function Expression)
             https://learn.javascript.ru/named-function-expression  */
        var f1 = function myFunc(){  /* f1 - глобальная переменная , а myFunc - локальная, 
                                        которую нельзя изменить снаружи (что важно для рекурсии) */
            return (f1 == myFunc) ? true : false;  /* Кажется что f1 и myFunc равны, и ожидается что 
                                                      функция всегда будет возвращать true */
        }
        if (f1()) console.log('Функция для обоих своих имён работает корректно.');  // f1 == myFunc  
        
        var f2 = f1; f1 = null; /* Если перезаписать глобальную переменную, то коррекное обращение 
                                   к функции по глобальному имени перестанет работать:  */
        if (!f2()) // Внутри функции продолжает работать сравнение, где теперь f1 != myFunc
            console.log('Функция перестала работать, т.к. её глобальное имя f1 перезаписано.'); 
        
        f1 = f2; var myFunc = null; /* Восстанавливаем переменную какой она была и пробуем теперь 
                                   изменить именованное функциональное выражение.  */
        if (f1()) // Внутри функции f1 == myFunc
            console.log('Функция снова работает корректно - снаружи невозможно изменить то, ' + 
                        'что хранится в её локальном имени.'); 
 
    // Передача функции в качестве аргумента другой функции   
        function applyFunc3(f,a,b,c){ // Объявление функции принимающей на вход другую функцию
            var x = f(a,b); // В этом примере к аргументам a,b,c попарно применяется функция f
            return f(x,c);
        }
        function sum(a,b) { // Функция сложения, используемая для передачи в качестве аргумента
            return a + b;
        }
        i = applyFunc3(sum, 2, 3, 4); // К числам применяется функция сложения.
        console.log('Результат применения функции sum к числам: ' + i); // i == 9
       
    
    /* Анонимные функции (замыкания) - это функции которые объявляются прямо там где используются, 
       без сохранения в именованную переменную. Поскольку эти функции выполняются сразу при их 
       определении, то они имеют название Immediately Invoked Function Expression (IIFE).       */
        
        // К числам применяется функция умножения, созданная на лету:
			i = applyFunc3( function(a,b){return a*b;}, 2, 3, 4 ); 
			console.log('Результат применения анонимной функции умножения: ' + i); // i == 24
        
        // Анонимную функцию можно создать, обернув её объявление в скобки
			(function (s){
			console.log("Удвоенная строка: " + s + s);
			}("АБВГД"));  // Выведется "АБВГДАБВГД"
		
  console.groupEnd("Функциональное программирование");
  }; f02();
}

{/* ОРГАНИЗАЦИЯ ЛОГИКИ ПРОГРАММЫ */
  console.groupCollapsed("Организация логики программы");

  {/* ВЕТВЛЕНИЯ В ЛОГИКЕ ПРОГРАММЫ
       https://learn.javascript.ru/ifelse   */

console.groupCollapsed("Организация ветвлений в логике программы");
        
    // Условие с одной ветвью
        if (bool1) str1 = 'Yes';
        // Запись в несколько строк:
        if (!bool1) {
            str1 = 'No';
        }
    // Условие с двумя ветвями
        if (bool1) str1 = 'Yes'; 
            else str1 = 'No';
        // Запись в несколько строк:
        if (bool1) {
            str1 = 'Yes'; 
        } else {
            str1 = 'No';
        }
    // Множественный выбор между несколькими условиями:
        if        (numb2 == 0)  { j = 0; 
        } else if (numb2 < 10)  { j = 2;
        } else if (numb2 < 100) { j = 5;
        } else                  { j = 10;
        }
        
    // Сравнение по образцу
        //    https://learn.javascript.ru/switch
        i = 2;
        switch(i) {     // В скобках задается выражение, для точного сравнения ===
            case  1:    // Директива case действует аналогично оператору if (i === 1)
                j='а';  /* От двоеточия до следующего case перечисляются инструкции, 
                           которые выполнятся в случае истинности сравнения */
                break;  // Если директива break выполнится, то она прервёт работу блока switch.
            case  2: j='б'; break; /* Поскольку i===2 эта инструкция будет выполнена и работа всего 
                                      блока switch закончится (присутсвует break) */
            case  3: j='в'; break; // Эту и последующие строки интерпретатор пропустит
            case  4: j='д'; break;
            default: j='_';        /* Если бы ни один образец не совпал, то сработают инструкции 
                                      заданные после директивы default */
        }  
        console.log("Числу " + i + " соответствует буква " + j); // j == "б"

        /* Если break не указать, то будут выполнены все остальные инструкции блока БЕЗ СРАВНЕНИЙ 
           с образцами. Т.е. в этом случае конструкция switch действует как переход по метке  */
        j="";
        switch(i) {     
           case  1: j+='а'; // i!==1 и значит инструкция не выполнится
           case  2: j+='б'; // i===2, инструкция выполнится и отключится режим сравнения с образцами
           case  3: j+='в'; // Все интсрукции выполнятся, т.к. сравнение больше не производится
           case  4: j+='д'; // Директиву default можно опускать
        }                    
        console.log("Начиная с числа " + i + " идет набор букв " + j); // j == "бвд"
    
    /* Тернарная условная операция. Это операция, возвращающая свой второй или третий операнд 
       в зависимости от значения логического выражения, заданного первым операндом. */
        bool1 = (numb1 > 10) ? true : false; // Формат записи:    условие ? значение1 : значение2
        bool1 = numb1 > 10 ? true : false;   // То же без скобок (у оператора ? низкий приоритет)
        // Цепочка тернарных условных операций:
		numb2 = 5;
        j = numb2 == 0   ? 0 :
            numb2 < 10   ? 2 :
            numb2 < 100  ? 5 :
                            10 ;
        console.log("Числу " + numb2 + " соответсвует число " + j); 

  console.groupEnd("Организация ветвлений в логике программы");
  }
  
  {/* БЕЗУСЛОВНЫЕ УПРАВЛЯЮЩИЕ КОММАНДЫ 
            https://puzzleweb.ru/javascript/11_loops3.php   */
        block1: { // Блок операторов можно пометить именованной меткой, завершающейся двоеточием
            i = 2;
            break block1; // Директива break прерывает выполнение блока с указанным именем
            i = 3; // Этот оператор не будет выполнен
        }
        console.log('Выполнение блока операторов прервано. i = ' + i);
  }

  {/* ЦИКЛЫ
        https://learn.javascript.ru/while-for   */    
  console.groupCollapsed("Циклы");
        
    // Цикл со счётчиком
        str1 = "";
        // В этом примере на каждой итерации счётчик увеличивается на 1 в порядке возрастания:
        for (i=1; i<10; i++) // (начало; условие; шаг) 
            str1 += i + " "; 
        
        for (; i>0; ) // Операторы в условии цикла можно оставлять пустыми  
            str1 += i-- + " "; 
        console.log("Счет от 1 до 10 и обратно: " + str1);
            
        var factorial1 = 1;
        // Если в теле цикла несколько операторов, то они заключаются в логический блок {} :
        for (i=2; i<=5; i++) { 
            factorial1 = factorial1 * i; 
            console.log(i + '! = ' + factorial1 + '; ');
        }
        
    // Вложенный цикл со счётчиком
        console.log('Таблица сложения:'); 
        for (i=1; i<=5; i++) {
            str1 = "";
            for (j=1; j<=5; j++) {
                str1 += Number(i+j) + ' '; 
            }
            console.log(str1);
        }
        console.log('После выполнения циклов значения счётчиков сохраняются: ' + 
                    'i = ' + i + ' и j = ' + j);
        
    // Цикл с предусловием
        i=12;
        while (i<90) { // Удваиваем число если оно меньше 90
            i *= 2;
        }
        console.log('Цикл с предусловием окончен. i = ' + i);
        
    // Цикл с постусловием
        do 
            i /= 3;   // Можно использовать несколько операторов без заключения их в блок {}
        while (i>10); // Уменьшаем число в 3 раза пока не преодолеем порог меньше 10
        console.log('Цикл с постусловием окончен. i = ' + i);

    // Перерывание работы цикла
        for (;;i++) { // При таком условии цикл будет повторяться вечно, если его не прервать
            if (i % 2 == 0) continue; // Переход на следующую итерацию текущего цикла
            if (i > 30) break; // Выход из текущего цикла
        } 
        console.log('Вечный цикл окончен. i = ' + i);
        
        // С помощью break сделаем таблицу сложения треугольной
        console.log('Нечетные строки треугольной таблицы сложения:'); 
        loop1: for (i=1; i<=5; i++) { // Цикл как и обычный блок можно пометить именованной меткой
            str1 = "";
            loop2: for (j=1; j<=5; j++) {
                if (j>i) break loop2; // Выход из цикла помеченного меткой loop2
                if (i%2 == 0) continue loop1; // Переход на следующую итерацию цикла loop1
                str1 += Number(i+j) + ' ';
            }    
            console.log(str1);
        } 
  console.groupEnd("Циклы");    
  }

  {/* РЕКУРСИЯ 
        https://learn.javascript.ru/recursion  */ 
  console.groupCollapsed("Рекурсия");
    
    // Рекурсия с ветвлением по условию:
        var factorial = function f(n){  // Вычисление факториала от n
            if (n==0) return 1; /* else можно не писать, поскольку в случае n==0 на этой строке 
                                   функция завершит работу  */
            return n * f(n-1); 
        }
        console.log("10! = " + factorial(10)); //  == 3628800
        
        
        var summNatural = function f(n){  // Сумма натуральных чисел от 1 до n
            return n ? n + f(n-1) : n;  // Тернарный условный оператор ? делает код компактнее
        }
        console.log("1 + .. + 10 = " + summNatural(10)); //  == 55
    
    // Рекурсия через множественный выбор
        var factorial2 = function f(n){    /* Эта версия функции корректно обрабатывает всё что 
                                              не является положительным числом, возвращая NaN   */
            return n > 200 ? Infinity   :  // Для запредельных значений сразу возвращаем Infinity
                   n > 0   ? n * f(n-1) :  // Цепочка операторов ? проверяет несколько условий.
                   n === 0 ? 1          :
                             NaN; 
        }
        console.log("10! = " + factorial2(10)); //  == 3628800
    
    // Рекурсия со вспомогательной функцией для хранения промежуточного значения
        var prime = function pr(n) { // Функция проверки простое ли число (даёт true или false)
            // Локальная вспомогательная функция:
            function pr_(n,m) {  // Аргумент m хранит число, до которого произведена проверка
                return m * m > n  ? true  : // Все кандидаты на делители проверены - возвращаем true 
                       n % m == 0 ? false : // Делитель найден - возвращаем false
                       pr_(n,m+1); // Рекурсивный вызов проверки следующего кандидата на делителя
            }
            return n > 0 ? pr_(n,2) : NaN; /* Для положительного числа запускаем вспомогательную 
                                              функцию проверки кандидатов на делители начиная с 2 */
        }  
        str1='';
        for (i=2; i<128; i++)   // Формируем список простых чисел
            if (prime(i)) str1 += " " + i + " ";   
        console.log("Простые числа: " + str1);
  console.groupEnd("Рекурсия");       
  }
  
  {/* ПЕРЕХВАТ ОШИБОК ВЫПОЛНЕНИЯ 
        https://learn.javascript.ru/exception  */
    console.groupCollapsed("Перехват ошибок выполнения");
    
    // Простая обработка ошибок, выявляемых интерпретатором
        try { // Конструкция try…catch позволяет предотвратить падение скрипта в случае ошибки.
            zxc + 1; // Тут ошибка - попытка использования несуществующей переменной
        } catch(e) { // Данные об ошибке можно посмотреть в возвращённом объекте e
            console.log('Ошибка ' + e.name + ": " + e.message + "\n" + e.stack); 
        }
        
    // Принудительная генерация ошибки оператором throw
        i=200;
        try { // throw вызывается в связке с функциями SyntaxError, ReferenceError, RangeError и пр.
            if (i > 100)  throw new RangeError("Число больше допустимого.");
        } catch(e) {
            console.log('Ошибка ' + e.name + ": " + e.message); 
        }
        
    // Возврат (проброс) ошибки из блока catch (избирательная обработка ошибок)
        var checkRange = function() {
            try { // Ситуация, когда переменная zxc по каким-то причинам не существует:
                if (zxc > 100)  throw new RangeError("Число больше допустимого.");
            } catch(e) {
                if (e.name == "RangeError") { 
                    console.log('Ошибка ' + e.name + ": " + e.message); 
                } else {   
                    throw e; // Проблема не в размере числа, поэтому генерируем ошибку как если бы
        }}} // не было блока try…catch (в расчете на то что она будет обработана уровнем выше)
        
        try { // В функции обрабатываются ошибки диаппазона, а в этом блоке - все остальные ошибки
            checkRange();  // Пробуем вызвать функцию проверки размера числа
        } catch(e) { // Поймали другую непревиденную ошибку:
            console.log('Непредвиденная ошибка вызова checkRange:' + e.name + ": " + e.message); 
        }
    
    // Принудительное выполнение действий  независимо от результатов отлова ошибки
        
        
    console.groupEnd("Перехват ошибок выполнения");        
  }
  
  {/* ДИНАМИЧЕСКОЕ СОЗДАНИЕ КОДА И ДАННЫХ */
    console.groupCollapsed("Динамическое создание кода и данных");
        
        // Создание переменной в зависимости от условия
            if (true) { var condiVar = "Новый текст"; }
            console.log("Условие выполнилось и создана переменная с содержимым: " + condiVar); 
    
        // Создание функции в зависимости от условия
        // https://learn.javascript.ru/function-declaration-expression#bad-conditional-declaration
            if (true) { // В режиме Function Expression функцию можно объявлять внутри блока if
                var condiFunc = function(){ console.log(
                                            'Условие выполнилось и создана функция condiFunc.'); }   
            } 
            // Проверка того что функция создана перед ее вызовом (иначе скрипт может зависнуть):
            if (condiFunc) condiFunc(); 

		/* Генерация кода из текстовой строки. Можно создать код и поместить его в переменную
                https://learn.javascript.ru/eval  */
            str1 = "{ console.log('Выполняется сгенерированный код'); }";  
            /* Объявление функции через ключевые слова new Function (c большой буквы F) позволяет 
               двумя строками задать параметры и тело функции в виде строки:  */
            var genProc1 = new Function('', str1); 
            genProc1(); 
            var genFunc1 = new Function('a,b', ' return "Получены параметры " + a + " и " + b ');
            console.log( genFunc1(45,false) );
            
            eval(str1); // Менее надёжный метод - запуск кода функцией eval(). 
            window.eval(str1); // Выполнение кода в глобальной области.
            
    console.groupEnd("Динамическое создание кода и данных");        
  }

  console.groupEnd("Организация логики программы");
}

{/* СОСТАВНЫЕ СТРУКТУРЫ ДАННЫХ */ 
  console.groupCollapsed("Составные структуры данных");
  
  {/* СТАТИЧЕСКИЕ ЧИСЛОВЫЕ ТИПИЗИРОВАННЫЕ МАССИВЫ 
		https://learn.javascript.ru/arraybuffer-binary-arrays
		Типизированный массив - это набор элементов одного типа.
		Если количество элементов фиксировано, то такой массив называют статическим. */  

  console.groupCollapsed("Статические числовые типизированные массивы");
	// Базовый вариант создания статического массива - выделение области памяти указанного размера
	// и дальнейшее создание различных представлений, как интерпретировать байты это области:
	
	// Конструкция new ArrayBuffer(n)выделяет область памяти размером n байт:
	var memory1 = new ArrayBuffer(64);
	// Размер области памяти можно узнать с помощью свойства byteLength
		console.log("По ссылке memory1 выделено байт:" + memory1.byteLength);
	
	/* В области памяти можно создать массивы.
	  Именем функции задаётся то, как считывать данные из этой области */
	var arrUint8   = new   Uint8Array(memory1); //  8-битные целые числа без знака 
	var arrUint16  = new  Uint16Array(memory1); // 16-битные целые числа без знака 
	var arrUint32  = new  Uint32Array(memory1); // 32-битные целые числа без знака
	var arrInt8    = new    Int8Array(memory1); //  8-битные целые числа
	var arrInt16   = new   Int16Array(memory1); // 16-битные целые числа
	var arrInt32   = new   Int32Array(memory1); // 32-битные целые числа
	var arrFloat32 = new Float32Array(memory1); // 32-битные числа с плавающей точкой
	var arrFloat64 = new Float64Array(memory1); // 64-битные числа с плавающей точкой
	
	// Особый тип беззнакового 8-битного целого, которое при переполнении не обнуляется, а сохраняет
	// максимальное значение 255 (а при вычитании и уходе в минус - сохраняет 0):
	var arrUint8Clamped = new Uint8ClampedArray(memory1); 
	
	arrInt8[0] = -57; // Запись числа в первый элемент массива. 
	
	console.log("Данные области памяти дают разные числа в зависимости от представления:");
	console.log("arrUint32[0] == "  + arrUint32[0]);
	console.log("arrInt8[0] == "    + arrInt8[0]   );
	console.log("arrFloat64[0] == " + arrFloat64[0]);

	// Количество элементов массива можно узнать с помощью метода lenght:
	console.log("Из-за разности типов у массивов одного объёма разные количества элементов:");
	console.log("Длина массива arrInt8 == "    + arrInt8.length);
	console.log("Длина массива arrInt16 == "   + arrInt16.length);
	console.log("Длина массива arrInt32 == "   + arrInt32.length);
	console.log("Длина массива arrFloat64 == " + arrFloat64.length);

	// Свойство BYTES_PER_ELEMENT возвращает к-во байт, занимаемых одним элементом массива:
	console.log("Размер элемента массива arrInt32 в байтах: "   + arrInt32.BYTES_PER_ELEMENT);
	
	/* При создании представления для области памяти можно указать только часть этой области путём 
	   передачи вторым и третьим аргументами смещения и длины (в байтах). 
	   Если длина не указана, то диаппазон будет до конца области данных. */
	var arrUint16b  = new Uint16Array(memory1,8,4); // Массив ссылается на байты с 8 по 11-й	
	arrUint16b[0] = arrUint16b[1] = 0xFF; // Записали в эти числа максимальное значение
	
	// Использование конструкции DataView позволяет аналогичным образом считывать набор бит:
	var memView1 = new DataView(memory1,8,4);
	// и потом интерпретировать эти биты в соответствии тем или иным типом данных:
	console.log("Данные, начиная с 8-го байта, можно интерпретировать как числа: ");
	console.log("Uint8:  " + memView1.getUint8 (0));
	console.log("Uint16: " + memView1.getUint16(0));
	console.log("Uint32: " + memView1.getUint32(0));
	
	/* Можно не указывать имя области памяти, а просто задать нужное количество элементов массива.
		В этом случае область памяти будет создана автоматически: */
	var arrInt16с = new Int16Array(10); // Создан массив из десяти 16-битных чисел 
	
	// При этом можно обратиться к диаппазону памяти по свойству-ссылке .buffer
	var memory2 = arrInt16с.buffer;
	console.log("Размер области памяти для массива arrInt16с в байтах: " + memory2.byteLength);
	
	// Можно создать массив, скопировав все элементы из существующего массива (в т.ч. динамического)
	var arrInt32c = new Int32Array(arrInt16с);

	// Вызов без аргументов создаёт пустой массив нулевой длины
	var arrInt8b = new Int8Array();
	console.log("Длина массива arrInt8b == " + arrInt8b.length);
	
	// С помощью конструкции TextEncoder в числовой массив можно сохранить текстовую строку:
	// https://learn.javascript.ru/text-decoder
	if (typeof(TextEncoder)=="function") {
	var encoder1 = new TextEncoder(); // Создаём новый енкодер текста
	var textArray1 = encoder1.encode("Демо-текст"); // Метод .encode возвращает числовой массив
	console.log('Строка "Демо-текст" в числовом виде: ' + textArray1);
	
	/* Обратное преобразование чисел в строку делается с помощью декодера. В аргументах можно 
	   указать кодировку, способ обработки ошибок и  порядок следования байт: */
	var decoder1 = new TextDecoder(); // Создан новый декодера
	
	// Метод decode декодера обрабатывает числовой массив и возвращает строку:
	var str1 = decoder1.decode(textArray1); // Вторым аргументом можно задать дополнительные опции
											// (например обработки потоков данных)
	console.log('Числовой массив расшифрован в строку: ' + str1);
	} 
											
	// Копирование одного числового массива в другой осуществляется методом .set
		var textArray2 = new Uint8Array(21);
		textArray2.set(textArray1); // Массив 1 скопирован в массив 2
		// Вторым аргументом можно задать смещение, начиная с какой позиции вставлять данные
		textArray2.set(textArray1,2); // Массив вставлен со смещением в 2 байта
		console.log('Результат копирования массивов: ' + decoder1.decode(textArray2));

	// Вместо копирования в новый массив, можно создать ссылку на часть массива и работать с этой
	// переменной как с подмассивом основного массива: 
		var subArray1 = textArray2.subarray(2,8);  // Подмассив с позиции 2 до позиции 7
		console.log('Подмассив subArray1 соержит строку : ' + decoder1.decode(subArray1));
		
  console.groupEnd("Статические числовые типизированные массивы");    
  }

  {/* ДИНАМИЧЕСКИЕ НЕТИПИЗИРОВАННЫЕ МАССИВЫ
        Динамический массив - это набор произвольных элементов с доступом по числовому индексу.
        В JavaScript массивы эмулируются объектами, снабжёнными возможностями индексирования.
            https://learn.javascript.ru/array  */    
  console.groupCollapsed("Динамические нетипизированные массивы");

    // Создание и инициализация массива
        var arr1 = [];  // Пустой массив
        var arr1a = new Array(); // Альтернативная запись
        // Если в такой записи указать один числово аргумент, то он задаст длину массива
        var arr1b = new Array(10); // Создание массива длиной 10 элементов (их значения - undefined)
        var arr1b = new Array(10,3); // Создание массива из двух элементов 10 и 3
        var arr2 = ["А", "Б", 456, undefined, true]; // Создание массива с разнотипными элементами
    
    // Чтение и запись элементов массива
        k = arr2[0]; // Считать первый элемент массива (нумерация элементов - с нуля)
        b = arr2[9] == undefined; // Несуществующие и неинициализированные ячейки дают undefined
        
        arr2[2] = "Новое значение"; // Записать данные в элемент с индексом 2
        arr1[5] = "А"; // Если записать данные в ячейку с индексом выходящим за границы 
                       // массива, то размер массива автоматически увеличится
        delete arr1[5]; // Операция delete не удаляет элемент, а присваивает значение undefined
    
    // Длина массива  - в свойстве .length
        numb1 = arr1.length; // == 6   (текущая длина массива)
        arr1.length = 20;    // Длину массива можно изменить, записав новое значение в это свойство.
        arr1.length = 0;     // Задав нулевую длину массив можно обнулить. Равносильно arr1 = [];
        
    // Многомерные динамические массивы
        // Создание многомерного массива
        var tableSum = [  // Двухмерный массив таблица сложения
            [0,1,2],    
            [1,2,3],
            [2,3,4] ];  // Первые три элемента созданы массивами

        b = tableSum[2][2] == 4;  // Обращение к элементу многомерного массива  
                 
        // 4-мерный массив хранения пикселей движущейся голограммы размером 10x10x10
        var holo3d = [];
        for (i=0; i < 10; i++) {
            holo3d[i] = [];  // Создание двумерного массива путём добавления ячеек-массивов
            for (j=0; j < 10; j++) {
                holo3d[i][j] = []; // Создание трехмерного массива
                for (k=0; k < 10; k++) {
                    holo3d[i][j][k] = []; // Создание 4x-мерного массива
        }   }   }
        holo3d[3][1][7][2] = 80; // Запись значения в созданный 4x-мерный массив;
    
    // Методы вставки и выемки элементов динамических массивов с перестройкой индекса:
        // Реализация стека
        i = arr1.push(15); // Вставить значение 15 в конец массива. i == новая длина массива.
        k = arr1.pop();    // Вынуть последний элемент массива, возвратив его значение.
        
        // Реализация очереди. Дополнительно используются медленные операции с началом массива:
        i = arr1.unshift(15); // Вставить значение 15 в начало массива. i == новая длина массива. 
        k = arr1.shift(); // Вынуть первый элемент массива, возвратив его значение. 
        
        // Универсальный метод splice может вынимать вставлять элементы в любом месте массива
            arr1 = [0,1,2,3,4,5,6,7,8,9];
        k = arr1.splice(7); // Вынуть все элементы начиная с указанного индекса, записав их в массив
            console.log("Содержимое вынутого подмассива: " + k); // 7,8,9
        k = arr1.splice(-1); // Отрицательный индекс указывает отступ с конца массива
            console.log("Вынут последний элемент: " + k);  
            
            // Вторым аргументом можно указать количество вынимаемых элементов:
            k = arr1.splice(0,2); 
            console.log("Вынуты первые два элемента: " + k); // 0,1
            k = arr1.splice(1,0); 
            console.log("При нулевом втором аргументе возвращается пустой массив: " + k);
            
            // В третьем и последующих аргументах идут значения для вставки в исходный массив:
            arr1.splice(0,0,-2,-1,0); // Вставить без удаления начиная с позиции 0 значения -2,-1,0
            arr1.splice(1,3,7,8); // На позиции 1 удалить 3 элемента и вставить значения 7,8
            console.log("Массив arr1 после всех операций splice: " + arr1); // -2,7,8,3,4,5 
    
    /* Методы обработки групп элементов: 
            https://learn.javascript.ru/array-methods  */
    
    // Копирование участков массива в новый массив без изменения исходного массива
        arr1a = arr1.slice();  // Метод slice без аргументов копирует массив целиком
        /* Двумя аргументами  можно задать отступы, задающие границы копируемого подмассива
           Формат идентичен методу slice для строк */
        arr1a = arr1.slice(1,4); // Скопирует элементы с 1-го по 3-й включительно
        
    // Склейка массивов
        arr1b = arr1.concat(1,2,3); // В arr1b запишется массив arr1 с добавленными элементами 1,2,3
        arr1b = arr1.concat(arr2,"|",arr1a); // Аргументами могут быть присоединяемые массивы
        console.log("Склеенный массив: " + arr1b);  

    // Приведение массива к строке
        str1 = arr2.join(); // Метод join даёт строку из элементов массива, разделённых запятыми
        str1 = arr2.join(" | "); // Можно указать свою строку-разделитель
        console.log("Содержимое массива arr2: " + str1);  // undefined приводится к строке ""
        
        // При автоматическом приведении элементы массива выведутся через запятую :
        console.log("Содержимое массива arr2: " + arr2);  
        arr2[1] = ",\n";  // Запятая и прочие символы выведутся как есть:
        console.log("Букву Б заменили на запятую с переносом строки: " + arr2);  
        console.log("Таблица сложения " + tableSum); // Многомерные массивы выводятся в одну строку
    
    // Приведение строки к массиву (парсинг)
        str1 = "12345.67890";
        arr1 = str1.split(".");  // Разбивает сроку на элементы по указанной строке-разделителю
        console.log('Результат split("."): ' + arr1);  // Два элемента 12345 и 67890
        arr1 = str1.split("");  // Если раздлитель пустая строка, то разбиение будет посимвольное:
        console.log('Результат split(""): "' + arr1); // 1,2,3,4,5,.,6,7,8,9,0
        arr1 = str1.split("",4); // Вторым аргументом можно указать сколько элементов нужно спарсить
        console.log('Результат split("",4): ' + arr1); // 1,2,3,4,5,.,6,7,8,9,0
       
    // Сортировка элементов массива на месте (без создания нового массива)
        arr1 = [2,3,5,7,11,13,17,19,23];
        arr1.sort(); // Метод sort без аргументов cортирует элементы как строки.
        console.log("Простые числа отсортированы как строки: " + arr1); // == 11,13,17,19,2,23,3,5,7
        
        /* Для сортировки по другому критерию нужно указать функцию сравнения, которая возвращает 
           положительное или отрицательное число:  */
        var compareNumbs = function (a, b) {  
            return a - b;  // Вернет положительное число если a > b и отрицательное, если a < b 
        }
        arr1.sort(compareNumbs);  // Через аргумент передаётся ссылка на функцию (без скобок)
        console.log("Простые числа отсортированы как числа: " + arr1);  // == 2,3,5,7,11,13,17,19,23
    
    // Инверсия массива на месте (изменение порядка элементов на обратный)
        arr1.reverse();
        console.log("Элементы в обратном порядке: " + arr1);  // == 23,19,17,13,11,7,5,3,2
        
    /* Поиск по массиву. Метод indexOf работает аналогично методу indexOf для строк
           Можно указать вторым аргументом индекс, с которого осущетсвлять поиск. 
           Если значение не найдено, то возвращается -1 */ 
        i = arr1.indexOf(17);  // Возратит индекс n для которого arr1[n] === 17
        console.log("Значение 17 хранится в элементе с номером " + i);  // == 2
    
    /* Применение функций к элементам массива 
            https://learn.javascript.ru/array-iteration  */     
    
        // Перебор элементов массива с вызовом функции для каждого (альтернатива циклу for)
        arr1a.forEach( function(item,index,arr1a){ // 2й и 3й аргументы необязательны
            console.log("В ячейке " + index + " хранится значение " + item);
        });
        
        // Фильтрация элементов массива
        arr1a = arr1b.filter( function(item) { // Фильтрующая функция возвращает true или false
            return item > 0; // Эта функция отфильтровывает значения > 0
        });
        console.log("Положительные значения в массиве arr1b: " + arr1a); // 7,8,3,4,5,true,7,8,3
        
        /* Трансформация массива - создание нового массива, в котором к каждому 
           элементу применена указанная функция */
        arr1a = arr1.map( function(item,index,arr1) { // 2й и 3й аргументы необязательны
            return item + index;  
        });
        console.log("Сумма индекса и значения: " + arr1a); // 23,20,19,16,15,12,11,10,10
        
        // Кванторы всеобщности и существования
        var isOdd = function(n) { // Демонстрационная Функция поверки чисел на чётность
            return (n % 2) === 0;
        }
        if (! arr1.every(isOdd)) console.log("Не все числа массива arr1 чётные."); 
        if (  arr1.some(isOdd)) console.log("В массиве arr1 есть чётные числа."); 
        
        // Свёртка массива (рекурсивное применение функции к элементам с накопительным параметром).
        k = arr1.reduce( function(sum,item,index,arr1){
            return "" + sum + "|" + item; // Суммируем числа как строки.
        }, "!"); // Второй аргумент необязательный, указывает начальное значение накопителя
        console.log("Склеенные слева направо элементы массива arr1: " + k); 

        k = arr1.reduceRight( function(sum,item,index,arr1){ // То же, но справа налево
            return "" + sum + "|" + item;  
        }); // Если начальное значение не указано, то в качестве него используется начальный элемент
        console.log("Склеенные справа налево элементы массива arr1: " + k); 
        
  console.groupEnd("Динамические массивы");    
}

  {/* ОБЪЕКТЫ И ИХ СВОЙСТВА 
        https://learn.javascript.ru/object  */ 
  console.groupCollapsed("Создание объектов и хранение в них данных");

    // Создание пустого объекта
        var obj1 = new Object();
        var obj2 = {};
        
    // Копирование ссылки на объект - объекты являются ссылочным типом
        var obj3 = obj1;  // Теперь obj1 и obj3 указывают на один и тот же объект в памяти.
        
    // Сравнение ссылок на объекты    
        if (obj1 == obj3) // Проверка равенства переменных, хранящих ссылку на объект.
            console.log("Переменные obj1 и obj3 ссылаются на один и тот же объект.");
        if (!(obj1 == obj2)) // Хоть объекты одинаковы по содержанию, но ссылки на них не равны.
            console.log("Переменные obj1 и obj2 ссылаются на разные объекты.");
            
    // Проверка существования объекта
        if (typeof obj1 == "object") console.log("Объект obj1 существует");
        if (typeof obj4 == "undefined") console.log("Объект obj4 не существует"); 
    
    // Именованные свойства объектов - указываются через точку
        obj1.numb1 = 5;     // Свойство создаётся в момент присвоения
        numb2 = obj1.numb1; // Чтение свойста - аналогично чтению из переменной
        
        // Проверка существования свойств объектов
        b = obj1.numb3 === undefined;  // Обращение к несуществующему свойству даёт undefined
        obj1.numb1 = undefined; // Значение undefined может быть и у существующего свойства.
        // Поэтому надёжно проверить, существует ли свойство можно операцией in
        if ("numb1" in obj1) console.log("У объекта obj1 есть свойство numb1.");
        
        /* Удаление свойств объектов производится ключевым словом delete:
             https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/delete  */
        delete obj1.numb1; // Операция возвращает true после выполнения. В не strict режиме если 
                           // свойство не удаляется то возвращается false
        if (!("numb1" in obj1)) console.log("Свойство obj1.numb1 успешно удалено.");
    
    // Отличия переменных и свойств объектов
        i = window.numb2; // Глобальные переменные - это свойства глобального объекта (window и др.)
        window.v1 = 1;    // Cвойство объекта window можно создать напрямую 
        v1 = 2;           // и обращаться с ним как с переменной
        console.log("В свойстве v1 хранится " + v1);
        
        var v2 = 2; // Ключевое слово var задаёт флаг non-configurable. 
                    // В режиме Strict слово var нельзя опускать при создании переменных 
                    // и такие переменные нельзя удалять через delete:
            if (delete window.v1) console.log("Простое свойство объекта window можно удалить.");
            //  delete window.v2   - в режиме Strict такая операция вызовет ошибку
            
        window.obj4 = {};      // То же касается и объектов
            if (delete window.obj4) console.log("Удалён объект, созданный как свойство window.");
            //  delete window.obj1 - в режиме Strict такая операция вызовет ошибку
        window.obj4 = new Object(); // Свойство-объект можно создать и с использованием new
    
    // Работа со свойствами как с ассоциативным массивом
        obj1["numb1"] = 7; // К свойству объекта можно обращаться в виде строки, заключенной в []
        obj1["Номер факса"] = 856; // Это позволяет задавать имена свойств с пробелами
        str1 = "Дополнительный номер факса";
        obj1[str1] = 857; // или передавать их имена через переменные.
    
    // Создание объекта с групповым перечислением свойств:
        var vcard1 = { name:"Иван", age: 28, homePhone: 789, officePhone: 456 };
        var vcard2 = {  // Запись в несколько строк более наглядна
            name: "Иван",    // Эквивалент vcard1.name = "Иван"; 
            age: 28,
            phones: {        // Свойство тоже может быть объектом
                home: 789,   // Эквивалент vcard1.phones.home = 789; 
                office: 456
            }
        };
    
    // Перебор свойств объекта
        console.log("Все свойства объекта vcard1: ");
        for (var k in vcard1) {
            console.log("\t Свойство " + k + " == " + vcard1[k]);
        } // Свойства с буквенными ключами возвращаются в порядке их создания
        
        console.log("Если свойство age удалить и создать, то оно выведется последним: ");
        delete vcard1.age;  // Если свойство удалить,     
        vcard1.age   = 29;  //     а затем создать, то оно выведется последним.
        vcard1["3"]  = "А"; // Свойства с именами в виде цифр без знаков и точек, сортируются в  
        vcard1["21"] = "Б"; // порядке возрастания и идут впереди независимо от порядка их создания.
        vcard1["+1"] = "Г"; // Строка с плюсом или другими "не цифрами" не участвует в сортировке.
        vcard1[0]    = "В"; // Имя свойства можно задать числом - оно приведётся к строке.
        for (var k in vcard1) console.log("\t Свойство " + k + " == " + vcard1[k]); 
        
        // Получить имена свойств объекта в виде массива:
        arr1a = Object.keys(vcard1); 
        console.log("Все свойства объекта vcard1 в виде массива: ");
        console.log(arr1a);
        
    // Определение количества свойств можно сделать путём их перебора
        i = 0;
        for (k in vcard1) i++;
        console.log("В объекте vcard1 свойств: " + i);
        
        i = Object.keys(vcard1).length;  // либо использовать массив, возвращаемый методом keys()
        console.log("В объекте vcard1 свойств: " + i);
        
    // Создание полной независимой копии объекта (глубокое клонирование)
        var cloneObj = function f(o1){
            var o2 = {};  // Создаём новый объект o2 и копируем в него все свойства из объекта o1 
            for (var k in o1) { // Если свойство является объектом, то вызываем функцию рекурсивно
                o2[k] = (typeof o1[k] == "object") ? f(o1[k]) : o1[k];
            }
            return o2; 
        }
        
        var vcard2link = vcard2;            // Копирование ссылки на объект
        var vcard2copy = cloneObj(vcard2);  // Клонирование объекта
        
        vcard2.phones.home = 123;
        console.log("Изменение vcard2.phones.home=123 затрагивает копию ссылки, но не клон: ");
        console.log("vcard2.phones.home : " + vcard2.phones.home);          // == 123
        console.log("vcard2link.phones.home : " + vcard2link.phones.home);  // == 123
        console.log("vcard2copy.phones.home : " + vcard2copy.phones.home);  // == 789
    
    // Вывод содержимого объекта в консоль
        console.log("Содержимое объекта vcard2 : ");
        console.log(vcard2);   
        console.log("Содержимое объекта vcard2copy : " );
        console.log(vcard2copy);
        
    /* Использование свойств объекта в качестве именованных аргументов функции. Такой подход 
       позволяет не соблюдать порядок указания аргументов, а передавать их в виде одного объекта. 
       https://learn.javascript.ru/arguments-pseudoarray#imenovannye-argumenty  */
       var hello4vcard = function(vcard){
           var s = ""; 
           var phones = vcard.phones || {}; // На случай если свойство-объект не существует его 
                                            // нужно подменить пустым объектом. Иначе будет ошибка.
           if (vcard.name) s = s + "Здравствуйте, " + vcard.name + "! ";
           if (phones.home) s = s + "Ваш домашний номер: " + phones.home + ". ";
           if (phones.office) s = s + "Ваш рабочий номер: " + phones.office + ". ";
           vcard.name = "NoName"; // Осторожно! Изменение свойства изменяет глобальный объект
           return s;
       }
       console.log(hello4vcard(vcard2));
       console.log("Первый вызов функции изменил объект. Результат второго вызова:");
       console.log(hello4vcard(vcard2));
       console.log(hello4vcard({name: "Пётр"}));  // Объект можно создать на лету
       
  console.groupEnd("Создание объектов и хранение в них данных");       
  }

  {/* РАБОТА С ДАТОЙ И ВРЕМЕНЕМ (ОБЪЕКТЫ DATE)
      https://learn.javascript.ru/datetime */ 
  console.groupCollapsed("Работа с датой и временем");
    
    // Дата и время хранится в специальном объекте типа Date
    
    // Запись в переменную текущего времени и даты
    var t = new Date(); // Создать новый Date-объект. В него будет записано текущее время
    t.setTime(Date.now()); /* Записать в Date-объект текущее время. Такой вызов работает 
                              быстрее, так как не уходит время на создание нового объекта. */
    
    // Запись в переменную определённой даты и времени
        // В виде отступа в миллисекундах от 01.01.1970 00:00 
        var time1 = new Date(5 * 24 * 3600 * 1000);  // Отступ 5 суток (6 января 1970г. 00:00)
        time1.setTime(3000);  // Отступ 3 секунды (1 января 1970г. 00:00:03)
        time1.setTime(NaN);   // == Invalid Date    для некорректных значений
        time1.setTime(-3000); // Отрицательным отступом задаются даты ранее 1970 года
        console.log(time1);

        // В виде определённой даты и времени в местной временной зоне (месяцы считаются с 0 !)
            var time2 = new Date(1995,0); // 1 янв 1995 (минимум необходимо указать год и месяц)
            // Если год задан двумя цифрами то к нему прибавится 1900:
                var time2b = new Date(95,0,7); // 7 янв 1995 00:00 по местному времени
            // Можно указать время вплоть до миллисекунд:
                var time2c = new Date(2003,0,7,15,43,55,985); // 7 янв 2003 15:43:55.985   
            console.log(time2b);
        
        // Запись отдельных компонентов даты  - через соответсвующие методы:
            // по местному времени
            t.setFullYear(2017);      // 4 цифры года
            t.setFullYear(2017,0,14); // Можно дополнительно указать месяц и день месяца
            t.setMonth(0);            // Месяц (от 0 до 11)
            t.setMonth(0,14);         // Можно дополнительно указать день месяца
            t.setDate(14);            // Число месяца (от 1 до 31)
            
            t.setHours(22);           // Сколько часов по местному времени
            t.setHours(22,15,37,687); // Можно добавить минуты и секунды и миллисекунды
            t.setMinutes(15);         // Минуты. Можно добавить секунды и миллисекунды
            t.setSeconds(37);         // Секунды. Можно добавить миллисекунды  
            t.setMilliseconds(687);   // Миллисекунды
        
            // по Гринвичу
            t.setUTCFullYear(2017,0,14); 
            t.setUTCMonth(0,14);         
            t.setUTCDate(14);            
            t.setUTCHours(22,15,37,687);  // Время в Лондоне
            t.setUTCMinutes(15);         
            t.setUTCSeconds(37);         
            t.setUTCMilliseconds(687);   
            
            /* Если значение выходит допустимый диаппазон, то разница между значением и допустимой 
               границей задаёт сдвиг, на который нужно увеличить или уменьшить дату */
            t.setMonth(-2); // Установить на 2 месяца раньше января (т.е. ноябрь предыдущего года)
            t.setDate(33); // Установить на 33 суток позже от начала месяца (2-4 число след.месяца)
            
    // Чтение отдельных компонентов даты и времени:
        // по местному времени        // по Гринвичу
        i = t.getFullYear();          i = t.getUTCFullYear(); 
        i = t.getMonth();             i = t.getUTCMonth();    
        i = t.getDate();              i = t.getUTCDate();     
        i = t.getDay();               i = t.getUTCDay();      
        i = t.getHours();             i = t.getUTCHours();  
        i = t.getMinutes();           i = t.getUTCMinutes();
        i = t.getSeconds();           i = t.getUTCSeconds();
        i = t.getMilliseconds();      i = t.getUTCMilliseconds();
            
    // Приведение даты к числу - даёт значение в миллисекундах
        i = t.valueOf();    // Явное преобразование
        i = time2 - time1;  // Неявное преобразование при  математических операциях
        console.log("Вычитание двух дат даёт результат " + i); // Число миллисикунд
        i = time2 + time1;  // Но операция сложения производит конкатенацию дат как строк!
        console.log("Сложение двух дат даёт результат " + i);  // Строка из букв и цифр
        
    // Средства для бенчмаркинга
        
        // Функция console.time() запускает таймер идентифицируемый строковой меткой
        console.time('Вычисление 10 тыс. раз факториалов от 0 до 10 функцией 1');
            for (i=1; i<10000; i++) for (j=1; j<10; j++) k = factorial(j);
        // Функция console.timeEnd() выводит значение таймера с указанной меткой
        console.timeEnd('Вычисление 10 тыс. раз факториалов от 0 до 10 функцией 1');
        console.time('Вычисление 10 тыс. раз факториалов от 0 до 10 функцией 2');
            for (i=1; i<10000; i++) for (j=1; j<10; j++) k = factorial2(j);
        console.timeEnd('Вычисление 100 тыс. раз факториалов от 0 до 10 функцией 2');
         
        /* Если в браузере не задействовано округление таймера с целью защиты от атак, то функция 
           performance.now() возвращает значение вплоть до микросекунд. Не работает в движке Presto. 
        */
        try {
            j = performance.now(); // Количество миллисекунд с момента первого обращения к серверу
            for (i=1; i<1000000; i++) k = Math.sqrt(i);
            k = performance.now() - j;
            console.log('Миллион квадратных корней вычислено за ' + k + ' миллисекунд.'); 
        } catch(e) { // Данные об ошибке можно посмотреть в возвращённом объекте e
            console.log('Ошибка пуска performance ' + e.name + ": " + e.message + "\n" + e.stack); 
        }
        
    // Приведение даты к строке    
        str1 = t.toString();
        console.log("Полная дата по местному времени в строковом виде: " + str1);
        str1 = t.toDateString();
        console.log("Дата по местному времени в строковом виде: " + str1);
        str1 = t.toTimeString();
        console.log("Время по местному времени в строковом виде: " + str1);
        str1 = t.toUTCString();
        console.log("Полная дата по Гринвичу в строковом виде: " + str1);
        str1 = t.toISOString();
        console.log("Полная дата в строковом виде в формате ISO: " + str1);
        
        /* пользовательское форматирование
            https://learn.javascript.ru/intl#intl-datetimeformat    */
        str1 = t.toLocaleString("ru"); // Первый аргумент задает локаль
        console.log("Форматированная дата с настройками по умолчанию: " + str1);
        
        var dateOptions = { // Вторым аргументом через объект можно задать компоненты и настройки
            year: 'numeric',  // Варианты значения: 2-digit, numeric
            month: 'long',    // Варианты: 2-digit, numeric, narrow, short, long
            day: 'numeric',
            weekday: 'long',  // Варианты: narrow, short, long
            hour: 'numeric',
            minute: 'numeric',
            timeZone: 'UTC',   
            timeZoneName: 'long'  // Варианты: short, long
        };
        str1 = t.toLocaleString("ru",dateOptions);
        console.log("Форматированная дата с пользовательскими настройками: " + str1);  

    // Приведение строки к дате
        // Функция Date.parse() возвращает миллисекунды или NaN
        i = Date.parse('2018-12'); // Год и месяц 
        i = Date.parse('2016-12-02T22:15:37.687Z'); // Точное время по Гринвичу
        i = Date.parse('2016-12-02T22:15:37.687+05:00'); // Точное время в часовом поясе +05GMT
        t.setTime(i); // Записать миллисекунды в Date-объект
        
  console.groupEnd("Работа с датой и временем");
  }

  {/* БИНАРНЫE-ОБЪЕКТЫ
      https://learn.javascript.ru/blob 
	  BLOB (Binary Large Object) - объект хранящий бинарные данные какого-то типа. Чаще всего это 
	  данные MIME-типа (Multipurpose Internet Mail Extensions). */
	  console.groupCollapsed("Бинарные объекты");

	  /* Новый бинарный-объект создается конструкцией new blob() и в качестве аргумента передается
	     массив бинарных объектов */
	  var blob1 = new Blob(["Текстовые данные1"," + дополнение."]);
	  console.log("blob1: ", blob1);
	  
	  /* Вторым аргументом указывается объекта с опциями объекта. 
	     Чаще всего в опции type указывается MIME-тип бинарного объекта. */
	  var blob2 = new Blob(["<html>Текст html-страницы</html>"], {type: 'text/html'});
	  console.log("blob2: ", blob2);
	  
	  // При создании blob можно использовать существующий бинарный массив:
	  var encoder2 = new TextEncoder();  var textArray2 = encoder2.encode("Text 2"); 
	  var blob3 = new Blob([textArray2, " + addon"], {type: 'text/plain'});
	  
	  /* Метод URL.createObjectURL() создаёт уникальный адрес в оперативной памяти, по которому 
	     можно объект открыть или скачать как файл.*/
	  var url1 = URL.createObjectURL(blob3);
	  console.log('URL для скачивания объекта blob3: ' + url1);
	  
	  /* Если объект уже не нужен, и его нужно удалить из оперативной памяти, то прежде потребуется 
	     удалить и ссылку на него. Сделать это можно методом URL.revokeObjectURL()  */
	  if(0) { URL.revokeObjectURL(url1); }   
	  console.groupEnd("Бинарные объекты");

  }

  {/* ФУНКЦИИ-ОБЪЕКТЫ */ 
  console.groupCollapsed("Функции как объекты");

    /* Функция как объект со свойствами  
        https://learn.javascript.ru/closures#svoystva-funktsii  */
        var c1 = function counter(){
            if (counter.v) counter.v++; else counter.v = 1;
            return counter.v;
        }
        c1(); c1(); c1(); c1(); i = c1();
        console.log('Функция c1 была выполнена ' + i + ' раз.');
        c1.v = 40; i = c1();  // Свойство можно изменять снаружи функции
        console.log('После принудительного изменения свойства счетчик поменялся на ' + i);

    /* Вложенные функции 
        https://learn.javascript.ru/closures#vlozhennye-funktsii */
        
        var decoString = function(str) {
            function deco(c,n) { // Подфункция декорирования строки по краям другой строкой
                function mul(ord){  // Функция повторения декорируемой строки
                   var s = ""; for (var i=1;i<=n;i++) s += c;  
                   s = ord ? s : s.split("").reverse().join("");  // Разворот строки для ord == 0
                   return s;
                }
                return(mul(1) + str + mul(0)); // Переменная внешней функции доступна и внутри
            }
            return deco("*-",3);
        }
        str1 = decoString("декорируемая строка");
        console.log("Результат работы вложенных функций: " + str1);
    
    /* Возврат вложенной функции с созданием замыкания
        https://learn.javascript.ru/closures#vozvrat-funktsii  */
        
        /* Каждая функция при запуске создаёт спец.объект LexicalEnvironment, в который копируются 
        аргументы, функции и переменные функции. А при создании функции присваивается специальное 
        недоступное свойство [[Scope]], которое указывает на LexicalEnvironment текущей функции. 
        При обращении к переменной функция ищет её сначала в своём LexicalEnvironment, а затем в
        LexicalEnvironments, находящихся по цепочке ссылок [[Scope]] - вплоть до объекта Window. */
        var makeCounter = function() {  // Функция подсчитывающая количество своих запусков
            var currentCount = 1; // Счетчик - локальная переменная главной функции
            return function() { /* Возвращается вложенная функция хранящая используемое ею 
                                лексическое окружение (в данном случае - переменную currentCount) */  
                return currentCount++;  // Вложенная функция при вызове возвратит 
            };                          //   значение счетчика и увеличит его
        }
        var c1 = makeCounter();     /* Запуск функции возвращающей функцию создаёт и хранит 
                                       лексическое окружение для c1() */
        c1(); c1(); c1(); i = c1(); // Каждый вызов увеличивает счётчик и возвращает результат
        var c2 = makeCounter();     // Новый созданный счётчик будет независим от первого т.к.
        c2(); c2(); j = c2();       // у него собственный объект LexicalEnvironment
        console.log("Функции c1() и с2() запускались " + i + " и " + j + " раза.");
        
    // Видимость внешних переменных у вложенных функций разных видов
    
        /* У функциональных выражений, созданных через new Function, [[Scope]]ссылается не на 
           породившее функцию лексическое окружение, а на глобальный объект window 
           https://learn.javascript.ru/scope-new-function  */
        str1 = "глобальная переменная, хранящаяся в объекте window";
        var lexEnvTest = function() {
            var str1 = "локальная переменная функции lexEnvTest";
            function func1() { return str1; }  // Обычная функция 
            var func2 = new Function('', 'return str1;'); // Функц.выражение new                              
            // Простая функция ищет переменную сначала в LexicalEnvironment одним уровнем выше
            console.log("Вложенная функция func1() видит, что str1 - " + func1()); // локальная
            /* Функциональное выражение созданное через new ищет переменную сразу на самом верхнем 
               уровне - в объекте window */
            console.log("Вложенная функция func2() видит, что str1 - " + func2()); // глобальная
        }
        lexEnvTest();
    
    /* Возврат нескольких вложенных функций, обернутых в объект
        https://learn.javascript.ru/closures-usage  */
        var makePair = function(a, b){
            return {  // Возвращаем объект
                plus:  function(){ return a+b; },
                minus: function(){ return a-b; },
                multi: function(){ return a*b; },
                div:   function(){ return a/b; }
        }}
        var p = makePair(7,8); // Создано замыкание - в лексическом окружении хранятся два числа.
        i = p.multi(); // == 56  Метод .multi() объекта p произвел умножение хранящихся чисел.
    
    // Возврат функции-объекта, свойствами которого являются функции-методы
       var makeTimer = function(){ // Создаём простой секундомер для замеров времени
            var startTime = Date.now(); // Переменная будет хранить время начала отсчета
            function timer(){ // Вложенная функция возвращает текущее значение секундомера
                return Date.now() - startTime; 
            }
            timer.reset = function(){ // Метод .reset() "обнуляет" секундомер
                startTime = Date.now(); 
            }
            return timer; // Возвращаем вложенную функцию с целью создания замыкания
        }
        var t = makeTimer(); // Создан объект-функция, которую удобно вызывать как функцию t();
        for (i=1; i<1000000; i++) k = Math.sqrt(i);  
        console.log('Миллион квадратных корней вычислено за ' + t() + ' миллисекунд.');
        t.reset();
        console.log('Значение таймера после обнуления: ' + t() + ' миллисекунд.');
    
  console.groupEnd("Функции как объекты");
  }

  console.groupEnd("Составные структуры данных");
}

{/* ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ */  
console.groupCollapsed("Объектно-ориентированное программирование");

  {/* Методы объектов (Методом называется функция, являющаяся свойством объекта)
    https://learn.javascript.ru/object-methods  */
console.groupCollapsed("Методы объектов");
    
    // Объявление метода внутри объекта:
        obj1 = { 
            comment: 'Объект содержит комментарий и функцию вывода приветсвия.',
            showHello: function() { console.log('Привет от метода !'); }
        };
        
    // Вызов метода    
        obj1.showHello();    // Вывод сообщения в консоль
        obj1["showHello"](); // Альтернативная запись
    
    // Добавление и удаление методов:
        obj1.showHello2 = function() { console.log('Привет от другого метода !'); };
        obj1.showHello2();
        delete obj1.showHello2;
    
    // Доступ к свойствам текущего объекта из метода:
        // Ключевое слово this указывает на объект, в контексте которого вызван метод
        obj1.showComment = function() { console.log(this.comment); };
        obj1.comment = 'Теперь объект содержит комментарий и две функции.';
        obj1.showComment();
        
        // Функцию использующую this можно создавать без привязки к объекту
        var printObj = function() {console.log(this);} // Функция вывода текущего объекта в консоль
        obj1.print = printObj; // Если эту функцию записать в свойство, то она станет методом 
        obj1.print(); // Метод выведет все содержимое объекта в консоль
        console.log("Если функцию вызвать вне объекта то указатель this в ней - undefined: ");
        printObj(); // undefined
console.groupEnd("Методы объектов");
}

  {/* Преобразование объектов к примитивным типам
    https://learn.javascript.ru/object-conversion  */
console.groupCollapsed("Преобразование объектов к примитивным типам");
    
    // Строковое преобразование (производится там где ожидается получение строки)
        
        // Если в объекте нет метода toString() то интерпретатор возвращает "[object Object]".
        console.log("Простой объект при приведении к строке даёт " + {}); // "[object Object]"
        
        // Можно создать свой метод toString()
        var pixel1 = { 
            x: 3, y: 4, 
            toString: function() { 
                return "Координаты точки: " + this.x + " и " + this.y;
        }}
        console.log("Объект pixel1 при строковом преобразовании возвращает строку: " + pixel1);
        
        pixel1.toString = function() { 
                return this.x + this.y;  // Метод может возвращать в т.ч. число или boolean
        }
        console.log("А теперь объект pixel1 возвращает число " + pixel1);

    /* Приведение типа объекта к строке
            https://learn.javascript.ru/class-instanceof  */
        
        // Для ключевого слова typeof справедливы следущие равенства 
            b = typeof null === "object" && // true    (такова особенность JS)
                typeof {}   === "object" && 
                typeof []   === "object" &&
                typeof new Date   === "object";    
        
        // Стандартный метод .tosring возвращает разные строки для объектов, массивов и дат:
            var objType = {}.toString; // Скопируем этот метод в функцию 
            str1 = objType.call({}) +       // "[object Object]"
                   objType.call([]) +       // "[object Array]"
                   objType.call(new Date) + // "[object Date]"
                   objType.call(null);   // "[object Null]" 
            console.log("Три типа встроенных объектов: " + str1);
        
    // Численное преобразование (производится там где ожидается получение числа)
        
        // Если у объекта нет встроенных методов преобразования, то объект преобразуется к NaN
        b = + {} === NaN; // true
        
        // Если в объекте есть метод valueOf() то в первую очередь используется он:
        var phones1 = { home: 89001234567, work: 88004567890, // В объекте - номера телефонов
            valueOf: function() { return this.work; } // Возвращаем рабочий номер телефона
        }
        b = + phones1 === 88004567890; // true потому что phones1.valueOf() == 88004567890
        
        // При отсутствии метода valueOf() используется метод toString() (если он есть)
        pixel1.x = 5; pixel1.y = 7;
        b = + pixel1 === 12; // true  -  pixel1.toString() == 5 + 7 == 12
        
        /* При сложении объектов со строками в приоритете метод valueOf() (кроме Date-объектов, 
           которые при любом сложении используют метод toString())  */
        console.log("Cложение строки и объекта pixel1 использует valueOf(): " + pixel1);
        console.log("Сложение строки и Date-объекта использует toString(): " + time1);
        
    // Логическое преобразование (производится там где ожидается получение boolean) 
    
        b = !! {} === true;  // Любой объект при явном логическом преобразовании даёт true
        
        // При нестрогих сравнениях с boolean объект преобразуется к числу, а затем сравнивается 
        phones1.work = 0;
        if (phones1 == false)  console.log("Объект phones1 == false, т.к. 0 == false");  
        if (phones1 !== false) console.log("Объект phones1 !== false, т.к. 0 !== false");
        
        // Специальный метод Array.isArray() позволяет проверить, является ли аргумент массивом:
        if ( Array.isArray(arr1) ) console.log("Результат проверки: arr1 является массивом"); 
    
console.groupEnd("Преобразование объектов к примитивным типам");
}

  {/* Сериализация объектов (в формат JSON)
        Эта операция необходима для сохранения всей структуры объекта в виде одной строки текста.
        https://learn.javascript.ru/json  */
  console.groupCollapsed("Сериализация объектов (в формат JSON)");
    
    // Простая сериализация объекта "как есть":
        str1 = JSON.stringify(vcard2); // Метод JSON.stringify преобразует объект в JSON
        console.log("Объект vcard1 в формате JSON: " + str1);
        vcard2 = JSON.parse(str1); // Обратная операция - считывание объекта из JSON
        
    // Выборочная сериализация (вторым аргументом можно указать массив с именами нужных свойств):
        str1 = JSON.stringify(vcard2,["name", "age"]); 
        console.log("Избранные свойства объекта vcard1 в формате JSON: " + str1);
        
    /* Использование прокси-функции для нестандартной сериализации (во втором аргументе метода).
       Функция применяется рекурсивно в т.ч. для всех вложенных свойств. */
        str1 = JSON.stringify(vcard2, function(key, value) { 
            // В функцию передаются имя и значение свойства, а функция должна возратить:
            if (key == 'age') return value + " лет"; // либо значение в сериализованном виде,
            if (key == 'phones') return undefined; // либо undefined если свойство нужно исключить,
            return value; // либо значение как есть (т.е. как если бы функции вообще не было).
        }); 
        console.log("Объект vcard1 преобразованный в JSON с применением функции: " + str1);
        
        // Для обратного преобразования точно также можно использовать функцию:
        var vcard2b = JSON.parse(str1,function(key, value) { 
            if (key == 'age') return parseInt(value); // Преобразует строку "28 лет" в число 28
            return value; 
        }); 
        
    // Полное переопределение сериализирующего метода .toJSON
        vcard2b.toJSON = function() {
            return this.name + " - " + this.age + " лет";
        };
        str1 = JSON.stringify(vcard2b); 
        console.log("Объект vcard1 сериализован переопределённым методом toJSON: " + str1);
    
  console.groupEnd("Сериализация объектов (в формат JSON)");
  }
  
  {/* Конструкторы объектов (функции создающие новые функции-объекты)
    https://learn.javascript.ru/constructor-new  */
console.groupCollapsed("Конструкторы объектов");
    
    // Конструктором становится любая функция, вызванная с ключевым словом new
    var emptyFunc = function() {};
    var f1 = new emptyFunc();  // Создан пустой объект на основе пустой функции
    
    // Изменение свойств создаваемых объектов в конструкторе
    var NulPixel = function(){  // Имена функций-конструкторов принято называть с большой буквы
        this.x = 0; // this указывает на создаваемый конструктором объект
        this.y = 0;
        this.area = function() { return this.x * this.y; };  // Можно задать метод 
    }
    pixel1 = new NulPixel();  // Создан объект { x: 0, y: 0 }
    pixel1.x = 342; pixel1.y = 453; 
    console.log("Площадь экрана от угла до пикселя {342,453}: " + pixel1.area() + " пикселей");
    
    // Передача аргументов в конструкор 
    var Pixel = function(x, y){ 
        this.x = x; 
        this.y = y;
    }
    pixel1 = new Pixel(3,4);  // Создан объект { x: 3, y: 4 }
    
    // Анонимный конструктор (может создать единичный объект проведя необходимые вычисления)
    pixel1 = new function(){ var k=0;
        for (var i=1;i<10;i++) k += Math.sqrt(i);
        this.x = k; 
        this.y = Math.round(k*2);
    };

    /* Комбинированные функции-конструкторы (могут как конструировать объекты, так и 
       возвращать вместо сконструированного объекта другой объект или массив) 
           https://learn.javascript.ru/constructor-new#pravila-obrabotki-return  */
    
    var CombyReturn = function(type){
        this.comment = "Сконструирован новый объект";
        switch(type) { 
            // Простые типы возвращать нельзя.  Вместо них вернется новый объект this
            case "string" :  return "Простая строка"; // Этот return проигнорируется
            case "number" :  return 123;              // Этот return проигнорируется  
            case "bool"   :  return true;             // Этот return проигнорируется 
            case "array"  :  return [1,2,3];  // Возврат массива и прочих объектов сработает
            case "object" :  return {p1:1, p2:2, p3:3}; 
            case "function" :  return function(x) { console.log(x); }; 
        }                       
    }
    console.log("Комбинированная функция-конструктор не умеет возвращать простые типы:");
    console.log(new CombyReturn("string"));
    console.log(new CombyReturn("number"));
    console.log(new CombyReturn("bool"));
    console.log("Но умеет возвращать вместо объекта this другой объект, массив или функцию:");
    console.log(new CombyReturn("object"));
    console.log(new CombyReturn("array"));
    console.log(new CombyReturn("function"));
console.groupEnd("Конструкторы объектов");
}

  {/* Дескрипторы свойств (объект хранящий значение, параметры, геттеры и сеттеры свойства)
    https://learn.javascript.ru/descriptors-getters-setters  */
console.groupCollapsed("Дескрипторы свойств");

    /* Запись значения свойства в дескриптор (используется метод Object.defineProperty() 
       с тремя аргументами: целевой объект, имя свойства и объект-дескриптор свойства ) */
        // Свойство value дескриптора хранит значение:
        Object.defineProperty(pixel1, "x", { value: 320 }); // То же, что pixel1.x = 532
        Object.defineProperty(pixel1, "z", { value: 0 });   // Можно задать новое свойство
    
    // Запрет изменения или удаления свойства
        Object.defineProperty(pixel1, "z", { 
            writable: false,     // запрет записи
            сonfigurable: false  // запрет удаления через delete
        }); // Можно задать новое свойство
        
    // Невидимость свойства для цикла for...in
        Object.defineProperty(pixel1, "z", { enumerable: false }); 
        console.log("Все свойства объекта pixel1 кроме невидимого свойства z: "); 
        for (var k in pixel1) console.log(k); 
    
    /* Геттеры и сеттеры (привязанные к свойству функции, которые выполняются при операциях чтения
        или записи в свойство) */
        Object.defineProperty(pixel1, "area", {
           get: function() {   // Функция, возвращающая значение свойства .area
               return this.x * this.y;
           },
           set: function(a) {   // Функция, срабатывающая при записи в свойство .area
               this.y = a / this.x;
           }
        });
        console.log("Площадь экрана от угла до pixel1: " + pixel1.area + " пикселей");
        console.log("Координата pixel1.y равна " + pixel1.y);
        pixel1.area = 76800;  // Это присвоение изменяет значение pixel1.y   
        console.log("Координата pixel1.y теперь равна " + pixel1.y); 
    
    /* Обработка нескольких дескрипторов (через метод Object.defineProperties() с двумя 
       аргументами - указатель на изменяемый объект  и объект из дескрипторов) */

        Object.defineProperties(pixel1, { 
            x: { value: 240 },
            y: { configurable: false } /* Смена true на false сработает, но не наоборот:
            z: { configurable: true }  // не сработает, т.к. свойство не configurable. */
        }); // Для изменения false на true нужно использовать Object.defineProperty()
    
    // Получение списка свойств объекта через специальный метод
        console.log("Видимые свойства объекта pixel1: ");
        console.log(Object.keys(pixel1));
        console.log("Все свойства объекта pixel1: ");
        console.log(Object.getOwnPropertyNames(pixel1));
    
    // Копирование дескриптора в новый объект (для манипуляций с ним)
        var descr1 = Object.getOwnPropertyDescriptor(pixel1, 'x'); // Скопировано в descr1
        descr1.writable = false;    // Изменяем содержимое нового дескриптора
        delete descr1.enumerable;  // При этом можно удалять его составляющие
        delete pixel1.x; // Чтобы новый дескриптор не объединился со старым, свойство
                         // нужно полностью удалить. Тогда удалится старый дескриптор.
        Object.defineProperty(pixel1, 'x', descr1); // Применяем новый дескриптор 
        console.log("Видимые свойства объекта pixel1 (свойство x теперь невидимо): ");
        console.log(Object.keys(pixel1)); 

    // Применение групповых политик к дескриптору (задают степень модифицируемости объекта):
        Object.preventExtensions(pixel1); // Запрет расширения объекта новыми свойствами
        Object.seal(pixel1);   // Опечатывает набор свойств, но позволет менять их значения 
        Object.freeze(pixel1); // Замораживает все свойства вместе с их значениями
    
    // Проверка соответствия дескриптора групповым политикам:
        if (! Object.isExtensible(pixel1)) console.log("Объект не расширяемый."); 
        if (Object.isSealed(pixel1)) console.log("Объект опечатан.");
        if (Object.isFrozen(pixel1)) console.log("Объект заморожен.");
        
console.groupEnd("Дескрипторы свойств");
}    

  {/* Шаблоны применения функций к объектам */  
  console.groupCollapsed("Статические и фабричные методы консрукторов");
    
    /* Статические свойства и методы - те, которые не привязаны к экземплярам объектов
        https://learn.javascript.ru/static-properties-and-methods */
    
        var PixelStat = function(){ // Конструктор пикселей, который считает сколько пикселей создал
            if (PixelStat.count == undefined) PixelStat.count = 0; // Статическое свойство .count, 
                else PixelStat.count++; // в котором накапливается количество созданных пикселей
        }
        PixelStat.showCount = function(){  // Статический метод для вывода в консоль статистики
            console.log("Создано " + this.count + " пикселей.");
        };
        for (i=1;i<99;i++) { new PixelStat(); } // Создадим пачку пикселей
        PixelStat.showCount();                  // Вывод в консоль их количества
    
    /* Фабричные методы - занимаются созданием новых объектов. Их преимущество в том, что 
       не применяется this, а значит нет риска потери контекста */
        PixelStat.CreateNull = function(){  // Фабричный метод создания нулевого пикселя
            var p = new PixelStat; // Создаем новый пиксель
            p.x = p.y = 0;         // с нулевыми координатами
            return p;
        }
        var pixel1 = PixelStat.CreateNull(); 
        console.log("Создан новый пиксель с координатами " + pixel1.x + " и " + pixel1.y);
        
        PixelStat.Create = function(a,b){ // Создание пикселя с указанными координатами
            var p = new PixelStat; 
            p.x = a; p.y = b;      
            return p;
        }   
        var pixel1 = PixelStat.Create(300,400); 
        console.log("Создан новый пиксель с координатами " + pixel1.x + " и " + pixel1.y);
    
    // Независимая функция работы с объектом (объявленная вне конструктора или объекта)
        var distance = function(){  // Сторонний метод вычисления расстояния от угла экрана до пикселя
            return Math.sqrt( Math.pow(this.x,2) + Math.pow(this.y,2) );
        };  // Эту функцию можно вызвать разными вариантами:
        
    // Вызов сторонней функции через копирование в свойство объекта (изменяет объект)
        pixel1.dist = distance; 
        k = pixel1.dist(); // == 500
        console.log("Расстояние от угла экрана до pixel1: " + k );
    
    // Явное указание другого контекста при вызове функции (встроенными методами call и apply):
        distance.call(pixel1); // == 500  Контест вызова - объект pixel1
        // Если через запятую задать аргументы, то они передадутся в функцию:
        distance.call(pixel1,1,2,3,4); // == 500
        // Аналогичным методом apply можно передать массив аргументов:
        distance.apply(pixel1,[1,2,3,4]); // == 500 
    
    // Создание постоянной привязки функции к указанному контексту (через метод bind)
        var pixDist = distance.bind(pixel1);
        pixDist(); // == 500
        pixel1.x = 3; pixel1.y = 4;  // Изменение объекта влияет на привязанную функцию:
        k = pixDist(); // == 5    
        k = pixDist.call({x:1,y:1}); // == 5  Замена this с помощью call теперь не работает
            // https://ru.stackoverflow.com/questions/535030/Потеря-контекста-вызова
        console.log("Расстояние от угла экрана до pix: " + k );     
    
    // Фиксирование аргументов, передываемых в функцию
        var pixDist2 = distance.bind(pixel1,1,2);  
        b = pixDist2("a","b") == pixDist(1,2,"a","b"); // true
        // Если контекст null или undefined, то привязываются только аргументы:
        var pixDist3 = distance.bind(null,1,2);  
    
    // Каррирование функций (создание производных функций с меньшим количеством аргументов)
        var mul = function(a, b) { return a * b; };  // Функция умножения от двух аргументов
        var double = mul.bind(null, 2); // Функция умножения на 2 с одним аргуменом:
        k = double(5); // == mul(2, 5) == 10
    
    /* Функция-обёртка или декоратор (функция которая принимает на вход  функцию 
       и возвращает её, снабдив новыми возможностями)  
            https://learn.javascript.ru/js-misc  */
        
        var numCheck = function(f) { // Функция проверки, являются ли аргументы функции числами
            return function() {
                for (var i = 0; i < arguments.length; i++) {
                    if (isNaN(parseFloat(arguments[i]))) { // Проверка: аргумент - не число?
                        console.log( "Некорректный тип аргумента номер " + i + ": " + arguments[i]);
                    return;
                }}
                return f.apply(this, arguments);
        }}
        
        var sqrtN = numCheck(Math.sqrt); // Оборачиваем функцию в декоратор
        i = sqrtN(4);     // Этот вызов сработает без ошибок
        j = sqrtN("abc"); // Этот вызов выведет предупреждение в консоль
        console.log("Корни квадратные для аргументов: " + i + " и " + j); // 2 и undefined
    
  console.groupEnd("Статические и фабричные методы консрукторов");
  }    

console.groupEnd("Объектно-ориентированное программирование");
}




















