//  Однострочный комментарий до конца строки задается двумя косыми чертами в начале комментария
/*  Многострочный комментарий - обрамляется парой символов "/" и "*" 
    В начале комментария символы идут в прямом порядке, а в конце - в обратном.
        https://learn.javascript.ru/structure#kommentarii
*/

/*  ОБЩИЕ СИНТАКСИЧЕСКИЕ ПРАВИЛА
    Команды в JS разделяются символом точки с запятой ";"
    Если символ ";" пропущен, но есть перевод строки, то интерпретатор может его автоматически вставить, но надеяться на это не стоит.
        https://learn.javascript.ru/structure#komandy
    Блок операторов выделяется фигурными скобками {}
    Отключить выполнение кода можно поместив его внутрь блока if(0){  }
*/
if(0){ "Невыполнящийся код" } // В коде не должно быть ошибок. Для включения нужно 0 заменить на 1.

"use strict"; /* Эта директива переводит интерпретатор в режим стандарта ES5, лишенного недостатков старого стандарта. 
                 При этом теряется совместимость с IE9- и скриптами, написанными в старом стандарте
                    https://learn.javascript.ru/strict-mode */

{/*  КОМАНДЫ ВЗАИМОДЕЙСТВИЯ С ПОЛЬЗОВАТЕЛЕМ 
         https://learn.javascript.ru/uibasic
*/  
    // Вывод текстовых строк
        console.log('Hello World!');  // В консоль с переносом строки
        console.group("Некая группа строк 1");  // Объявление начала группы строк в консоли
            console.groupCollapsed("Свернутая группа строк 2"); // Объявление свернутой группы строк, к тому же внутри первой группы
            console.groupEnd("Свернутая группа строк 2"); // Объявление конца группы строк
        console.groupEnd("Некая группа строк 1"); 

    if(0){  // Демонстрация всплывающих окон (отключена)
        alert('Hello world!');        // В модальное веб-окно с ожиданием реакции пользователя
        document.write('Hello world!');  // В текущее место веб-страницы (после закрывающего тега </script>). Если скрипт выполнится не в процессе, а после загрузки HTML-страницы то страница будет стерта и начата новая. 

    // Запрос пользователю ввести строку, которая будет сохранена в переменной inputStr
        var inputStr = prompt('Введите строку:', 'Текст по умолчанию'); 
    // Запрос пользователю ответить Да/Нет. Результат ответа будет сохранен в логическую переменную inputBool.    
        var inputBool = confirm("Вы подтверждаете запрос?"); 
    }
    // Пауза на 3 секунды. Будет отложено выполнение только блока операторов функции func(). Загрузка страницы и остальные скрипты на странице продолжат своё выполнение.
        function func() { 
            console.log('Прошло 3 секунды.'); 
        }
        setTimeout(func, 3000);
}

{/* РАБОТА С ПЕРЕМЕННЫМИ   
        https://learn.javascript.ru/variables
    Имя переменной не должно начинаться с цифры и может состоять из букв, цифр, символов $ и _ 
    Регистр имеет значение.
*/
console.groupCollapsed("Переменные"); // Объявление начала свёрнутой группы строк

    // Объявление и инициализация переменных
        var str1; /* Новая переменная объявляется с помощью ключевого слова var. Это можно делать в любом месте кода.
                        https://learn.javascript.ru/variables#vazhnost-direktivy-var */
        var numb1 = 546; // При объявлении переменной можно сразу инициализировать её значение.
        var str2, b, i, j, numb2, numb3 = 123;  // Можно объявить несколько переменных через запятую.
        numb3 = "Строка"; // Тип переменной не фиксирован и в любую переменную может быть записаны данные любого типа
        var NUMBER_PI = 3.14;  // В JS нет констант, поэтому принято вместо констант использовать переменные названные прописными буквами и просто не менять их значения в дальнейшем.
    
        //  Простые типы данных в JS      https://learn.javascript.ru/types-intro
        numb2 = 456;      // Для чисел существует стандартный тип - 64-битный с плавающей точкой (стандарт IEEE-754)
        numb2 = 789;      // Проинициализированную переменную можно заменить новым значением.
        numb1 = 123.789;  // Для задания вещественного числа используется разделитель - точка
        numb1 = 3.2e5;    // = 320000   Запись в научном формате. После символа "e" задаётся сдвиг запятой вправо для десятичного числа
        numb1 = 3.2e-5;   // = 0.000032 Отрицательное число сдвигает запятую влево, задавая десятичную дробь
        numb2 = Infinity; // Спец.значение "бесконечность" используется в случае деления на ноль или превышения максимального значения для числа
        numb3 = NaN;      // Спец.зачение "Not a Number" используется для обозначения ошибки вычислений
        
        // Задание целых 32-битных чисел в других системах счисления 
        numb2 = 0xF0; // Шестнадцатиричное число начинается с 0x
        numb2 = 070;  // Восьмиричное число начинается с 0
        
            // Также можно использовать функцию parseInt() задав строку с числом и основание (от 2 до 36)
            // http://javascript.ru/ParseInt
        numb2 = parseInt("F57", 16);      // Шестнадцатиричное число
        numb2 = parseInt("4651", 8);      // Восьмиричное число
        numb2 = parseInt("10011110", 2);  // Двоичное число
        numb2 = parseInt("-10011110", 2); // Знаком минус можно задать отрицательное значение
        numb2 = parseInt("14fdnv5z", 36); // Закодированный буквами номер телефона 88001234567  
        
        var bool1 = true;   // Логический тип "истина"
            bool1 = false;  // и "ложь"
    
        str1 = "Тестовая строка";       // Строки задаются двойными или одинарыми кавычками
        str1 = 'Тестовые "кавычки"';    // Для использования в строке двойных кавычек можно обрамлять её в одинарные кавычки
        str1 = "Тестовые \"кавычки\"";  // либо использовать экранирующий символ  "\"
        str1 = " \\ ";                  // Для сохранения экранирующего символа его нужно написать дважды 
        str1 = "Первая строка\nВторая строка"; // Перенос строки: \n
        str1 = "\t \r \b \f"; // Символы  Tab | carriage Return | Backspace | Form feed (новая страница)
        str1 = "\u005A";      // Символ в кодировке Unicode
        
        str2 = null;        // Специальный тип означающий "неизвестное значение"
        str1 = undefined;   // Специальный тип означающий "переменная неинициализирована". 
        
        /* Для проверки типа переменной можно применить оператор typeof, который возвращает такие значения:
            "number", "string", "boolean", "undefined", "object" */
        str1 = typeof str2; // Для переменных типа null оператор возвращает значение "object"

    // Использование переменных
        // Проверка, является ли переменная инициализированной. Работает независимо от того, объявлена ли переменная.
        if (typeof newVar == "undefined") { 
            console.log('Переменная newVar не инициализирована') 
        };
        console.log(str1); // Вывод значения переменной в консоль
        
        numb2 = numb1; // Запись значения переменной в другую переменную.
        numb2 = numb2 / numb1; // В выражениях для присвоения нового значения можно использовать эту же переменную, пока в ней хранится старое значение.
console.groupEnd("Переменные");
} 

{/* ОПЕРАЦИИ
       https://learn.javascript.ru/operators
       https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence */
console.groupCollapsed("Операции");       

    numb1 = numb2 = 5;         // Оператор присваивания тоже возвращает значение, которое можно использовать в предыдущем операторе присваивания
    console.log(numb1 = 7 + 5); // или в выводе на экран. Сам оператор правоассоциативный - т.е. вычисления последовательности операторов идут справа налево.
    
    /* Арифметические операции */
        numb1 = ( 7 + 2 - 3 ) * 4 / 5; // Сложение вычитание умножение и деление для чисел.
        numb1 = 31 % 8;    // Остаток от деления
        numb1 = 2 ** 3.5;  // Возведение в степень
        numb1 = 2 ** -2;   // == 0.25  Отрицательная степень указывает сколько раз нужно разделить единицу на данное число      
        Math.pow(2,-3.5);  // Аналогичное действие у функции Math.pow() 
        // Для вычисления корня можно использовать возведение в дробную степень
        numb1 = Math.sqrt(9);  // == 3   Корень квадратный их числа
        
        // Справедливы следующие соответствия (результат нижеприведенных сравнений == true)
            // https://learn.javascript.ru/number#delenie-na-nol-infinity
        b = 1 + Infinity  === Infinity     &&  
            1 - Infinity  === -Infinity    &&
            1 / Infinity  === 0            &&
           -1 / Infinity  === -0           && // ноль со знаком минус (бесконечно малое отрицательное число)
            1 / 0         === Infinity     &&
        ""+ 0 / 0         === "NaN"        && // Не допустимы: деление 0 на 0,
        ""+ 0 * Infinity  === "NaN"        && // умножение нуля на бесконечность,
        ""+(5 + NaN)      === "NaN"        && // арифметические операции с NaN,
        ""+ Infinity / Infinity  === "NaN" && // деление двух бесконечностей,
        ""+(Infinity - Infinity) === "NaN" && // вычитание двух бесконечностей.
            isNaN(0/0)  && // Функция isNaN(n) возвращает true если её аргумент NaN
            isFinite(5);   // isFinite(n) возращает true если её аргумент - конечное число    
        console.log("Результат проверки всех особых операций с числами: " + b);
    
    /* Унарные операции */
        i = +numb1;   // Унарный оператор подтверждения знака (используется для приведения других типов к числу)
        i = -numb1;   // Унарный оператор смены знака.
        j = ~i;       // Побитовая инверсия - вычитание из -1. Т.е. смена знака и одновременный декремент. Полезна в связке с операцией смены знака:
        j = -~i;      // Инкремент числа. Унарный аналог j = i+1 
        j = ~-i;      // Декремент числа. Унарный аналог j = i-1
        i = -~ 2 * 6; // Результат равен 18, а не 13, поскольку у унарных операторов приоритет выше чем у операций умножения и деления."
    
        i++; // Постфиксный инкремент переменной. Возвращает значение переменной ДО операции инкремента и увеличивает значение переменной на 1.
        i++; // Постфиксный декремент переменной. Возвращает значение переменной ДО операции декремента и уменьшает значение переменной на 1.
        ++i; // Префиксный инкремент переменной. Возвращает значение переменной ПОСЛЕ операции инкремента. Унарный аналог i = i+1.
        ++i; // Префиксный декремент переменной. Возвращает значение переменной ПОСЛЕ операции декремента. Унарный аналог i = i-1.
    
    /* Побитовые операции над 32-битной целой частью числа. Дробая часть теряется. Имеют низкий приоритет поэтому часто требуют обрамления скобками.
            https://learn.javascript.ru/bitwise-operators  */
        i = i << 5;  // Побитовый сдвиг влево на указанное число бит с сохранением знака (умножение на степень двойки ).
        i = i >> 2;  // Побитовый сдвиг вправо на указанное число бит с сохранением знака (деление на степень двойки).
        i = i >>> 1; // Побитовый сдвиг вправо на указанное число бит c заполнением освободившихся бит нулями.
        i = i & 5;   // Побитовое И (AND). Используется для установки в нужные биты значения 0.
        i = i | 5;   // Побитовое ИЛИ (OR). Используется для установки в нужные биты значения 1.
        i = i ^ 5;   // Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR). Используется для смены значений нужных битов на противоположные.
    
    /* Комбинированные операторы присваивания */
        i += 5; i -= 5;   // Увеличить или уменьшить переменную на указанное число.
        i *= 3; i /= 3;   // Умножить или поделить переменную на указанное число.   
        i %= 10;          // Записать в переменную остаток от деления её на указанное число; 
        i <<= 2; i >>= 2; i >>>= 2; // Сдвинуть биты переменной влево или вправо на указанное число позиций.
        i &= 5; i |= 5; i ^= 5;     // Поменять значение нужных бит на 0, 1 или противоположное.
        
    // В качестве оператора последовательных операций в одной строке используется символ запятой. Имеет самый низкий приоритет (нужно обрамлять его в скобки) и возвращает только последнее вычисленное значение в последовательности:
        numb1 = (i = 3, j = 2, i + j); // Используется в ряде случаев для сокращения кода и мимоходных присвоений значений переменным. 
    
    /* Операторы сравнения и логические операторы: 
            https://learn.javascript.ru/comparison  */
        // Во всех нижепреведенных сравнениях результат равен True  
        b = 2 == '2'   && // Нестрогое равенство (c приведением типов)
            2 != '3'   && //     и нестрогое неравенство
            2 === 2    && // Строгое равенство (без приведения типов)
            2 !== '2'  && //     и строгое неравенство
            bool1 != !bool1      && // Отрицание
            (1 >= 1) && (2 > 1)  && // Логическое "И" (конъюнкция)
           ((1 <= 1) || (2 < 1)) && // Логическое "ИЛИ" (дизъюнкция) - имеет более низкий приоритет
            NaN != NaN           && // NaN не равен ничему - даже самому себе
            null == undefined    && // Значения null и undefined нестрого равны друг другу и не равны ничему другому
            null >= 0            && // При применении операторов больше/меньше null приводится к нулю, 
            null != 0            && //     но при этом null != 0.
            "Строка 2" > "Строка 1"; // Строки сравниваются побуквенно по численным значениям символов в кодировке Unicode
        console.log("Результат всех сравнений и логических операций: " + b);
    
    /* Конкатенация строк: через бинарный оператор +  */
        str1 = str1 + "строка2"; 
    
    /* Особенности арифметического переполнения и искажений хранения */
        // 32-битная операция умножения целого числа на 2 путем сдвига влево вызовет переполнение на меньших числах, чем обычное умножение 64-битного вещественного
        console.log("Переполнение: вместо 20000000000 получаем " + (10000000000 << 1)); 
        numb1 = Number.MAX_SAFE_INTEGER; // 9007199254740991 это максимальное целое число которое сохранится без искажений 
        bool1 = (numb1+1) == (numb1+2) // Результат True поскольку обе суммы дают результат 9007199254740992 
console.groupEnd("Операции");
}

{/* ПРИВЕДЕНИЕ ТИПОВ ПРИ ОПЕРАЦИЯХ 
       https://learn.javascript.ru/types-conversion  
*/  
console.groupCollapsed("Приведение типов при операциях");

    // Автоматическое строковое преобразование
        str1 = 1 + '2'; // == 12. Если один из двух операндов при сложении является строкой, то производится конкатенация строк, а не арифметическое сложение.
        
        str1 = 1 + 2 + 3 + '4' + 5 + 6; // == 6456. Несколько операций сложения подряд выполняются слева направо. Пока операнды чиловые происходит арифметическое сложение. Но как только поступает строковый операнд, все остальные операции будут соединять строки.
        
        console.log(numb1); // Там где ожидается строковое значение простые типы приводятся к строке автоматически.

    // Явное строковое преобразование
        str1 = String( bool1 );  // Функция string преобразует любой тип в строку.   http://javascript.ru/String
        str1 = "" + true + 25 + null; // Явно преобразовать к строке можно и путём конкатенации с пустой строкой.

        // Справедливы следующие равенства 
        b = "" + undefined  === "undefined" &&  
            "" + null       === "null"      &&
            "" + NaN        === "NaN"       &&
            "" + Infinity   === "Infinity"  &&
            "" + true       === "true"      &&
            "" + false      === "false";     
        console.log("Результат проверки всех преобразований в строку: " + b); // true
        
        // Приведение числа к строке в разных системах счисления
            // https://learn.javascript.ru/number#tostring-sistema-schisleniya
        // toString(n) - метод численных значений, возвращающий строку в системе счисления по основанию n
        numb1 = 175; numb2 = 3.14;
        // Справедливы следующие равенства:
        b = numb1.toString()   === "175"      && // При неуказанном основании используется десятичная система
            numb1.toString(16) === "af"       && // Представление числа как шестнадцатиричное,
            numb1.toString(2)  === "10101111" && // двоичное.
            numb1.toString(36) === "4v"       && // Максимальное основание 36 - использует цифры и все латинские малые буквы
            numb2.toString()   === "3.14"     && // Вещественные числа тоже допустимы
            numb2.toString(36) === "3.51fu8n1fu9";  // в любых системах счисления
        console.log("Результат проверки всех вызовов toString: " + b); // true
        
        // Приведение числа к строке в национальном формате
                // https://learn.javascript.ru/intl
        numb1 = 1234567.12345;
        str1 = numb1.toLocaleString(); // "1 234 567,123"  

    // Автоматическое численное преобразование. Происходит при арифметических операциях и сравнениях с числами.
        i = 1 + null + true; // Если при сложении среди операндов нет строки, то все операнды приводятся к числу.
        i = '1' / '2' - '3' * '4' % '5'; // С другими арифметическими операциями все строки всегда приводятся к числу.
        i = '1' - '2б'; // результат равен NaN в случае если хотя бы одна строка дала ошибку преобразования
        // Операции сравнения == < <= > >= приводят свои операнды к числу (за исключением если они оба - строки)
        
    // Явное численное преобразование
        i = + '789';       // Унарный плюс приводит любой операнд к числу
        i = Number('789'); // Тот же эффект у функции Number()
        i = + '  \n 789 '; // При преобразовании строки в число пробельные символы по краям обрезаются (включая переносы строк)

        // Приведение целого числа к вещественному не нужно, т.к. все числа хранятся как вещественные
        // Приведение вещественного числа к целому:
                // https://learn.javascript.ru/number#okruglenie
            numb1 = Math.floor(3.2);  // == 3  Округление числа вниз
            numb1 = Math.ceil(3.2);   // == 4  Округление числа вверх
            numb1 = Math.round(3.2);  // == 3  Округление до ближайшего целого
            numb1 = 3.14159;
            numb2 = numb1.toFixed(2); // == 3.14  Метод toFixed(n) округляет до n знаков после точки
            numb2 = numb1 ^ 0; // Если для хранения целой части хватает 32 бит, то её удобно получать применением побитовой операции XOR
        
        // Функции парсинга строки способны считать число из начала строки даже если после цифр идут буквы. 
            // https://learn.javascript.ru/number#myagkoe-preobrazovanie-parseint-i-parsefloat
        // Справедливы следующие равенства:
        b = parseInt('45px')    ===  45 &&  // parseInt() - функция парсинга целого числа   
            parseInt('87.95 р') ===  87 &&  // Парсинг целого числа заканчивается на точке 
            parseInt('3.2e5')   ===   3 &&  // Научный формат как целое число НЕ распознается
            parseInt('0x10')    ===  16 &&  // Шестнадцатиричное число обрабатывается корректно
            parseInt('010')     ===  10 &&  // Восьмиричное число обрабатывается как десятичное. 
            // Для произвольных систем счисления можно вторым аргументом указать основание:
            parseInt('100',2)   ===   4 &&  // Двоичное число
            parseInt(' \n 5px') ===   5 &&  // Допустимы пробелы и переносы строки вначале
            isNaN(parseInt("$25"))      &&  // Если первый значимый символ не является цифрой и пробелом то результат NaN
            isNaN(parseInt(""))         &&  // Если в строке нет цифр, то результат NaN     
            isNaN(parseInt('Infinity')) &&  // Бесконечность не является целым числом - результат NaN     
            parseFloat('45.8px')   === 45.8  &&  // parseFloat() - функция парсинга вещественного числа   
            parseFloat('87.95.38') === 87.95 &&  // Если есть вторая точка то парсинг на ней остановится
            parseFloat('3.2e-2')   === 0.032 &&  // Научный формат обрабатывается корректно для вещ.чисел
            parseFloat('0x10')     === 0     &&  // Шестнадцатиричное число как вещественное не распознается
            parseFloat('Infinity!') === Infinity;  // Бесконечность распознается как вещественное 
        console.log("Результат проверки всех парсингов чисел: " + b); // true
                 
        // Также справедливы следующие равенства
        bool1 = isNaN(+ undefined) &&  
                isNaN(+ "123 456") && // Пробел внутри строки недопустим
                + ""    === 0      && // Пустая строка даёт 0
                + null  === 0      && 
                + true  === 1      &&
                + false === 0;         
        console.log("Результат проверки всех преобразований в число: " + bool1); // true
        
        // Проверка, является ли переменная числом:
            if (!isNaN(parseFloat(numb1))) // Такая проверка отсекает значения "", null, true, false
                console.log("В переменной Numb1 хранится число.");
            if (!isNaN(parseFloat(numb1)) && isFinite(numb1)) // Такая проверка отсекает ещё и бесконечные значения
                console.log("В переменной Numb1 хранится конечное число.");
    
    // Автоматическое логическое преобразование. Производится в случаях где ожидается логическое значение.
        if (numb1) j=5; // Если значение числа numb1 отлично от 0 или Nan, то выполнится операция j=5.
        if (str1) j=5;   // Если строка str1 не пустая, то выполнится операция j=5.
        
        // Операции && и || используют логический эквивалент операндов, но возращают непреобразованное значение.
            bool1 = numb1 && str1;  // В bool1 запишется число или строка, но не true или false 
        
        /* В последовательности логических И/ИЛИ возвращается первое слева значение, которое приводится к false/true. Если таковых нет, то возвратится последнее значение в последовательности. 
                https://learn.javascript.ru/logical-ops#korotkiy-tsikl-vychisleniy  */
            i = 1 && 2 && 3 && 0 && 4 && 5; // i==0 
            str1 = "" || 0 || "abc" || "";  // str1=="abc" 
            // При этом над оставшимися операндами вычисление не производятся
            (numb1 = 0) || (numb2 = 5) || (numb3 = 10); // В  numb3 ничего не будет записано, так как на операнде (numb2 = 5) вычисления прекратятся
    
    // Явное логическое преобразование        
        bool1 = !!789; // Два логических НЕ подряд приводят любой операнд к логическому    
        bool1 = Boolean(789); // Тот же эффект у функции Boolean() 

        // Справедливы следующие равенства
        bool1 = ( !! " "  === true  ) &&  // Пробел не является пустой строкой
                ( !! ""   === false ) && 
                ( !! 0    === false ) && 
                ( !! NaN  === false ) &&  // Все остальные числа дают true
                ( !! null === false ) && 
                ( !! undefined  === false );  // Все остальные значения и объекты преобразуются в true
        console.log("Результат проверки всех преобразований в логическое значение: " + bool1); // true
console.groupEnd("Приведение типов при операциях");        
}

{/* МАТЕМАТИЧЕСКИЕ ФУНКЦИИ И СТРОКОВЫЕ ПРЕОБРАЗОВАНИЯ */
console.groupCollapsed("Математические функции и строковые преобразования");
    // https://learn.javascript.ru/number#drugie-matematicheskie-metody  

    numb1 = Math.PI;  // Число Пи == 3.141592653589793
    numb1 = Math.E;   // Число e  == 2.718281828459045
    numb1 = Math.random();    // Генерация псевдослучайного числа:  0 <= Math.random() < 1. 

    numb1 = Math.abs(-3.14);  // == 3.14  Абсолютное значение числа
    numb1 = Math.log(10);     // Натуральный логарифм числа. log(x) - степень в которую нужно возвести e чтобы получить x.
    numb1 = Math.exp(1);      // Натуральная экпонента. exp(x) == e в степени x.
        console.log("Число e: " + numb1);
    numb1 = Math.max(2,-1,7); // Максимальное число из перечисленных аргументов
    numb1 = Math.min(2,-1,7); // Минимальное число из перечисленных аргументов
    
    // Тригонометрические функции
    numb1 = Math.sin(3.14/2); // Синус числа (для числа Пи/2 равен 1)
    numb1 = Math.cos(3.14);   // Косинус числа (для числа Пи равен -1)
    numb1 = Math.tan(3.14/4); // Тангенс числа (для числа Пи/4 равен 1)
    
    numb1 = Math.asin(1);     // Арксинус числа (для числа 1 равен Пи / 2). Аргумент должен быть <= 1 по модулю. Иначе - NaN
    numb1 = Math.acos(-1);    // Аркосинус числа (для числа 0 равен Пи). Аргумент должен быть <= 1 по модулю. Иначе - NaN
    numb1 = Math.atan(1);     // Арктангенс числа (для числа 1 равен Пи/4)
    numb1 = Math.atan(-5,5);  // Арктангенс по координатам точки (y,x) на плоскости (для угла 315 градусов равен Пи/4)     
        // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2
    
console.groupEnd("Математические функции и строковые преобразования");        
}


{/* РАБОТА С ФУНКЦИЯМИ И ПРОЦЕДУРАМИ (ПОДПРОГРАММАМИ)  
        https://learn.javascript.ru/function-basics
    Функция - это блок программы, который принимает на вход аргументы и возвращает некое значение (или значения).
    Процедура - блок программы, которому могут передаваться или не передаваться на вход аргументы, но который (в отличие от функции) не возвращает значения, а просто совершает некие побочные действия (ввод/вывод, изменение значений глобальных переменных и т.д.).
    В JavaScript процедурой явлется функция, которая не возвращает никакого значения.
*/
console.groupCollapsed("Работа с функциями и процедурами");

    // Объявление функции в режиме Function Declaration (допустимо в любом месте кода)
        function proc1() {  // После имени функции и круглых скобок задается блок операторов, являющийся телом функции
            'use strict';   // В начале функции можно задавать режим strict для интерпретатора. Он будет действовать в пределах функции
            console.log('Выполняется процедура proc1');  // Эта функция просто совершает побочное действие - выводит строку в консоль.
        }
    
    // Использование функций
        proc1(); // Вызов функции без аргументов
        proc1("Строка1", "Строка2", 15, true ); // В круглых скобках через запятую можно передать в функцию произвольное количество аргументов, даже если они не были объявлены при объявлении фукнции. 
        proc2("Тестовый аргумент", 23); // Если функция объявлена в режиме Function Declaration вызов функции можно делать до объявления функции
        
        /* Доступ к необъявленным аргументам в теле функции возможен через коллекцию (псевдомассив) arguments[]        
            https://learn.javascript.ru/arguments-pseudoarray  */
        function proc2() { // Вывод первых двух аргументов в консоль 
            console.log("Функцией proc2 получены аргументы: " + arguments[0] + " и " + arguments[1]);  
        }
        proc2("Только один аргумент"); // Если передать аргументов меньше задуманного, то для непереданных аргументов будет возвращаться значение undefined
        
        function proc3(width, height) { // Можно указать имена аргументов. Они станут локальными переменными внутри функции   
            str1 = "Ширина: " + width + ", Высота: " + height; // Из тела функции можно изменять глобальные переменные. Если глобальная переменная не существует то в режиме Strict это вызовет ошибку 
            var str2 = "Локальное значение";  // Директивой var можно объявить локальную переменную, даже если её имя совпадает с глобальной 
            console.log("Внутри функции в Str2 - " + str2); // В теле функции обрабатывается локальное значение
            
            wight = 65; var height = 75; // Значение аргументов можно по неосторожности заменить на другое. Интерпретатор ошибки не покажет. Но эту особенность можно использовать для проставления значений по умолчанию (если аргумент не передан в функцию):
            if (width === undefined) width = 0; // Очевидный способ
            width = width || 0; // Компактный но менее наглядный способ, использующий особенность оператора || 
        }

        str2 = "Глобальное значение";
        proc3(35,45);
        console.log("Функцией proc3 получены аргументы. " + str1);
        console.log("Вне тела функции в Str2 - " + str2); // Вне тела функции обрабатывается глобальное значение
    
    // Возвращение значений из функции   
        function summ_sqr(a, b) { 
            return a**2 + b**2;  // Возврат значения осуществляется ключевым словом return и возвращаемым выражением после него.
            console.log("Это сообщение не отобразится"); // После return компилятор прекращает выполнение тела функции
            return; // Если указать return без возвращаемого выражения, то это аналогично директиве break в цикле - будет прервано выполнение тела функции без возврата значения (т.е. ведёт себя как процедура).
        }
        function emptyFunc() {} 
        console.log("Пустая функция возвращает " + emptyFunc() ); // Функция-процедура возвращает undefined
    
    // Имя функции как переменная. Функциональные выражения
           // https://learn.javascript.ru/function-declaration-expression
        str1 = "" + proc1; // Имя фукнции без скобок является переменной, хранящей код функции. Его содержимое можно сохранить в строковую переменную.
        var proc1b = proc1; // Функцию можно продублировать в новую переменную
        var proc1c = function(){   // Объявление функции в режиме Function Expression
            console.log('Выполняется процедура proc1с');
        }
        proc1c(); // Если функция объявлена в режиме Function Expression вызов функции можно делать только после объявления функции
        proc1c = null; // Переменную содержащую функциональное выражение можно обнулить
        
    // Область видимости функциональных выражений
        // Для разграничения области видимости используются именнованные функциональные выражения (NFE - Named Function Expression)
            // https://learn.javascript.ru/named-function-expression
        var f1 = function myFunc(){  // f1 - глобальная переменная , а myFunc - локальная, которую нельзя изменить снаружи (что важно для рекурсии)
            return (f1 == myFunc) ? true : false;  // Кажется что f1 и myFunc равны, а поэтому функция всегда будет возвращать true
        }
        if (f1()) console.log('Функция для обоих своих имён работает корректно.');  // f1 == myFunc  
        
        var f2 = f1; f1 = null; // Если перезаписать глобальную переменную, то коррекное обращение к функции по глобальному имени перестанет работать:
        if (!f2()) console.log('Функция перестала работать, т.к. её глобальное имя f1 перезаписано.'); // f1 != myFunc
        
        f1 = f2; myFunc = null; // Восстанавливаем переменную какой она была и пробуем теперь изменить именованное функциональное выражение.
        if (f1()) console.log('Функция снова работает корректно - снаружи невозможно изменить то что хранится в её локальном имени.'); // Внутри функции f1 == myFunc
        
 
    // Передача функции в качестве аргумента другой функции   
        i = applyFunc3(sum, 2, 3, 4); // К числам применяется функция сложения.
        console.log('Результат применения функции sum к числам: ' + i); // i == 9
        
        function applyFunc3(f,a,b,c){ // Объявление функции принимающей на вход другую функцию
            var x = f(a,b);           // В этом примере к аргументам a,b,c попарно применяется функция f
            return f(x,c);
        }
        function sum(a,b) {  // Функция сложения двух чисел, используемая для передачи в качестве аргумента
            return a + b;
        }
    
    // Анонимные функции - это функции которые объявляются прямо там где используются, без сохранения в именованную переменную
        i = applyFunc3(     // К числам применяется функция умножения, созданная на лету
                function(a,b){return a*b;}, 
                2, 3, 4
            ); 
        console.log('Результат применения анонимной функции умножения к числам: ' + i); // i == 24
    
console.groupEnd("Работа с функциями и процедурами");
}
       
/* ОРГАНИЗАЦИЯ ЛОГИКИ ПРОГРАММЫ */

  {/* ВЕТВЛЕНИЯ В ЛОГИКЕ ПРОГРАММЫ
       https://learn.javascript.ru/ifelse   */

console.groupCollapsed("Организация ветвлений в логике программы");
        
    // Условие с одной ветвью
        if (bool1) str1 = 'Yes';
        // Запись в несколько строк:
        if (!bool1) {
            str1 = 'No';
        }
    // Условие с двумя ветвями
        if (bool1) str1 = 'Yes'; 
            else str1 = 'No';
        // Запись в несколько строк:
        if (bool1) {
            str1 = 'Yes'; 
        } else {
            str1 = 'No';
        }
    // Множественный выбор между несколькими условиями:
        if        (numb2 == 0)  { j = 0; 
        } else if (numb2 < 10)  { j = 2;
        } else if (numb2 < 100) { j = 5;
        } else                  { j = 10;
        }
        
    // Сравнение по образцу
            https://learn.javascript.ru/switch
        i = 2;
        switch(i) {     // В скобках задется выражение, для которого будет производиться точное сравнение ===
            case  1:    // Директива case действует аналогично оператору if (i === 1)
                j='а';  // От двоеточия до следующего case перечисляются инструкции, которые выполнятся в случае истинности сравнения
                break;  // Если директива break выполнится, то она прервёт работу блока switch.
            case  2: j='б'; break; // Поскольку i===2 эта инструкция будет выполнена и работа всего блока switch закончится (присутсвует break)
            case  3: j='в'; break; // Эту и последующие строки интерпретатор пропустит
            case  4: j='д'; break;
            default: j='_';        // Если бы ни один образец не совпал, то сработают инструкции заданные после директивы default
        }                          // j == "б"
        console.log("Числу " + i + " соответствует буква " + j); 

        // Если директиву break не указать, то будут выполнены все остальные инструкции блока БЕЗ СРАВНЕНИЙ с образцами. Т.е. в этом случае конструкция switch действует как переход по метке
        j="";
        switch(i) {     
            case  1: j+='а'; // i!==1 и значит инструкция не выполнится
            case  2: j+='б'; // i===2 а значит эта инструкция будет выполнена и отключен режим сравнения с образцами
            case  3: j+='в'; // Все оставшиеся интсрукции выполнятся, т.к. сравнение больше не производится
            case  4: j+='д'; // Директиву default можно опускать
        }                    // j == "бвд_"
        console.log("Начиная с числа " + i + " идет набор букв " + j); 
    
    // Тернарная условная операция. Это операция, возвращающая свой второй или третий операнд в зависимости от значения логического выражения, заданного первым операндом. 
        bool1 = (numb1 > 10) ? true : false; // Формат записи:      условие ? значение1 : значение2
        bool1 = numb1 > 10 ? true : false;   // То же самое без скобок (в силу низкого приоритета оператора ?)
        // Цепочка тернарных условных операций
        j = (numb2 = 0)   ? 0 :
            (numb2 < 10)  ? 2 :
            (numb2 < 100) ? 5 :
                            10 ;
  console.groupEnd("Организация ветвлений в логике программы");
  }
  
  {/* БЕЗУСЛОВНЫЕ УПРАВЛЯЮЩИЕ КОММАНДЫ 
            https://puzzleweb.ru/javascript/11_loops3.php   */
        block1: { // Блок операторов можно пометить именованной меткой, завершающейся двоеточием
            i = 2;
            break block1; // Директива break прерывает выполнение блока с указанным именем
            i = 3; // Этот оператор не будет выполнен
        }
        console.log('Выполнение блока операторов прервано. i = ' + i);
  }
  
  {/* ДИНАМИЧЕСКОЕ СОЗДАНИЕ КОДА И ДАННЫХ */
    console.groupCollapsed("Динамическое создание кода и данных");
        
        // Создание переменной в зависимости от условия
            if (true) { var condiVar = "Новый текст"; }
            console.log("Условие выполнилось и создана переменная с содержимым: " + condiVar); 
    
        // Создание функции в зависимости от условия
                https://learn.javascript.ru/function-declaration-expression#bad-conditional-declaration
            if (true) { // В режиме Function Expression функцию можно объявлять внутри блока if
                var condiFunc = function(){ console.log('Условие выполнилось и создана функция condiFunc.'); }   
            } 
            if (condiFunc) condiFunc(); // Проверка того что функция создана перед ее вызовом (иначе скрипт может зависнуть)

        // Генерация кода из текстовой строки 
            str1 = "{ console.log('Выполняется сгенерированный код'); }";  // Можно создать код и поместить его в переменную
            var genProc1 = new Function('', str1); // Объявление функции через выражение с ключевыми словами new Function (c большой буквы F) позволяет двумя строками задать параметры и тело функции
            genProc1(); 
            var genFunc1 = new Function('a,b', ' return "Получены параметры " + a + " и " + b ');
            console.log( genFunc1(45,false) );
    console.groupEnd("Динамическое создание кода и данных");        
  }

  {/* ЦИКЛЫ
        https://learn.javascript.ru/while-for   */    
  console.groupCollapsed("Циклы");
        
    // Цикл со счётчиком
        Str1 = "";
        for (i=1; i<10; i++) // (начало; условие; шаг) Здесь на каждой итерации счётчик увеличивается на 1 в порядке возрастания.
            Str1 += i + " "; 
        
        for (; i>0; ) // Операторы в условии цикла можно оставлять пустыми  
            Str1 += i-- + " "; 
        console.log("Счет от 1 до 10 и обратно: " + Str1);
            
        var factorial1 = 1;
        for (i=2; i<=5; i++) { // Если в теле цикла несколько операторов, то они заключаются в логический блок {}
            factorial1 = factorial1 * i; 
            console.log(i + '! = ' + factorial1 + '; ');
        }
        
    // Вложенный цикл со счётчиком
        console.log('Таблица сложения:'); 
        for (i=1; i<=5; i++) {
            Str1 = "";
            for (j=1; j<=5; j++) {
                Str1 += Number(i+j) + ' '; 
            }
            console.log(Str1);
        }
        console.log('После выполнения циклов значения счётчиков сохраняются: i = ' + i + ' и j = ' + j);
        
    // Цикл с предусловием
        i=12;
        while (i<90) { // Удваиваем число если оно меньше 90
            i *= 2;
        }
        console.log('Цикл с предусловием окончен. i = ' + i);
        
    // Цикл с постусловием
        do 
            i /= 3;   // Можно использовать несколько операторов без заключения их в блок {}
        while (i>10); // Уменьшаем число в 3 раза пока не преодолеем порог меньше 10
        console.log('Цикл с постусловием окончен. i = ' + i);

    // Перерывание работы цикла
        for (;;i++) { // При таком условии цикл будет повторяться вечно, если его не прервать
            if (i % 2 == 0) continue; // Переход на следующую итерацию текущего цикла
            if (i > 30) break; // Выход из текущего цикла
        } 
        console.log('Вечный цикл окончен. i = ' + i);
        
        // С помощью break сделаем таблицу сложения треугольной
        console.log('Нечетные строки треугольной таблицы сложения:'); 
        loop1: for (i=1; i<=5; i++) { // Цикл как и обычный блок можно пометить именованной меткой
            Str1 = "";
            loop2: for (j=1; j<=5; j++) {
                if (j > i) break loop2; // Переход на следующую итерацию цикла помеченного меткой loop2
                if (i % 2 == 0) continue loop1; // Выход из цикла помеченного меткой loop1
                Str1 += Number(i+j) + ' ';
            }    
            console.log(Str1);
        } 
  console.groupEnd("Циклы");    
  }

  {/* РЕКУРСИЯ 
        https://learn.javascript.ru/recursion  */ 
  console.groupCollapsed("Рекурсия");
    
    // Рекурсия с ветвлением по условию:
        var factorial = function f(n){  // Вычисление факториала от n
            if (n==0) return 1; // else можно не писать, поскольку в случае n==0 на этой строке функция завершит работу
            return n * f(n-1); 
        }
        console.log("10! = " + factorial(10)); //  == 3628800
        
        
        var summNatural = function f(n){  // Сумма натуральных чисел от 1 до n
            return n ? n + f(n-1) : n;  // Тернарный условный оператор ? делает код компактнее
        }
        console.log("1 + .. + 10 = " + summNatural(10)); //  == 55
    
    // Рекурсия через множественный выбор
        var factorial2 = function f(n){    // Эта версия функции корректно обрабатывает всё что не является положительным числом, возвращая NaN   
            return n > 200 ? Infinity   :  // Для запредельных значений сразу возвращаем Infinity
                   n > 0   ? n * f(n-1) :  // Цепочка тернарных операторов ? позволяет проверить несколько условий.
                   n === 0 ? 1          :
                             NaN; 
        }
    
    // Рекурсия со вспомогательной функцией для хранения промежуточного значения
        function prime(n)  { // Функция определения числа на простоту (возвращает true или false)
            function prime_(n,m) {  // Локальная вспомогательная функция. Аргумент m хранит число, до которого произведена проверка
                return m * m > n  ? true  : // Все кандидаты на делители проверены - возвращаем true 
                       n % m == 0 ? false : // Делитель найден - возвращаем false
                                    prime_(n,m+1); // Рекурсивный вызов проверки следующего кандидата на делителя
            }
            return n > 0 ? prime_(n,2) : NaN; // Для положительного числа запускаем вспомогательную функцию проверки кандидатов на делители начиная с 2
        }  
        str1='';
        for (i=2; i<128; i++)   // Формируем список простых чисел
            if (prime(i)) str1 += " " + i + " ";   
        console.log("Простые числа: " + str1);
  console.groupEnd("Рекурсия");       
  }

  