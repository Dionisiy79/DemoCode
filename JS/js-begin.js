//  Однострочный комментарий до конца строки задается двумя косыми чертами в начале комментария
/*  Многострочный комментарий - обрамляется парой символов "/" и "*" 
    В начале комментария символы идут в прямом порядке, а в конце - в обратном.
        https://learn.javascript.ru/structure#kommentarii
*/

/*  ОБЩИЕ СИНТАКСИЧЕСКИЕ ПРАВИЛА
    Команды в JS разделяются символом точки с запятой ";"
    Если символ ";" пропущен, но есть перевод строки, то интерпретатор может его автоматически вставить, но надеяться на это не стоит.
        https://learn.javascript.ru/structure#komandy
    Блок операторов выделяется фигурными скобками {}
    Отключить выполнение кода можно поместив его внутрь блока if(0){  }
*/
if(0){ "Невыполнящийся код" } // В коде не должно быть ошибок. Для включения нужно 0 заменить на 1.

"use strict"; /* Эта директива переводит интерпретатор в режим стандарта ES5, лишенного недостатков старого стандарта. 
                 При этом теряется совместимость с IE9- и скриптами, написанными в старом стандарте
                    https://learn.javascript.ru/strict-mode */

console.group("Команды");
{/*  КОМАНДЫ ВЗАИМОДЕЙСТВИЯ С ПОЛЬЗОВАТЕЛЕМ 
         https://learn.javascript.ru/uibasic
*/  
    if(0){  // Демонстрация всплывающих окон (отключена)
    // Вывод текстовых строк
        alert('Hello world!');        // В модальное веб-окно с ожиданием реакции пользователя
        console.log('Hello World!');  // В консоль с переносом строки
        document.write('Hello world!');  // В текущее место веб-страницы (после закрывающего тега </script>). Если скрипт выполнится не в процессе, а после загрузки HTML-страницы то страница будет стерта и начата новая. 

    // Запрос пользователю ввести строку, которая будет сохранена в переменной inputStr
        var inputStr = prompt('Введите строку:', 'Текст по умолчанию'); 
    // Запрос пользователю ответить Да/Нет. Результат ответа будет сохранен в логическую переменную inputBool.    
        var inputBool = confirm("Вы подтверждаете запрос?"); 
    }
    // Пауза на 3 секунды. Будет отложено выполнение только блока операторов функции func(). Загрузка страницы и остальные скрипты на странице продолжат своё выполнение.
        function func() { 
            console.log('Прошло 3 секунды.'); 
        }
        setTimeout(func, 3000);
}
console.groupEnd("Команды");
console.group("Переменные");
{/* РАБОТА С ПЕРЕМЕННЫМИ   
        https://learn.javascript.ru/variables
    Имя переменной не должно начинаться с цифры и может состоять из букв, цифр, символов $ и _ 
    Регистр имеет значение.
*/

    // Объявление и инициализация переменных
        var str1; /* Новая переменная объявляется с помощью ключевого слова var. Это можно делать в любом месте кода.
                        https://learn.javascript.ru/variables#vazhnost-direktivy-var */
        var numb1 = 546; // При объявлении переменной можно сразу инициализировать её значение.
        var str2, i, j, numb2, numb3 = 123;  // Можно объявить несколько переменных через запятую.
        numb3 = "Строка"; // Тип переменной не фиксирован и в любую переменную может быть записаны данные любого типа
        var NUMBER_PI = 3.14;  // В JS нет констант, поэтому принято вместо констант использовать переменные названные прописными буквами и просто не менять их значения в дальнейшем.
    
    //  Простые типы данных в JS      https://learn.javascript.ru/types-intro
        numb2 = 456;      // Для чисел существует стандартный тип - 64-битный с плавающей точкой
        numb2 = 789;      // Проинициализированную переменную можно заменить новым значением.
        numb1 = 123.789;  // Для задания вещественного числа используется разделитель - точка
        numb2 = Infinity; // Спец.значение "бесконечность" используется в случае деления на ноль
        numb3 = NaN;      // Спец.зачение "Not a Number" используется для обозначения ошибки вычислений
        
    // Задание целых 32-битных чисел в других системах счисления делается функцией parseInt()
            // http://javascript.ru/ParseInt
        numb2 = parseInt("F57", 16);      // Шестнадцатиричное число
        numb2 = parseInt("4651", 8);      // Восьмиричное число
        numb2 = parseInt("10011110", 2);  // Двоичное число
        numb2 = parseInt("-10011110", 2); // Знаком минус можно задать отрицательное значение
        
        var bool1 = true;   // Логический тип "истина"
            bool1 = false;  // и "ложь"
    
        str1 = "Тестовая строка";       // Строки задаются двойными или одинарыми кавычками
        str1 = 'Тестовые "кавычки"';    // Для использования в строке двойных кавычек можно обрамлять её в одинарные кавычки
        str1 = "Тестовые \"кавычки\"";  // либо использовать экранирующий символ  "\"
        str1 = " \\ ";                  // Для сохранения экранирующего символа его нужно написать дважды 
        str1 = "Первая строка\nВторая строка"; // Перенос строки: \n
        
        str2 = null;        // Специальный тип означающий "неизвестное значение"
        str1 = undefined;   // Специальный тип означающий "переменная неинициализирована". 
        
        /* Для проверки типа переменной можно применить оператор typeof, который возвращает такие значения:
            "number", "string", "boolean", "undefined", "object" */
        str1 = typeof str2; // Для переменных типа null оператор возвращает значение "object"

    // Использование переменных
        // Проверка, является ли переменная инициализированной. Работает независимо от того, объявлена ли переменная.
        if (typeof newVar == "undefined") { 
            console.log('Переменная newVar не инициализирована') 
        };
        console.log(str1); // Вывод значения переменной в консоль
        
        numb2 = numb1; // Запись значения переменной в другую переменную.
        numb2 = numb2 / numb1; // В выражениях для присвоения нового значения можно использовать эту же переменную, пока в ней хранится старое значение.
} 
console.groupEnd("Переменные");
console.groupCollapsed("Операции");       
{/* ОПЕРАЦИИ
       https://learn.javascript.ru/operators
       https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence */
    numb1 = numb2 = 5;         // Оператор присваивания тоже возвращает значение, которое можно использовать в предыдущем операторе присваивания. Сам оператор правоассоциативный - т.е. вычисления последовательности операторов идут справа налево.
    console.log(numb1 = 7 + 5); // или в выводе на экран
    
    /* Арифметические операции */
        numb1 = ( 7 + 2 - 3 ) * 4 / 5; // Сложение вычитание умножение и деление для чисел.
        numb1 = 31 % 8;                // Остаток от деления
        numb1 = 2 ** 3.5;              // Возведение в степень
        // Для вычисления корня квадратного или любого другого используется возведение в дробную степень
        
        // Справедливы следующие соответствия (результат нижеприведенных сравнений == true)
        bool1 = 1 + Infinity  === Infinity     &&  
                1 - Infinity  === -Infinity    &&
                1 / Infinity  === 0            &&
                1 / 0         === Infinity     &&
          ""+   0 * Infinity  === "NaN"        && // Не допустимо: умножение нуля на бесконечность,
          ""+   Infinity / Infinity  === "NaN" && // деление двух бесконечностей,
          ""+  (Infinity - Infinity) === "NaN";   // вычитание двух бесконечностей.
        console.log("Результат проверки всех операций с числом Infinity: " + bool1);
    
    /* Унарные операции */
        i = +numb1;  // Унарный оператор подтверждения знака (используется для приведения других типов к числу)
        i = -numb1;  // Унарный оператор смены знака.
        j = ~i;       // Побитовая инверсия - вычитание из -1. Т.е. смена знака и одновременный декремент. Полезна в связке с операцией смены знака:
        j = -~i;      // Инкремент числа. Унарный аналог j = i+1 
        j = ~-i;      // Декремент числа. Унарный аналог j = i-1
        i = -~ 2 * 6; // Результат равен 18, а не 13, поскольку у унарных операторов приоритет выше чем у операций умножения и деления."
    
        i++; // Постфиксный инкремент переменной. Возвращает значение переменной ДО операции инкремента и увеличивает значение переменной на 1.
        i++; // Постфиксный декремент переменной. Возвращает значение переменной ДО операции декремента и уменьшает значение переменной на 1.
        ++i; // Префиксный инкремент переменной. Возвращает значение переменной ПОСЛЕ операции инкремента. Унарный аналог i = i+1.
        ++i; // Префиксный декремент переменной. Возвращает значение переменной ПОСЛЕ операции декремента. Унарный аналог i = i-1.
    
    /* Побитовые операции над 32-битной целой частью числа. Дробая часть теряется. Имеют низкий приоритет поэтому часто требуют обрамления скобками.
            https://learn.javascript.ru/bitwise-operators  */
        i = i << 5;  // Побитовый сдвиг влево на указанное число бит с сохранением знака (умножение на степень двойки ).
        i = i >> 2;  // Побитовый сдвиг вправо на указанное число бит с сохранением знака (деление на степень двойки).
        i = i >>> 1; // Побитовый сдвиг вправо на указанное число бит c заполнением освободившихся бит нулями.
        i = i & 5;   // Побитовое И (AND). Используется для установки в нужные биты значения 0.
        i = i | 5;   // Побитовое ИЛИ (OR). Используется для установки в нужные биты значения 1.
        i = i ^ 5;   // Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR). Используется для смены значений нужных битов на противоположные.
    
    /* Комбинированные операторы присваивания */
        i += 5; i -= 5;   // Увеличить или уменьшить переменную на указанное число.
        i *= 3; i /= 3;   // Умножить или поделить переменную на указанное число.   
        i %= 10;          // Записать в переменную остаток от деления её на указанное число; 
        i <<= 2; i >>= 2; i >>>= 2; // Сдвинуть биты переменной влево или вправо на указанное число позиций.
        i &= 5; i |= 5; i ^= 5;     // Поменять значение нужных бит на 0, 1 или противоположное.
        
    // В качестве оператора последовательных операций в одной строке используется символ запятой. Имеет самый низкий приоритет (нужно обрамлять его в скобки) и возвращает только последнее вычисленное значение в последовательности:
        numb1 = (i = 3, j = 2, i + j); // Используется в ряде случаев для сокращения кода и мимоходных присвоений значений переменным. 
    
    /* Операторы сравнения и логические операторы: 
            https://learn.javascript.ru/comparison  */
        // Во всех нижепреведенных сравнениях результат равен True    
        bool1 = 2 == '2';   // Нестрогое равенство (c приведением типов)
        bool1 = 2 != '3';   // и нестрогое неравенство
        bool1 = 2 === 2;    // Строгое равенство (без приведения типов)
        bool1 = 2 !== '2';  // и строгое неравенство
        bool1 = !bool1;     // Отрицание
        
        bool1 = (1 >= 1) && (2 > 1); // Логическое "И" (конъюнкция)
        bool1 = (1 <= 1) || (2 < 1); // Логическое "ИЛИ" (дизъюнкция)
        
        bool1 = null == undefined;   // Значения null и undefined нестрого равны друг другу и не равны ничему другому
        bool1 = null >= 0;           // При применении операторов больше/меньше null приводится к нулю, но при этом null != 0.
        bool1 = "Строка 2" > "Строка 1"; // Строки сравниваются побуквенно по численным значениям символов в кодировке Unicode
    
    str1 = str1 + "строка2"; // Конкатенация строк: через бинарный оператор +
    
    /* Особенности арифметического переполнения и искажений хранения */
        // 32-битная операция умножения целого числа на 2 целого путем сдвига влево вызовет переполнение на меньших числах, чем обычное умножение 64-битного вещественного
        console.log("Переполнение: вместо 20000000000 получаем " + (10000000000 << 1)); 
        numb1 = Number.MAX_SAFE_INTEGER; // 9007199254740991 это максимальное целое число которое сохранится без искажений 
        bool1 = (numb1+1) == (numb1+2) // Результат True поскольку обе суммы равны 9007199254740992 
}
console.groupEnd("Операции");
{/* ПРИВЕДЕНИЕ ТИПОВ ПРИ ОПЕРАЦИЯХ 
       https://learn.javascript.ru/types-conversion  
*/  
    // Автоматическое строковое преобразование
        str1 = 1 + '2'; // == 12. Если один из двух операндов при сложении является строкой, то производится конкатенация строк, а не арифметическое сложение.
        
        str1 = 1 + 2 + 3 + '4' + 5 + 6; // == 6456. Несколько операций сложения подряд выполняются слева направо. Пока операнды чиловые происходит арифметическое сложение. Но как только поступает строковый операнд, все остальные операции будут соединять строки.
        
        console.log(numb1); // Там где ожидается строковое значение простые типы приводятся к строке автоматически.

    // Явное строковое преобразование
        str1 = String( bool1 );  // Функция string преобразует любой тип в строку.   http://javascript.ru/String
        str1 = "" + true + 25 + null; // Явно преобразовать к строке можно и путём конкатенации с пустой строкой.

        // Справедливы следующие равенства 
        bool1 = "" + undefined  === "undefined" &&  
                "" + null       === "null"      &&
                "" + NaN        === "NaN"       &&
                "" + Infinity   === "Infinity"  &&
                "" + true       === "true"      &&
                "" + false      === "false";     
        console.log("Результат проверки всех преобразований в строку: " + bool1); // true
        
    // Автоматическое численное преобразование. Происходит при арифметических операциях и сравнениях с числами.
        i = 1 + null + true; // Если при сложении среди операндов нет строки, то все операнды приводятся к числу.
        i = '1' / '2' - '3' * '4' % '5'; // С другими арифметическими операциями все строки всегда приводятся к числу.
        i = '1' - '2б'; // результат равен NaN в случае если хотя бы одна строка дала ошибку преобразования

    // Явное численное преобразование
        i = + '789';       // Унарный плюс приводит любой операнд к числу
        i = Number('789'); // Тот же эффект у функции Number()
        i = + '  \n 789 '; // При преобразовании строки в число пробельные символы по краям обрезаются (включая переносы строк)
        
        // Справедливы следующие равенства
        bool1 = String(+ undefined) === "NaN" &&  
                String(+ "123 456") === "NaN" && // Пробел внутри строки недопустим
                       + ""    === 0          && // Пустая строка даёт 0
                       + null  === 0          && 
                       + true  === 1          &&
                       + false === 0;         
        console.log("Результат проверки всех преобразований в число: " + bool1); // true
    
    // Автоматическое логическое преобразование. Производится в случаях где ожидается логическое значение.
        if (numb1) j=5; // Если значение числа numb1 отлично от 0 или Nan, то выполнится операция j=5.
        if (str1) j=5;   // Если строка str1 не пустая, то выполнится операция j=5.
        
        // Операции && и || используют логический эквивалент операндов, но возращают непреобразованное значение.
            bool1 = numb1 && str1;  // В bool1 запишется число или строка, но не true или false 
        
        /* В последовательности логических И/ИЛИ возвращается первое слева значение, которое приводится к false/true. Если таковых нет, то возвратится последнее значение в последовательности. 
                https://learn.javascript.ru/logical-ops#korotkiy-tsikl-vychisleniy  */
            i = 1 && 2 && 3 && 0 && 4 && 5; // i==0 
            str1 = "" || 0 || "abc" || "";  // str1=="abc" 
            // При этом над оставшимися операндами вычисление не производятся
            (numb1 = 0) || (numb2 = 5) || (numb3 = 10); // В  numb3 ничего не будет записано, так как на операнде (numb2 = 5) вычисления прекратятся
    
    // Явное логическое преобразование        
        bool1 = !!789; // Два логических НЕ подряд приводят любой операнд к логическому    
        bool1 = Boolean(789); // Тот же эффект у функции Boolean() 

        // Справедливы следующие равенства
        bool1 = ( !! " "  === true  ) &&  // Пробел не является пустой строкой
                ( !! ""   === false ) && 
                ( !! 0    === false ) && 
                ( !! NaN  === false ) &&  // Все остальные числа дают true
                ( !! null === false ) && 
                ( !! undefined  === false );  // Все остальные значения и объекты преобразуются в true
        console.log("Результат проверки всех преобразований в логическое значение: " + bool1); // true
}

{/* РАБОТА С ФУНКЦИЯМИ И ПРОЦЕДУРАМИ (ПОДПРОГРАММАМИ)  
        https://learn.javascript.ru/function-basics
    Функция - это блок программы, который принимает на вход аргументы и возвращает некое значение (или значения).
    Процедура - блок программы, которому могут передаваться или не передаваться на вход аргументы, но который (в отличие от функции) не возвращает значения, а просто совершает некие побочные действия (ввод/вывод, изменение значений глобальных переменных и т.д.).
    В JavaScript процедурой явлется функция, которая не возвращает никакого значения.
*/
    // Объявление функции (допустимо в любом месте кода)
        function proc1() {  // После имени функции и курглых скобок задается блок операторов, являющийся телом функции
            console.log('Выполняется процедура proc1');  // Эта функция просто совершает побочное действие - выводит строку в консоль.
        }
    
    // Использование функций
        proc1(); // Вызов функции без аргументов
        proc1("Строка1", "Строка2", 15, true ); // В круглых скобках через запятую можно передать в функцию произвольное количество аргументов, даже если они не были объявлены при объявлении фукнции. 
        
        /* Доступ к необъявленным аргументам в теле функции возможен через коллекцию (псевдомассив) arguments[]        
            https://learn.javascript.ru/arguments-pseudoarray  */
        function proc2() { // Вывод первых двух аргументов в консоль 
            console.log("Функцией proc2 получены аргументы: " + arguments[0] + " и " + arguments[1]);  
        }
        proc2("Тестовый аргумент", 23);
        proc2("Только один аргумент"); // Если передать аргументов меньше задуманного, то для непереданных аргументов будет возвращаться значение undefined
        
        function proc3(width, height) { // Можно указать имена аргументов. Они станут локальными переменными внутри функции   
            Str1 = "Ширина: " + width + ", Высота: " + height; // Из тела функции можно изменять глобальные переменные. Если глобальная переменная не существует то в режиме Strict это вызовет ошибку 
            var Str2 = "Локальное значение";  // Директивой var можно объявить локальную переменную, даже если её имя совпадает с глобальной 
            console.log("Внутри функции в Str2 - " + Str2); // В теле функции обрабатывается локальное значение
            
            wight = 65; var height = 75; // Значение аргументов можно по неосторожности заменить на другое. Интерпретатор ошибки не покажет. Но эту особенность можно использовать для проставления значений по умолчанию (если аргумент не передан в функцию):
            if (width === undefined) width = 0; // Очевидный способ
            width = width || 0; // Компактный но менее наглядный способ, использующий особенность оператора || 
        }

        Str2 = "Глобальное значение";
        proc3(35,45);
        console.log("Функцией proc3 получены аргументы. " + Str1);
        console.log("Вне тела функции в Str2 - " + Str2); // Вне тела функции обрабатывается глобальное значение
    
    // Возвращение значений из функции   
        function summ_sqr(a, b) { 
            return a**2 + b**2;  // Возврат значения осуществляется ключевым словом return и возвращаемым выражением после него.
            console.log("Это сообщение не отобразится"); // После return компилятор прекращает выполнение тела функции
            return; // Если указать return без возвращаемого выражения, то это аналогично директиве break в цикле - будет прервано выполнение тела функции без возврата значения (т.е. ведёт себя как процедура).
        }
        function emptyFunc() {} 
        console.log("Пустая функция возвращает " + emptyFunc() ); // Функция-процедура возвращает undefined
}
       
{/* ОРГАНИЗАЦИЯ ВЕТВЛЕНИЙ В ЛОГИКЕ ПРОГРАММЫ
       https://learn.javascript.ru/ifelse
*/
    // Условие с одной ветвью
        if (bool1) str1 = 'Yes';
        // Запись в несколько строк:
        if (!bool1) {
            str1 = 'No';
        }
    // Условие с двумя ветвями
        if (bool1) str1 = 'Yes'; 
            else str1 = 'No';
        // Запись в несколько строк:
        if (bool1) {
            str1 = 'Yes'; 
        } else {
            str1 = 'No';
        }
    // Множественный выбор между несколькими условиями:
        if        (numb2 == 0)  { j = 0; 
        } else if (numb2 < 10)  { j = 2;
        } else if (numb2 < 100) { j = 5;
        } else                  { j = 10;
        }
        
    // Сравнение по образцу
            https://learn.javascript.ru/switch
        i = 2;
        switch(i) {     // В скобках задется выражение, для которого будет производиться точное сравнение ===
            case  1:    // Директива case действует аналогично оператору if (i === 1)
                j='а';  // От двоеточия до следующего case перечисляются инструкции, которые выполнятся в случае истинности сравнения
                break;  // Если директива break выполнится, то она прервёт работу блока switch.
            case  2: j='б'; break; // Поскольку i===2 эта инструкция будет выполнена и работа всего блока switch закончится (присутсвует break)
            case  3: j='в'; break; // Эту и последующие строки интерпретатор пропустит
            case  4: j='д'; break;
            default: j='_';        // Если бы ни один образец не совпал, то сработают инструкции заданные после директивы default
        }                          // j == "б"
        console.log("Числу " + i + " соответствует буква " + j); 

        // Если директиву break не указать, то будут выполнены все остальные инструкции блока БЕЗ СРАВНЕНИЙ с образцами. Т.е. в этом случае конструкция switch действует как переход по метке
        j="";
        switch(i) {     
            case  1: j+='а'; // i!==1 и значит инструкция не выполнится
            case  2: j+='б'; // i===2 а значит эта инструкция будет выполнена и отключен режим сравнения с образцами
            case  3: j+='в'; // Все оставшиеся интсрукции выполнятся, т.к. сравнение больше не производится
            case  4: j+='д'; // Директиву default можно опускать
        }                    // j == "бвд_"
        console.log("Начиная с числа " + i + " идет набор букв " + j); 

    
    // Тернарная условная операция. Это операция, возвращающая свой второй или третий операнд в зависимости от значения логического выражения, заданного первым операндом. 
        bool1 = (numb1 > 10) ? true : false; // Формат записи:      условие ? значение1 : значение2
        bool1 = numb1 > 10 ? true : false;   // То же самое без скобок (в силу низкого приоритета оператора ?)
        // Цепочка тернарных условных операций
        j = (numb2 = 0)   ? 0 :
            (numb2 < 10)  ? 2 :
            (numb2 < 100) ? 5 :
                            10 ;

    // БЕЗУСЛОВНЫЕ УПРАВЛЯЮЩИЕ КОММАНДЫ 
            https://puzzleweb.ru/javascript/11_loops3.php
        block1: { // Блок операторов можно пометить именованной меткой, завершающейся двоеточием
            i = 2;
            break block1; // Директива break прерывает выполнение блока с указанным именем
            i = 3; // Этот оператор не будет выполнен
        }
        console.log('Выполнение блока операторов прервано. i = ' + i);

}

{/* ЦИКЛЫ */
        https://learn.javascript.ru/while-for
    // Цикл со счётчиком
        Str1 = "";
        for (i=1; i<10; i++) // (начало; условие; шаг) Здесь на каждой итерации счётчик увеличивается на 1 в порядке возрастания.
            Str1 += i + " "; 
        
        for (; i>0; ) // Операторы в условии цикла можно оставлять пустыми  
            Str1 += i-- + " "; 
        console.log("Счет от 1 до 10 и обратно: " + Str1);
            
        var factorial1 = 1;
        for (i=2; i<=5; i++) { // Если в теле цикла несколько операторов, то они заключаются в логический блок {}
            factorial1 = factorial1 * i; 
            console.log(i + '! = ' + factorial1 + '; ');
        }
        
    // Вложенный цикл со счётчиком
        console.log('Таблица сложения:'); 
        for (i=1; i<=5; i++) {
            Str1 = "";
            for (j=1; j<=5; j++) {
                Str1 += Number(i+j) + ' '; 
            }
            console.log(Str1);
        }
        console.log('После выполнения циклов значения счётчиков сохраняются: i = ' + i + ' и j = ' + j);
        
    // Цикл с предусловием
        i=12;
        while (i<90) { // Удваиваем число если оно меньше 90
            i *= 2;
        }
        console.log('Цикл с предусловием окончен. i = ' + i);
        
    // Цикл с постусловием
        do 
            i /= 3;   // Можно использовать несколько операторов без заключения их в блок {}
        while (i>10); // Уменьшаем число в 3 раза пока не преодолеем порог меньше 10
        console.log('Цикл с постусловием окончен. i = ' + i);

    // Перерывание работы цикла
        for (;;i++) { // При таком условии цикл будет повторяться вечно, если его не прервать
            if (i % 2 == 0) continue; // Переход на следующую итерацию текущего цикла
            if (i > 30) break; // Выход из текущего цикла
        } 
        console.log('Вечный цикл окончен. i = ' + i);
  
        console.log('Нечетные строки треугольной таблицы сложения:'); 
        loop1: for (i=1; i<=5; i++) { // Цикл как и обычный блок можно пометить именованной меткой
            Str1 = "";
            loop2: for (j=1; j<=5; j++) {
                if (j > i) break loop2; // Переход на следующую итерацию цикла помеченного меткой loop2
                if (i % 2 == 0) continue loop1; // Выход из цикла помеченного меткой loop1
                Str1 += Number(i+j) + ' ';
            }    
            console.log(Str1);
        } 
    

}