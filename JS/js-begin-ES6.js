"use strict"; 
/* В этом файле преставлен код, демонcтрирующий особенности языка Javascript, появивишиеся 
   в новом стандарте EcmaScript 6. Запускается этот код на странице js-begin-ES6.html, 
   а весь вывод результатов своей работы осуществляет в консоль браузера. 
   
    Откройте этот скрипт в Notepad++ чтобы свернуть блоки в удобное меню простой комбинацией клавиш:
	(Alt + 2)          - свернуть 
    (Alt + Shift + 0)  - развернуть.
    
	То же самое можно сделать в Visual Studio Code:
	(Ctrl + K) + (Ctrl + 2) - свернуть, 
    (Ctrl + K) + (Ctrl + J) - развернуть      */
  

                 
{/* ХРАНЕНИЕ И ОБРАБОТКА ДАННЫХ В ОПЕРАТИВНОЙ ПАМЯТИ. */
  console.groupCollapsed("Хранение и обработка данных в оперативной памяти");

  {/* РАБОТА С ПЕРЕМЕННЫМИ LET И CONST   
          https://learn.javascript.ru/variables
    */
  console.groupCollapsed("Переменные"); 

    // Новые правила объявления и использования переменных
        let str1; /* В стандарте ES6 переменные объявляются с помощью ключевого слова let, которое
            пришло на смену ключевому слову var. В целом использование let практически не отличается 
            от var, за исключением нескольких важных отличий: */
        
        /* Область видимости let-переменной ограничивается не только телом функции (как у var), но
           и любыми блоками кода, обрамлёнными фигурными скобками. 
           Кроме того, если в одной области видимости может быть сколько угодно var-объявлений 
           (у них все слова var кроме первого будут проигнорированы), то let-объявление требует 
           полного отсутствия любых других объявленийпеременной с этим же именем в текущем уровне 
           видимости (иначе будет ошибка): */
        
        str1 = "Внешнее значение";
        var globalStr1 = "Глобальное значение";
        {   
            let str1 = "Внутреннее значение"; /* Повторное объявление переменной возможно только 
              внутри дочернего блока или дочерней функции (в этом случае создаётся новая локальная 
              переменная, невидимая за пределами дочернего блока). */
            let str2 = "Новая локальная переменная"; // Эта переменная видна только внутри блока
            var globalStr2 = "Новая глобальная перменная";  // А эта видна для всего скрипта
            console.log(str1); // "Значение в дочернем блоке"
        }         
        console.log(str1); // "Значение в родительском блоке"

        /* При этом в дочерних блоках переменная родительского блока видна и доступна только если 
           в дочернем блоке нигде не объявлена одноимённая локальная переменная */
        { console.log(str1); // "Значение в родительском блоке"
          str1="Новое значение"
        } 
        console.log(str1); // "Новое значение"
        
        /* Использование необъявленной переменной вне области её видимости вызывает ошибку. В данном
           случае ошибки нет, поскольку переменная объявлена позже (тремя строками ниже): */
        console.log(str2); // undefined
        str2 = "Новое значение"; 
        console.log(str2); // "Новое значение"
        var str2; /* Такое объявление переменной уже после её использования работает, но только со
          словом var - благодаря "всплытию" var-объявлений. Для let и const всплытие не работает. */
    
    // Настоящие константы 
    
        /* С помощью ключевого слова const можно объявлять константы. Оно полностью идентично let 
           за исключением того, что попытка изменения значения такой константы выдаст ошибку. */
        const number_PI = 3.14; 
        
  console.groupEnd("Переменные");
  } 

  {/* НОВЫЙ ТИП ДАННЫХ BIGINT
          https://learn.javascript.ru/types#bigint
    */
  console.groupCollapsed("Новый тип данных BigInt");
    
    /* В ES6 появилась поддержка больших целых числел, что позволяет безопасно работать с числами,
       превышающими значение Number.MAX_SAFE_INTEGER */
       
    // Тип BigInt поддерживается далеко не всеми браузерами, поэтому нужна проверка его наличия:
    if (typeof BigInt == "function") 
           console.log('Большие целые числа поддерживаются!');
      else console.log('Большие целые числа не поддерживаются!');

    if (typeof BigInt == "function") { 
    
        // Записать BigInt значение в переменную можно двумя способами:
        let N = 15n;    // Указать число с символом `n` в конце
        N = BigInt(15); // Применить функцию приведения целого(!) числа к BigInt 
        console.log(N); // 15n    
    
    // Использование больших целых чисел:
          
        // Для обычных чисел мы имеем известное ограничение:
        let n = Number.MAX_SAFE_INTEGER; /* 9007199254740991 */
        let b = (n+1) == (n+2); // Результат true (обе суммы дают результат 9007199254740992) 
        
        // Если же вместо обычных чисел использовать большие целые, то проблема исчезает
        N = BigInt(Number.MAX_SAFE_INTEGER);
        b = (N+1n) == (N+2n); // Результат false, т.к. второе число равно
        console.log(N+2n);    // 9007199254740993n
    
    // Операции
    
        /* К большим целым можно применять операции +,-,*,/,% но автоматическое  приведение типов 
           не работает - т.е. в них к обычному числу нужно применять функцию BigInt() */
        N = N * BigInt(n) ;
        console.log(N);        // 81129638414606663681390495662081n   
        console.log(13n / 5n); // 2n (в операциях деления возвращается целая часть)
        console.log(13n % 5n); // 3n (остаток)
        
        /* Для обратного приведения можно использовать только функцию Number(). При этом для очень 
           больших значений результат преобразования может оказаться округлённым, т.к. 64 бита 
           обычного числа может не хватить для хранения точного значения большого числа. */ 
        n = Number(N);
        console.log(n);         // 8.112963841460666e+31
        console.log(N);         // 81129638414606663681390495662081n
        console.log(BigInt(n)); // 81129638414606663681390495662080n
        
        /* А вот в операциях сравнения и логических операциях автоматическое приведение работает:
           Во всех нижепреведенных сравнениях результат равен true:  */
        b = 3n > "2"      && // Строка привелась к BigInt
            7n == 7       && // Number приведен к BigInt  
            7n !== 7      && // Типы Number и BigInt разные
            !!-1n == true && // Отличное от нуля большое число при булевом преобразовании равно true
            !!0n == false && // а нулевое - false
            typeof 1n == "bigint";
        console.log("Результат всех сравнений и логических операций: " + b); // true

    }
  console.groupEnd("Новый тип данных BigInt");
  } 
  
  console.groupEnd("Хранение и обработка данных в оперативной памяти");
}

